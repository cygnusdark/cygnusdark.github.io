<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器学习模型效果评估指标</title>
      <link href="/2023/07/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E6%95%88%E6%9E%9C%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87/"/>
      <url>/2023/07/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E6%95%88%E6%9E%9C%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在机器学习模型中，准确率、AUC、召回率和精度是常用的性能指标，用于评估模型的表现。这些指标有着不同的含义和用途，下面逐一进行解释：</p></blockquote><ol><li>准确率（Accuracy）：指模型正确分类的样本数占总样本数的比例。准确率越高，表示模型分类的正确率越高。</li><li>AUC（Area Under the Curve）：指模型在 ROC 曲线下的面积。AUC 的值介于 0 到 1，越接近 1，表示模型分类的准确率越高。</li><li>召回率（Recall）：指模型正确识别的正样本数占所有正样本的比例。召回率越高，表示模型能够捕捉到更多的正样本，但可能会将一些负样本错误地分类为正样本。</li><li>精度（Precision）：指模型正确识别的正样本数占所有被分类为正样本的样本的比例。精度越高，表示模型分类的准确率越高，但可能会遗漏一些正样本。</li></ol><p>这些指标通常用于比较不同模型的的表现，或者评估同一模型在不同数据集上的表现。在实际应用中，需要根据具体的问题和需求来选择适当的的表现指标。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink Checkpoint机制</title>
      <link href="/2023/07/01/Flink%20Checkpoint%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/07/01/Flink%20Checkpoint%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="checkpoint的过程包含了JobManager和Taskmanager端task的执行过程，按照步骤为"><a href="#checkpoint的过程包含了JobManager和Taskmanager端task的执行过程，按照步骤为" class="headerlink" title="checkpoint的过程包含了JobManager和Taskmanager端task的执行过程，按照步骤为"></a>checkpoint的过程包含了JobManager和Taskmanager端task的执行过程，按照步骤为</h1><ol><li><p>在JobManager端构建ExecutionGraph过程中会创建CheckpointCoordinator，这是负责checkpoint的核心实现类，同时会给job添加一个监听器CheckpointCoordinatorDeActivator（只有设置了checkpoint才会注册这个监听器），在JobManager端开始进行任务调度的时候，会对job的状态进行转换，由CREATED转成RUNNING，job监听器CheckpointCoordinatorDeActivator就开始启动checkpoint的定时任务了，最终会调用CheckpointCoordinator.startCheckpointScheduler()</p></li><li><p>CheckpointCoordinator会部署一个定时任务，用于周期性的触发checkpoint，这个定时任务就是ScheduledTrigger，在触发checkpoint之前先做一遍检查，检查当前正在处理的checkpoint是否超过设置的最大并发checkpoint数量，检查checkpoint的间隔是否达到设置的两次checkpoint的时间间隔，在都没有问题的情况下向所有的source task去触发checkpoint，远程调用TaskManager的triggerCheckpoint()方法</p></li><li><p>TaskManager的triggerCheckpoint()方法首先获取到source task（即SourceStreamTask），调用Task.triggerCheckpointBarrier()，triggerCheckpointBarrier()会异步的去执行一个独立线程，这个线程来负责source task的checkpoint执行。checkpoint的核心实现在StreamTask.performCheckpoint()方法中，该方法主要有三个步骤</p></li></ol><ol><li><p>在checkpoint之前做一些准备工作，通常情况下operator在这个阶段是不做什么操作的</p></li><li><p>立即向下游广播CheckpointBarrier，以便使下游的task能够及时的接收到CheckpointBarrier也开始进行checkpoint的操作</p></li><li><p>开始进行状态的快照，即checkpoint操作。</p></li></ol><p>注意以上操作都是在同步代码块里进行的，获取到的这个lock锁就是用于checkpoint的锁，checkpoint线程和task任务线程用的是同一把锁，在进行performCheckpoint()时，task任务线程是不能够进行数据处理的</p><ol start="4"><li><p>checkpoint的执行过程是一个异步的过程，保证不能因为checkpoint而影响了正常数据流的处理。StreamTask里的每个operator都会创建一个OperatorSnapshotFutures，OperatorSnapshotFutures 里包含了执行operator状态checkpoint的FutureTask，然后由另一个单独的线程异步的来执行这些operator的实际checkpoint操作，就是执行这些FutureTask。这个异步线程叫做AsyncCheckpointRunnable，checkpoint的执行就是将状态数据推送到远程的存储介质中</p></li><li><p>对于非Source Task，checkpoint的标志性开始在接收到上游的CheckpointBarrier，方法在StreamTask中的CheckpointBarrierHandler.getNextNonBlocked()。CheckpointBarrierHandler会根据CheckpointingMode模式不同生成不同的Handler，如果是EXACTLY_ONCE，就会生成BarrierBuffer，会进行barrier对齐，保证数据的一致性，BarrierBuffer中的CachedBufferBlocker是用来缓存barrier对齐时从被阻塞channel接收到的数据。如果CheckpointingMode是AT_LEAST_ONCE，那就会生成BarrierTracker，不会进行barrier对齐，而是继续处理数据，在接收到上游task所有的CheckpointBarrier才开始进程checkpoint，这样就会checkpoint(n)的状态会包含checkpoint(n+1)的数据，数据不一致。非Source Task的checkpoint执行跟步骤3、4是一样的，只不过触发的线程是Task工作线程，跟source task不一样</p></li><li><p>Task在执行完checkpoint后会向JobManager上报checkpoint的元数据信息，JobManager端的CheckpointCoordinator会调用PendingCheckpoint.acknowledgeTask()方法，该方法就是将task上报的元数据信息（checkpoint的路径地址，状态数据大小等等）添加到PendingCheckpoint里</p></li><li><p>task的checkpoint会一直进行到sink task。JobManager如果接收到了全部task上报的的Ack消息，就执行completePendingCheckpoint()，会将checkpoint元数据信息进行持久化，然后通知所有的task进行commit操作，一般来说，task的commit操作其实不需要做什么，但是像那种TwoPhaseCommitSinkFunction，比如FlinkKafkaProducer就会进行一些事物的提交操作等，或者像FlinkKafkaConsumer会进行offset的提交</p></li><li><p>所有task执行完commit操作后（实际上执行的是operator.notifyCheckpointComplete()方法），一个完整的checkpoint流程就完成了</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术规划50问</title>
      <link href="/2023/07/01/%E6%8A%80%E6%9C%AF%E8%A7%84%E5%88%92/"/>
      <url>/2023/07/01/%E6%8A%80%E6%9C%AF%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/tag-bg.jpg" alt="img"></p><ol><li>如何调整技术方向如何平衡技术开发和业务交付精力？</li><li>技术规划应该包括哪些内容？</li><li>   如何做一个业务上能落地而且会落地，而不是高高在上的技术规划</li><li>   技术预研的舍与得如何去平衡（效率&amp;成本&amp;其他等等），开源以及自研技术，有哪些倾向性选择？</li><li>   技术规划如何更能接地气，可持续？</li><li>   技术规划有没有好的方法论或者最佳实践？</li><li>   如何推动技术规划真正落地，实现价值</li><li>   技术规划的出发点是什么？与产品规划如何同步？</li><li>如何合理的制定短期规划和长期规划？</li><li>技术规划如何能做到业界领先，如何能让高层信服，如何能保证高质量落地？</li><li>技术规划有什么机制保障尽可能的落地？</li><li>如何结合业界趋势，做出贴合业务带来收益的实际产品？这中间有没有什么方法论？</li><li>如何看到领域内远期的（3-5）年的技术&#x2F;产品趋势，如何评估是否靠谱&#x2F;能否落地&#x2F;能否产生收益？</li><li>如何让技术规划获得更广泛的支持认可；没有业务，即需要自己拓展业务时，如何做技术规划</li><li>一个优秀技术规划的产出流程一般是什么样子的</li><li>在技术规划中遇到自己不擅长的领域如何规划处理</li><li>如何避免过度设计；如何权衡长短期规划</li><li>越实际的问题就有越明确的技术方案，而技术规划要面临下一个周期提前布局，其中的潜在逻辑是什么。</li><li>技术规划的落地执行往往由于实际需求&#x2F;方向变化会产生变形，如何快速调整，说明意义。</li><li>技术的先进性和成熟度怎么平衡？</li><li>方法论上的东西都知道，但是真正做技术规划的时候，一些长期有价值的技术方向还是很难想出来，这个时候如何办？</li><li>技术规划中，如何加强跨BUBG的协同合作</li><li>技术规划中技术驱动的项目如何与业务发展与指标相匹配，落地节奏怎么安排</li><li>技术方向调整，技术与管理如何选择</li><li>业务成长出现困境，如何更好的突破困境，逆境中发现机会点</li><li>学海无涯，技术精进的道路没有止境，如何平衡工作学习和生活？</li><li>如何兼具技术架构与技术细节把我能力，同时具备产品化的思维方式？</li><li>如何让自己的技术架构能力 cover bg 级别或者一个中小厂的技术团队（目标）</li><li>面临层出不穷的一线新技术问题，关于架构师在保持技术敏感度方面该如何做？</li><li>如何在有限的资源下，增强团队凝聚力和战斗力？</li><li>小组各个同学技术方向不同，如何对其产出进行横向评比？</li><li>如何在日常繁杂的业务中脱身而出，拓展出具有影响力的技术？</li><li>最为技术人员一般都在讲”T”字型发展模式，如何选定一个有价值高回报的方向去深入了解</li><li>技术日行千里，如何保持个人进步的节奏</li><li>以架构师为个人成长目标，如何系统性的制订个人学习计划？平时需关注哪些提升的途径？</li><li>架构师和具体实现间怎么平衡？架构师是否必须要承担部分PM的职责？</li><li>偏后端的基础工程架构，如何能更主动的帮助到业务的发展，以及在业务sense上如何得到成长？</li><li>停留在T7&#x2F;T8级别，难于跨越的这条洪沟是什么？如何跨过呢？</li><li>如何拓宽知识的广度，如果没有实战经验，纯看书看论文理解应该不够深刻</li><li>技术规划的目标定义了，但是找路径的时候不知道怎么做？</li><li>如何设计一个高可用高可扩展的架构？如何能够控制系统复杂度？</li><li>如何结合现有业务做长期三年规划架构师如何在人力紧张或者没有人力的时候快速落地技术规划</li><li>架构师是一个技术岗位，我一直是技术驱动在做人做事。但与其说架构师是在管理技术，不如说是在管理人。管理团队的人与管理团队中的技术，我想明确这是不是两种不同的管理风格，应该如何侧重？</li><li>技术迭代速度快，架构师的视野是否会限制团队的技术演进；是需要架构师时刻紧跟各领域技术趋势，还是可以有机制保证业务技术先进性</li><li>工作中涉及到的业务功能较多时，作为架构师该如何找到技术能力与业务能力之间的平衡点</li><li>如何在涉及到广度的时候，保持敏锐的技术判断力如何能更快速有效的提升自己，抓大放小，以便于进一步优化工作效率。想听听过来人的经验</li><li>T9需要什么标准</li><li>技术规划的长短期价值怎么权衡，比如在人力时间资源上的分配？</li><li>项目复盘怎么做才能更好的帮助技术规划调整？</li><li>作为一个技术leader，如何帮助团队去判断产品方向？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 保证数据一致性</title>
      <link href="/2022/12/01/Flink%20%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/2022/12/01/Flink%20%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>在Flink中，会自动做检查点，用于故障时恢复一个应用。在恢复时，application的state信息可以根据最近完成的检查点进行重建，并继续运行。不过，仅将一个application的state进行重置并不足以满足exactly-once的保证。</p><p>为了给一个应用提供exactly-once保证，在应用根据检查点重置state时，它的每个source connector都应该有能力将它的read position重置到做检查点时的read position。在做一个检查点时，source operator将它的read position也持久化，并在恢复时根据此位置进行重置。对于这类可以重置read position的source connector，比较有代表性的有：</p><p>基于文件的源：可以存储读文件字节流时的偏移量<br>Kakfa：可以存储读入topic partition的偏移量</p><p>如果一个application从一个无法重置read position的source connector读数据，则在故障发生并恢复时，只能提供at-most-once 的保证。</p><p>Flink的检查点与恢复机制、结合可重置reading position的source connector，可以确保一个应用不会丢失任何数据。但是，此应用仍可能输出同一数据两次。因为若是应用故障发生在两次检查点之间，则必定会导致已经成功输出的数据再次输出一次。所以仅通过Flink与source connector的行为，并不足以提供端到端的exactly-once保证，即使application的state具有exactly-once的保证。</p><p>一个application若是需要提供端到端exactly-once 的保证，则需要特殊的sink connectors。对于sink connectors来说，有两种技术可以应用于不同的场景，用于达到exactly-once的保证，分别为：idempotent writes、以transactional writes。</p><h1 id="Idempotent-Writes"><a href="#Idempotent-Writes" class="headerlink" title="Idempotent Writes"></a>Idempotent Writes</h1><p>一个idempotent 操作可被执行多次，但是仅会产生一个变化。例如向一个hashmap中插入同样的key-value pair，这即为一个idempotent操作。因为仅有第一次操作会在hashmap中增加此条目，而之后的插入不会改变hashmap中的内容。一个非 idempotent 操作的例子如追加操作，即使是同样的数据，每次追加都会增加一条数据。在流应用中，idempotent write是一个很有特点的操作，它们可以多次执行，但并不改变最终的结果。所以在Flink根据检查点机制进行恢复时，可以在一定程度上缓解replay对结果造成的影响（或是没有影响）。</p><p>需要注意的是，若是一个应用依赖于idempotent sinks，以达到exactly-once 的结果，则必须保证的是：在replay时覆盖之前写的结果。一般来说，只要流应用在replay时正常执行并输出，在新的输出覆盖掉之前写的结果后，即可以正常到达一致状态。</p><h1 id="Transactional-Writes"><a href="#Transactional-Writes" class="headerlink" title="Transactional Writes"></a>Transactional Writes</h1><p>第二种实现端到端exactly-once 一致性的方法是基于transactional writes。这个方法基于的想法是：仅在最近一个检查点成功完成后，才将所有结果写入到一个外部的sink系统。这个行为可以实现端到端exactly-once的原因是因为：在故障发生时，应用会被重置到最近的检查点，并且在此检查点之后，没有任何结果被写入到外部sink系统。但是此方法会增加延时，因为结果仅能在一个检查点完成后才能看到。</p><p>Flink提供了两种方式分别实现transactional sink connectors – 一个通用的 write-ahead-log（WAL<br>）以及一个two-phase-commit（2PC）sink。WAL sink将所有result records写入应用的state，并在它收到了一个“检查点完成”的通知后，将结果输出到sink 系统。因为WAL sink会将result records缓存到state backend，所以它可以用于任何sink 系统中。然而，使用此方法实现的exactly-once仍会有些代价：增加了应用的state大小，并且sink 系统需要处理突增写入的模式。</p><p>与WAL不同的是，2PC sink需要sink system提供事务支持，或者提供模拟事务的支持。对于每个检查点，sink首先启动一个事务，将所有接收到的记录添加到事务中，并将它们写入sink系统，但是不提交（commit）。当它收到一个“检查点完成”的通知后，它提交事务，并将结果落盘。</p><p>2PC协议集成在Flink的检查点机制中。Checkpoint barriers便是启动一个新事务的通知，所有operators中对于它“自身检查点完成”的通知，即是它们的commit 投票。JobManager的对于“整个检查点完成”的消息，即为提交事务的指示。</p><p>相对于WAL sinks，2PC sinks是基于sink 系统以及sink的实现方式，达到exactly-once的输出保障。而 相对于WAL sink的突增写入模式，2PC sink为持续向sink 系统写入记录。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 数据倾斜优化</title>
      <link href="/2022/12/01/Flink%20%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E4%BC%98%E5%8C%96/"/>
      <url>/2022/12/01/Flink%20%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>当进行聚合运算时（GroupBy&#x2F;KeyBy + Agg），如果聚合所使用的key存在热点，则会导致数据倾斜。如统计某日各个省份的车流量，则负责运算北京、上海等一线城市的count subtask节点则会成为热点，处理数据的压力会比较大。</p><h1 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h1><h2 id="任务卡死"><a href="#任务卡死" class="headerlink" title="任务卡死"></a>任务卡死</h2><p>keyBy 或 rebalance 下游的算子，如果单个 subtask 存在热点并完全卡死，会把整个 Flink 任务卡死。看如下示例：<br>如下图所示，上游每个 Subtask 中会有 3 个 resultSubPartition，连接下游算子的 3 个 subtask。下游每个 subtask 会有 2 个 InputChannel，连接上游算子的 2 个 subtask。Local BufferPool为subtask中的ResultSubpartition&#x2F;InputChannel所共用，在正常运行过程中如果没有反压，所有的 buffer pool 是用不完的。</p><p>一旦subtask B0变成热点，则会引起反压，依次产生如下问题：</p><ol><li>Subtask B0 内的 A0 和 A1 两个 InputChannel 会被占满；Subtask B0 公共的 BufferPool 中可申请到的空间也被占满</li><li>Subtask A0 和 A1 的 B0 ResultSubPartition 被占满；Subtask A0 和 A1 公共的 BufferPool 中可申请到的空间也被占满</li><li>如图2所示，Subtask A0 的主线程会从上游读取数据消费，按照数据的 KeyBy 规则，将数据发送到 B0、B1、B2 三个 ResultSubpartition 中；可以看到，如果 B0 这个ResultSubpartition占满了，且 B0 在公共的 Local BufferPool 中可申请到的空间也被占满。现在有一条数据被keyby后发往B0，但是现在 B0 这个ResultSubpartition 没有空间了，所以主线程就会卡在申请 buffer 上，直到可以再申请到 buffer</li></ol><p>Subtask A0 的主线程被卡住，则不会往下游的任何subtask发送数据了，如图1所示，下游的Subtask B1和Subtask B2不再接收新数据。整个任务处于瘫痪状态</p><h2 id="Checkpoint时间变长"><a href="#Checkpoint时间变长" class="headerlink" title="Checkpoint时间变长"></a>Checkpoint时间变长</h2><p>checkpoint barrier也是一种特殊的数据，如果整个任务中各个可用buffer变少，则checkpoint barrier的传输也会因为找不到可用buffer而降低速度；由于checkpoint barrier的对齐机制，会造成当前checkpoint的barrier迟迟无法对齐，进而超时。</p><h2 id="State变大"><a href="#State变大" class="headerlink" title="State变大"></a>State变大</h2><p>对于有两个以上输入管道的 Operator，存在checkpoint barrier对齐机制，接受到较快的输入管道的 barrier 后，它后面数据会被缓存起来但不处理，直到较慢的输入管道的 barrier 也到达，这些被缓存的数据会被放到state 里面，导致 checkpoint 变大。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><h2 id="修改分区策略"><a href="#修改分区策略" class="headerlink" title="修改分区策略"></a>修改分区策略</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>让不需要shuffle的两个算子间进行shuffle，打乱数据，从而避免数据倾斜</p><h3 id="手段"><a href="#手段" class="headerlink" title="手段"></a>手段</h3><p>在Flink任务提交后，经常可以看到web ui中的一些算子之间采用的分区策略是forward，在该分区策略下很可能会存在数据倾斜现象。如以下情况：<br>某kafka topic统计每个省份的车次，针对每个省份都有一个partition，共计36个partition，同时设有36个source算子，36个flatmap算子。由于source和flatmap满足one-to-one关系，且并行度相同，则Flink默认会采用forward这个分区策略来关联source和flatmap这两个算子。<br>Flink默认设置forward分区策略有两个条件：</p><ol><li>两个算子满足one-to-one关系</li><li>两个算子并行度相同</li></ol><p>此时，北京和上海对应的flatmap算子必然会出现热点数据，由于source到flatmap算子之间并不需要有特定的对应关系，因此可以采用不同的分区策略来将数据打乱，让不同省份的车流数据落到所有的flatmap算子，消除数据倾斜。</p><p>因此，我们只需要破坏forward分区策略的条件即可</p><ol><li>修改两个算子的并行度</li><li>强行设定分区策略：<code>dataStream.rebalance();</code></li></ol><h2 id="两阶段聚合"><a href="#两阶段聚合" class="headerlink" title="两阶段聚合"></a>两阶段聚合</h2><p>所谓两阶段聚合，即在需要shuffle的两个算子之间，再加一层算子</p><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><p>先进行一次聚合，减小算子2和算子3之间的数据量，减轻算子2和算子3之间的热点问题<br>新增新的shuffle，打散算子1和算子2之间的数据，减轻算子1和算子2之间的热点问题</p><h3 id="手段-1"><a href="#手段-1" class="headerlink" title="手段"></a>手段</h3><p>我们以sql的优化作为范例进行讲解，这样更加直观和简洁。DataStream API无非就是仿照sql的group by + agg模式，增加一层keyby + agg。</p><h4 id="修改sql"><a href="#修改sql" class="headerlink" title="修改sql"></a>修改sql</h4><p>有如下需求，按天统计每个类目的成交额</p><pre><code class="sql">SELECT     date_format(ctime, &#39;%Y%m%d&#39;) as cdate, -- 将数据从时间戳格式（2018-12-04 15:44:54），转换为date格式(20181204)       category_id,    sum(price) as category_gmvFROM srcGROUP BY date_format(ctime, &#39;%Y%m%d&#39;), category_id; --按照天做聚合</code></pre><p>以这个SQL为例，其数据流程图如下，一个小方块表示一条成交记录，不同颜色代表不同的category_id<br>Group By + Agg 模式中，SQL作业性能与数据分布非常相关，如果数据中存在数据倾斜，也就是某个key的数据异常的多，那么某个聚合节点就会成为瓶颈，作业就会有明显的反压及延时现象。<br>用两阶段聚合方法优化后的SQL如下：</p><pre><code class="sql">SELECT cdate,category_id,sum(category_gmv_p) as category_gmvFROM(    SELECT         date_format(ctime, &#39;%Y%m%d&#39;) as cdate, -- 将数据从时间戳格式（2018-12-04 15:44:54），转换为date格式(20181204)           category_id,        sum(price) as category_gmv_p    FROM src    GROUP BY category_id, mod(hash_code(FLOOR(RAND(1)*1000), 256),date_format(ctime, &#39;%Y%m%d&#39;); --按照天做聚合)GROUP BY cdate,category_id</code></pre><p>SQL中做了将一个Group By+Agg拆称了两个，子查询里按照category_id和mod(hash_code(FLOOR(RAND(1)*1000), 256)分组，将同一个category_id上的数据打散成了256份，先做一层聚合。外层Group By+Agg，将子查询聚合后的结果再次做聚合。这样通过两层聚合的方式，即可大大缓解某聚合节点拥堵的现象。其数据流程图如下：<br>这种方法达到了两个优化目标，在日期的基础上再将数据分成256份，打散数据，减轻算子1和算子2之间的热点问题；在算子2进行了初步的sum聚合，减小了到达算子3的数据量，减轻了算子2和算子3之间的热点问题。 该方法通过取余的方式将数据进一步打散，另有给key添加随机数的方式进行打散</p><h4 id="Local-Global"><a href="#Local-Global" class="headerlink" title="Local-Global"></a>Local-Global</h4><p>LocalGlobal和PartialFinal其实都属于两阶段聚合，只不过封装了拆解逻辑，我们只需要对Flink SQL任务做简单的配置即可。</p><p>LocalGlobal优化可以用来解决聚合时的数据倾斜问题。其核心思想是，将聚合分为两个阶段执行，先在上游进行局部(本地&#x2F;Local)聚合，再在下游进行全局(Global)聚合，类似MapReduce的Combine + Reduce，即先进行一个本地Reduce，再进行全局Reduce。该方法，只完成了先进行一次聚合，减少数据量这个目标<br>以如下场景为例</p><pre><code class="sql">SELECT color, sum(id)FROM TGROUP BY color</code></pre><p>开启LocalGlobal：</p><pre><code class="java">TableEnvironment tEnv = ...Configuration configuration = tEnv.getConfig().getConfiguration();// 要使用LocalGlobal优化，需要先开启MiniBatch configuration.setString(&quot;table.exec.mini-batch.enabled&quot;, &quot;true&quot;); configuration.setString(&quot;table.exec.mini-batch.allow-latency&quot;, &quot;5 s&quot;);configuration.setString(&quot;table.exec.mini-batch.size&quot;, &quot;5000&quot;);// 开启LocalGlobalconfiguration.setString(&quot;table.optimizer.agg-phase-strategy&quot;, &quot;TWO_PHASE&quot;);</code></pre><h4 id="Partial-Final"><a href="#Partial-Final" class="headerlink" title="Partial-Final"></a>Partial-Final</h4><p>LocalGlobal优化针对普通聚合（例如SUM、COUNT、MAX、MIN和AVG）有较好的效果，对于COUNT DISTINCT收效不明显，因为COUNT DISTINCT在Local聚合时，对于DISTINCT KEY的去重率不高，导致在Global节点仍然存在热点<br>如下场景，统计一天的UV</p><pre><code class="sql">SELECT day, COUNT(DISTINCT user_id)FROM TGROUP BY day</code></pre><p>如果user_id比较稀疏，即便开启了LocalGlobal优化，收效也并不明显，因为COUNT DISTINCT在Local阶段时，去重率并不高，这就导致在Global阶段仍然存在热点问题。不满足第一条目标和第二条目标。<br>为了解决这一问题，需要将原始聚合拆分成两层聚合:</p><pre><code class="sql">SELECT day, SUM(cnt)FROM (    SELECT day, COUNT(DISTINCT user_id) as cnt    FROM T    GROUP BY day, MOD(HASH_CODE(user_id), 1024))GROUP BY day</code></pre><p>现在Blink Planner提供了PartialFinal功能，无需自己拆解sql，只要简单的配置即可，配置如下：</p><pre><code class="java">TableEnvironment tEnv = ...Configuration configuration = tEnv.getConfig().getConfiguration();// 开启MiniBatch configuration.setString(&quot;table.exec.mini-batch.enabled&quot;, &quot;true&quot;); configuration.setString(&quot;table.exec.mini-batch.allow-latency&quot;, &quot;5 s&quot;);configuration.setString(&quot;table.exec.mini-batch.size&quot;, &quot;5000&quot;);// 开启LocalGlobalconfiguration.setString(&quot;table.optimizer.agg-phase-strategy&quot;, &quot;TWO_PHASE&quot;);// 开启Split Distinctconfiguration.setString(&quot;table.optimizer.distinct-agg.split.enabled&quot;, &quot;true&quot;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程常见问题</title>
      <link href="/2022/11/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2022/11/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="线程的状态有哪些？"><a href="#线程的状态有哪些？" class="headerlink" title="线程的状态有哪些？"></a>线程的状态有哪些？</h1><p>线程的生命周期大致分为5个阶段：<br>NEW（新建）：新建一个Thread对象时，此时还没有线程。<br>RUNNABLE（就绪）：调用start方法可以使线程进入就绪状态。<br>RUNNING（运行）：处于就绪状态的线程获得了CPU就可以执行业务，进入运行状态。<br>BLOCKED（阻塞）：处于运行状态的线程如果调用了sleep、wait方法或者竞争锁失败会进入阻塞状态。<br>TERMINATED（终止）：线程正常结束或者意外终止会进入终止状态。<br>线程的生命周期是比较基础的知识，一般是作为一个切入点有浅入深的问其他问题，在回答这个问题的时候不要干巴巴的只说5个状态单词，要把每个状态是怎么进入的也要讲一下。你如果不讲，面试官就会继续追问：那线程在哪些情况会进入阻塞状态呢？</p><h1 id="synchronized锁的升级机制"><a href="#synchronized锁的升级机制" class="headerlink" title="synchronized锁的升级机制"></a>synchronized锁的升级机制</h1><p>synchronized是JVM关键字，可以用来修饰代码块、方法（普通方法和静态方法），它是一个可重入的不可打断的锁。<br>线程竞争synchronized锁其实是对锁对象monitor的竞争，代码块是Object锁对象的monitor，方法是this monitor，静态方法是class monitor。<br>锁的升级机制：<br>synchronized在JDK1.5时锁竞争失败后会直接进入阻塞状态，线程上下文之间切换比较消耗CPU性能，在JDK1.5之后对锁进行了优化，引入了无锁，偏向锁，轻量级锁和重量锁。锁的升级过程即是无锁状态到重量级锁状态的变化过程。<br>锁对象头（Mark Word）有一个偏向标志，无锁状态时为0，当线程获取到锁时会把偏向标志修改为1，并且CAS把对象头中的线程ID修改为自己的线程ID，当下一个线程竞争锁时，发现偏向标志为1，且锁还未释放，则会复制对象头的信息到自己线程的Lock Record中，并且CAS修改对象头中的指针指向自己的LR，如果修改失败则自旋一定次数后（默认10次）升级为重量级锁，此时竞争失败的线程将会挂起。</p><h1 id="synchronized和lock的区别？"><a href="#synchronized和lock的区别？" class="headerlink" title="synchronized和lock的区别？"></a>synchronized和lock的区别？</h1><p>特点：synchronized是独占可重入锁，是非公平的竞争锁方式。ReentrantLock也是独占可重入锁，但是其可以指定为公平锁，默认是非公平锁。<br>用法：synchronized可以修饰方法和代码块，不需要显示的加锁和解锁。ReentrantLock修饰代码块，在lock()和unlock()方法中间的代码都是同步代码，需要显示的加锁和解锁，将锁的控制权交给了开发人员。<br>性能：基于JVM对关键字的支持，单线程下synchronized关键字性能要优于ReentrantLock，但是多线程环境下ReentrantLock性能优于synchronized。<br>高级特性：获取synchronized锁失败的线程会一直阻塞直到获取到锁，不能中断。ReentrantLock提供了可中断获取锁的方法lockInterruptibly()，而且还提供了获取锁失败不阻塞立即返回的方法tryLock()，如果开发场景中涉及到了高级应用，那就只能选择显示锁Lock了。</p><h1 id="两种锁的使用场景？"><a href="#两种锁的使用场景？" class="headerlink" title="两种锁的使用场景？"></a>两种锁的使用场景？</h1><p>在多数情况下会优先选择synchronized关键字，在必须要用到高级特性的时候选择Lock锁。另外一点就是要注意synchronized锁升级的不可逆性，并发量谷峰值差别较大的时候优先选择Lock锁。</p><h1 id="开发中你是怎么创建线程的？"><a href="#开发中你是怎么创建线程的？" class="headerlink" title="开发中你是怎么创建线程的？"></a>开发中你是怎么创建线程的？</h1><p>有4种创建方式，通常使用线程池的方式管理线程，并且线程的参数都是可配置的。</p><h1 id="线程池的参数有哪些？"><a href="#线程池的参数有哪些？" class="headerlink" title="线程池的参数有哪些？"></a>线程池的参数有哪些？</h1><p>corePoolSize：核心线程数量，即使线程池中的线程空闲也会一直保持此数量的线程，除非设置了allowCoreThreadTimeOut为true。<br>maximumPoolSize：线程池中允许的最大线程数量。<br>keepAliveTime：当线程池中的线程数量超过了核心线程的数量，在回收空闲的线程时线程将等待任务的最大时间，超过这个时间还没有任务执行，那么线程将会被回收。<br>unit：超过核心线程数量的线程空闲时等待任务的时间单位。<br>workQueue：用于存放提交任务的工作队列，这个队列只存放提交但是未执行的Runnable。<br>threadFactory：创建线程的工厂。<br>handler：当线程数量和队列元素都达到最大时，拒绝再次提交任务的策略。</p><h1 id="线程池的拒绝策略有哪些？开发中你是怎么选择的？"><a href="#线程池的拒绝策略有哪些？开发中你是怎么选择的？" class="headerlink" title="线程池的拒绝策略有哪些？开发中你是怎么选择的？"></a>线程池的拒绝策略有哪些？开发中你是怎么选择的？</h1><p>拒绝策略有4种：直接丢弃，丢弃队列中第一个任务，抛出异常，调用者执行。<br>前两个开发中一般较少选择，因为不可控。开发中勾勾用过后面两种：抛出异常捕获了记录日志。让主线程去执行保证任务一定被运行。</p><h1 id="开发中使用多线程要注意什么？"><a href="#开发中使用多线程要注意什么？" class="headerlink" title="开发中使用多线程要注意什么？"></a>开发中使用多线程要注意什么？</h1><p>避免死锁</p><h1 id="什么情况下会发生死锁？"><a href="#什么情况下会发生死锁？" class="headerlink" title="什么情况下会发生死锁？"></a>什么情况下会发生死锁？</h1><p>交叉锁互相等待肯定会死锁，还有比如内存不足导致线程无法执行，死循环导致的锁无法释放，显示锁开发人员忘记释放锁也会导致死锁。<br>问到这里可能面试官真的就多嘴一问：你们项目中遇到过死锁的情况吗，线上是怎么排查的？</p><h1 id="什么是乐观锁和悲观锁？"><a href="#什么是乐观锁和悲观锁？" class="headerlink" title="什么是乐观锁和悲观锁？"></a>什么是乐观锁和悲观锁？</h1><p>乐观锁和悲观锁都是一种思想，有对应的实现。乐观锁主要用于多读的场所，悲观锁主要用于多写的场所。<br>悲观锁：在修改数据之前先加锁，再对数据进行修改的加锁方式。在数据修改的整个过程中都会加锁。悲观锁又分为读锁和写锁。<br>乐观锁：在修改数据前不需要加锁，只有在对数据进行修改的时候才会进行检测。可以利用CAS实现乐观锁。<br>CAS比较并交换，但是会出现ABA的问题，如果不能接受ABA那么在比较的时候可以添加版本号。</p><h1 id="volatile关键字的作用？"><a href="#volatile关键字的作用？" class="headerlink" title="volatile关键字的作用？"></a>volatile关键字的作用？</h1><p>volatile关键字是一个轻量级锁，它可以保证可见性和有序性，但是不能保证原子性。<br>此时面试官可能会问：它是如何保证可见性和有序性的，为什么不能保证原子性？<br>读volatile修饰的变量时，会从主内存中取数据，然后在线程的工作内存中创建变量副本。写volatile修饰的变量时，会对总线lock加锁，此时其他CPU都不能访问到这个变量，当线程将修改后的数据写入主内存并通知其他CPU的数据失效后，对总线解锁。其他线程在后续的过程中因为变量失效不得不从主内存再次获取数据，从而保证了可见性。<br>有序性就是通过内存屏障实现的。</p><h1 id="ThreadLocal原理是什么？"><a href="#ThreadLocal原理是什么？" class="headerlink" title="ThreadLocal原理是什么？"></a>ThreadLocal原理是什么？</h1><p>ThreadLocal可以实现线程之间的分离，ThreadLocal修饰的变量，每个线程都会复制一份，因此常用来修饰静态变量。ThreadLocal内部维护了Entry数组，其中key是当前线程，Value是用户存入的变量。<br>ThreadLocal内部类Entry继承了弱引用，key是weak的引用，一旦GC不管内存是否充足都会被回收，但是value是强引用，会存在null的key指向value，因而造成内存泄漏。因此使用结束需要手动的remove，避免内存泄漏。</p><h1 id="AQS的原理是什么？"><a href="#AQS的原理是什么？" class="headerlink" title="AQS的原理是什么？"></a>AQS的原理是什么？</h1><p>AQS是JUC工具类的核心，它内部维护了volatile的状态变量state，锁的竞争即是对state的竞争，竞争失败的线程会加入阻塞队列，它是一个先进先出的队列。AQS提供了不同的获取锁和释放锁的操作，包括独占模式（公平和非公平的获取锁方式），共享模式，条件等待模式。线程的node节点对象维护了4个状态：CANCLLED、SIGNAL、CONDITION、PROPAGATE ，决定了线程是否需要挂起和唤醒。</p><h1 id="CountDownLatch和CyclicBarrier的区别"><a href="#CountDownLatch和CyclicBarrier的区别" class="headerlink" title="CountDownLatch和CyclicBarrier的区别"></a>CountDownLatch和CyclicBarrier的区别</h1><ol><li>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset()</li><li>方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次</li><li>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。比如以下代码执行完之后会返回true</li><li>CountDownLatch会阻塞主线程，CyclicBarrier不会阻塞主线程，只会阻塞子线程。某线程中断CyclicBarrier会抛出异常，避免了所有线程无限等待</li></ol><h1 id="场景：如何实现三个线程顺序执行？"><a href="#场景：如何实现三个线程顺序执行？" class="headerlink" title="场景：如何实现三个线程顺序执行？"></a>场景：如何实现三个线程顺序执行？</h1><p>AQS实现类的用法一般都是给你描述个场景问你如何实现，比如题目的线程顺序执行，还有一个线程等待多个线程该如何实现，一个系统最多只能100个人登录如何实现？<br>就是想看看你是否了解Condition、CountDownLatch、CyclicBarrier、Semaphore的用法。<br>Condition只能由Lock锁创建，一般适用于两个线程之间的等待。<br>CountDownLatch是AQS共享模式的实现，state状态值表示计数器，await方法会使线程进入阻塞状态直到其他线程调用countdown方法将计数器减为0，CountDownLatch适用于一对多等待的场景。<br>CyclicBarrier常用来与CountDownLatch作比较，它也可以实现CountDownLatch一对多的等待，CyclicBarrier是一个栅栏，初始化指定屏障个数，所有的线程都到达屏障之后才可以继续执行，会使线程阻塞，且其可以重复使用。<br>Semaphore是许可证，常用来限制访问的数量，也是AQS共享模式的实现，state状态值用来表示许可证的数量。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库使用规范</title>
      <link href="/2022/10/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
      <url>/2022/10/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>单表索引利用率不高，部分为单字段索引，同时未避免索引失效</li><li>部分表单表数据过多，未进行及时拆表</li><li>索引建立未避过业务高峰时间</li><li>单次查询数据较多，未对数据量做限制</li><li>慢查询大多数集中在统计或分页场景下，具体原因在于扫描行数过多引起</li></ul><h1 id="后期规范"><a href="#后期规范" class="headerlink" title="后期规范"></a>后期规范</h1><h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><ul><li><strong>[强制]</strong> 数据库表、字段必须增加中文注释，字符编码集采用utf8mb4</li><li><strong>[强制]</strong> 数据库字段必须为非空，设置默认值</li><li><strong>[强制]</strong> 单表列数目不可超过25个，若超过则应考虑拆表存储</li><li>建议优先选择符合存储需求的最小数据类型，如unsigned无符号整型、char替换固定长度的varchar</li><li>避免使用TEXT、BLOB数据类型</li></ul><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><ul><li><strong>[强制]</strong> 查询数据必须限制数量级，不可频繁拉取大量数据；若业务需求，建议添加缓存层，以及相应的缓存更新机制</li><li><strong>[强制]</strong> 查询时指定所需的列，读取过多不需要的列会增加数据库的CPU、IO消耗，同时不能有效利用联合索引</li><li><strong>[强制]</strong> 对于分页场景需求，不推荐基于limit实现分页，容易触发深度分页；可根据主键id或其他自增字段实现查询分页</li><li>查询时应注意数据字段类型，避免隐式类型转换，从而导致无法利用索引的问题</li><li>查询时遵循索引最左匹配原则，避免索引失效情况，如：左模糊查询%like%、函数处理等；</li><li>建议单表数据量级不超过3000万，如查询过于复杂的表应考虑水平拆表</li><li>避免使用子查询，可把子查询优化为连表查询</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li><strong>[强制]</strong> 数据库表索引变更时，需在业务查询不频繁的时间进行，严禁在业务繁忙时进行索引变更</li><li><strong>[强制]</strong> 单表索引数量不超过8个，单个索引字段不超过5个，核心SQL优先考虑联合索引</li><li>索引顺序：1.区分度最高的字段放在索引左侧；2.查询频率高的字段放在索引左侧；3.字段长度小的字段放在索引左侧；</li><li>避免在更新比较频繁、区分度较小的列上单独建立索引</li><li>where条件使用范围查询时，索引最多用于一个范围条件，超过则不再使用索引</li><li>在较长的varchar字段上使用索引时，建议指定索引长度 </li><li>部分查询场景有排序需求时，order by字段需同样注意索引顺序，否则会出现慢查询；可通过explain查看sql执行计划，选取合适的字段或增加索引来满足排序需求</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程间通信</title>
      <link href="/2022/10/01/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2022/10/01/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="线程间通信常见问题"><a href="#线程间通信常见问题" class="headerlink" title="线程间通信常见问题"></a>线程间通信常见问题</h1><ol><li>三个线程分别打印 A，B，C，要求这三个线程一起运行，打印 n 次，输出形如“ABCABCABC…”</li><li>两个线程交替打印 0~100 的奇偶数</li><li>通过 N 个线程顺序循环打印从 0 至 100</li><li>多线程按顺序调用，A-&gt;B-&gt;C，AA 打印 5 次，BB 打印10 次，CC 打印 15 次，重复 10 次</li><li>用两个线程，一个输出字母，一个输出数字，交替输出 1A2B3C4D…26Z</li></ol><h2 id="Lock解法-第一题"><a href="#Lock解法-第一题" class="headerlink" title="Lock解法 第一题"></a>Lock解法 第一题</h2><pre><code class="java">import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class PrintABCUsingLock &#123;    private int times; // 控制打印次数    private int state;   // 当前状态值：保证三个线程之间交替打印    private Lock lock = new ReentrantLock();    public PrintABCUsingLock(int times) &#123;        this.times = times;    &#125;    private void printLetter(String name, int targetNum) &#123;        for (int i = 0; i  &lt; times;)&#123;             lock.lock();             if (state % 3 == targetNum) &#123;                 state++;                 i++;                 System.out.print(name);            &#125;            lock.unlock();        &#125;&#125;    public static void main(String[] args) &#123;        //顺序打印10次        PrintABCUsingLock loopThread = new PrintABCUsingLock(10);        new Thread(() -&gt; &#123;            loopThread.printLetter(&quot;A&quot;, 0);        &#125;, &quot;A&quot;).start();        new Thread(() -&gt; &#123;            loopThread.printLetter(&quot;B&quot;, 1);        &#125;, &quot;B&quot;).start();                new Thread(() -&gt; &#123;            loopThread.printLetter(&quot;C&quot;, 2);        &#125;, &quot;C&quot;).start();    &#125;&#125;</code></pre><h2 id="wait-notify解法-第一题"><a href="#wait-notify解法-第一题" class="headerlink" title="wait&#x2F;notify解法 第一题"></a>wait&#x2F;notify解法 第一题</h2><pre><code class="java">public class PrintABCUsingWaitNotify &#123;    private int state;    private int times;    private static final Object LOCK = new Object();    public PrintABCUsingWaitNotify(int times) &#123;        this.times = times;    &#125;    private void printLetter(String name, int targetState) &#123;        for (int i = 0; i &lt; times; i++)            synchronized (LOCK) &#123;                while (state % 3 != targetState) &#123;                try &#123;                    LOCK.wait();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            state++;            System.out.print(name);            LOCK.notifyAll();        &#125;    &#125;    public static void main(String[] args) &#123;        PrintABCUsingWaitNotify printABC = new PrintABCUsingWaitNotify(10);        new Thread(() -&gt; &#123;            printABC.printLetter(&quot;A&quot;, 0);        &#125;, &quot;A&quot;).start();        new Thread(() -&gt; &#123;            printABC.printLetter(&quot;B&quot;, 1);        &#125;, &quot;B&quot;).start();        new Thread(() -&gt; &#123;            printABC.printLetter(&quot;C&quot;, 2);        &#125;, &quot;C&quot;).start();    &#125;&#125;</code></pre><h2 id="wait-notify解法-第二题"><a href="#wait-notify解法-第二题" class="headerlink" title="wait&#x2F;notify解法 第二题"></a>wait&#x2F;notify解法 第二题</h2><pre><code class="java">package cn.wideth.util.thread;public class OddEvenPrinter &#123;    private Object monitor = new Object();    private final int limit;    private volatile int count;    OddEvenPrinter(int initCount, int times) &#123;        this.count = initCount;        this.limit = times;    &#125;    private void print() &#123;        synchronized (monitor) &#123;            while (count &lt; limit)&#123;            try &#123;                System.out.println(String.format(&quot;线程[%s]打印数字:%d&quot;, Thread.currentThread().getName(), ++count));                monitor.notifyAll();                monitor.wait();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        //防止有子线程被阻塞未被唤醒，导致主线程不退出        monitor.notifyAll();      &#125;   &#125;    public static void main(String[] args) &#123;        OddEvenPrinter printer = new OddEvenPrinter(0, 10);        new Thread(printer::print, &quot;odd&quot;).start();        new Thread(printer::print, &quot;even&quot;).start();    &#125;&#125;</code></pre><h2 id="wait-notify解法-第五题"><a href="#wait-notify解法-第五题" class="headerlink" title="wait&#x2F;notify解法 第五题"></a>wait&#x2F;notify解法 第五题</h2><pre><code class="java">package cn.wideth.util.thread;public class NumAndLetterPrinter &#123;    private static char c = &#39;A&#39;;    private static int i = 0;    static final Object lock = new Object();    public static void main(String[] args) &#123;        new Thread(() -&gt; printer(), &quot;numThread&quot;).start();        new Thread(() -&gt; printer(), &quot;letterThread&quot;).start();    &#125;    private static void printer() &#123;        synchronized (lock) &#123;            for (int i = 0; i &lt; 26; i++) &#123;                if (Thread.currentThread().getName() == &quot;numThread&quot;) &#123;                    //打印数字1-26                    System.out.print((i + 1));                    // 唤醒其他在等待的线程                    lock.notifyAll();                    try &#123;                        // 让当前线程释放锁资源，进入wait状态                        lock.wait();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125; else if (Thread.currentThread().getName() == &quot;letterThread&quot;) &#123;                    // 打印字母A-Z                    System.out.print((char) (&#39;A&#39; + i));                    // 唤醒其他在等待的线程                    lock.notifyAll();                    try &#123;                        // 让当前线程释放锁资源，进入wait状态                        lock.wait();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;            lock.notifyAll();        &#125;    &#125;&#125;</code></pre><h2 id="Condition解法-第一题"><a href="#Condition解法-第一题" class="headerlink" title="Condition解法 第一题"></a>Condition解法 第一题</h2><pre><code class="java">package cn.wideth.util.thread;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class PrintABCUsingLockCondition &#123;    private int times;    private int state;    private static Lock lock = new ReentrantLock();    private static Condition c1 = lock.newCondition();    private static Condition c2 = lock.newCondition();    private static Condition c3 = lock.newCondition();    public PrintABCUsingLockCondition(int times) &#123;        this.times = times;    &#125;    public static void main(String[] args) &#123;        PrintABCUsingLockCondition print = new PrintABCUsingLockCondition(10);        new Thread(() -&gt; &#123;            print.printLetter(&quot;A&quot;, 0, c1, c2);        &#125;, &quot;A&quot;).start();        new Thread(() -&gt; &#123;            print.printLetter(&quot;B&quot;, 1, c2, c3);        &#125;, &quot;B&quot;).start();        new Thread(() -&gt; &#123;            print.printLetter(&quot;C&quot;, 2, c3, c1);        &#125;, &quot;C&quot;).start();    &#125;    private void printLetter(String name, int targetState, Condition current, Condition next) &#123;        for (int i = 0; i &lt; times;)&#123;            lock.lock();            try &#123;               while (state % 3 != targetState) &#123;                  current.await();               &#125;            state++;            i++;            System.out.print(name);            next.signal();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;      &#125;   &#125;&#125;</code></pre><h2 id="Semaphore解法-第一题"><a href="#Semaphore解法-第一题" class="headerlink" title="Semaphore解法 第一题"></a>Semaphore解法 第一题</h2><pre><code class="java">import java.util.concurrent.Semaphore;public class PrintABCUsingSemaphore &#123;    public static void main(String[] args) &#123;        // 初始化许可数为1，A线程可以先执行        Semaphore semaphoreA = new Semaphore(1);        // 初始化许可数为0，B线程阻塞        Semaphore semaphoreB = new Semaphore(0);        // 初始化许可数为0，C线程阻塞        Semaphore semaphoreC = new Semaphore(0);        new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 10; i++) &#123;                try &#123;                    // A线程获得许可，同时semaphoreA的许可数减为0,进入下一次循环时                    // A线程会阻塞，知道其他线程执行semaphoreA.release();                    semaphoreA.acquire();                    // 打印当前线程名称                    System.out.print(Thread.currentThread().getName());                    // semaphoreB许可数加1                    semaphoreB.release();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;, &quot;A&quot;).start();        new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 10; i++) &#123;                try &#123;                    semaphoreB.acquire();                    System.out.print(Thread.currentThread().getName());                    semaphoreC.release();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;, &quot;B&quot;).start();        new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 10; i++) &#123;                try &#123;                    semaphoreC.acquire();                    System.out.print(Thread.currentThread().getName());                    semaphoreA.release();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;, &quot;C&quot;).start();    &#125;&#125;</code></pre><h2 id="Semaphore解法-第三题"><a href="#Semaphore解法-第三题" class="headerlink" title="Semaphore解法 第三题"></a>Semaphore解法 第三题</h2><pre><code class="java">public class LoopPrinter &#123;    //线程个数    private final static int THREAD_COUNT = 3;    private static int result = 0;    //最大数字    private static int maxNum = 10;    public static void main(String[] args) throws InterruptedException &#123;        final Semaphore[] semaphores = new Semaphore[THREAD_COUNT];        for (int i = 0; i  &lt; THREAD_COUNT; i++)&#123;           //非公平信号量，每个信号量初始计数都为1            semaphores[i] = new Semaphore(1);            if (i != THREAD_COUNT - 1) &#123;               //  System.out.println(i+&quot;===&quot;+semaphores[i].getQueueLength());               //获取一个许可前线程将一直阻塞, for 循环之后只有 syncObjects[2] 没有被阻塞                 semaphores[i].acquire();            &#125;        &#125;        for (int i = 0; i  &lt; THREAD_COUNT; i++)&#123;          // 初次执行，上一个信号量是 syncObjects[2]            final Semaphore lastSemphore = i == 0 ? semaphores[THREAD_COUNT - 1] : semaphores[i - 1];            final Semaphore currentSemphore = semaphores[i];            final int index = i;            new Thread(() -&gt; &#123;            try &#123;             while (true) &#123;                // 初次执行，让第一个 for 循环没有阻塞的 syncObjects[2] 先获得令牌阻塞了                lastSemphore.acquire();                System.out.println(&quot;thread&quot; + index + &quot;: &quot; + result++);                if (result &gt; maxNum) &#123;                    System.exit(0);                &#125;                // 释放当前的信号量，syncObjects[0] 信号量此时为 1，下次 for 循环中上一个信号量即为syncObjects[0]                currentSemphore.release();             &#125;         &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        &#125;).start();       &#125;    &#125;&#125;</code></pre><h2 id="LockSupport解法-第一题"><a href="#LockSupport解法-第一题" class="headerlink" title="LockSupport解法 第一题"></a>LockSupport解法 第一题</h2><pre><code class="java">import java.util.concurrent.locks.LockSupport;public class PrintABCUsingLockSupport &#123;    private static Thread threadA, threadB, threadC;    public static void main(String[] args) &#123;        threadA = new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 10; i++) &#123;                // 打印当前线程名称                System.out.print(Thread.currentThread().getName());                // 唤醒下一个线程                LockSupport.unpark(threadB);                // 当前线程阻塞                LockSupport.park();            &#125;        &#125;, &quot;A&quot;);        threadB = new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 10; i++) &#123;                // 先阻塞等待被唤醒                LockSupport.park();                System.out.print(Thread.currentThread().getName());                // 唤醒下一个线程                LockSupport.unpark(threadC);            &#125;        &#125;, &quot;B&quot;);        threadC = new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 10; i++) &#123;                // 先阻塞等待被唤醒                LockSupport.park();                System.out.print(Thread.currentThread().getName());                // 唤醒下一个线程                LockSupport.unpark(threadA);            &#125;        &#125;, &quot;C&quot;);        threadA.start();        threadB.start();        threadC.start();    &#125;&#125;</code></pre><h2 id="LockSupport解法-第五题"><a href="#LockSupport解法-第五题" class="headerlink" title="LockSupport解法 第五题"></a>LockSupport解法 第五题</h2><pre><code class="java">import java.util.concurrent.locks.LockSupport;public class NumAndLetterPrinterByLockSupport &#123;    private static Thread numThread, letterThread;    public static void main(String[] args) &#123;        letterThread = new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 26; i++) &#123;                System.out.print((char) (&#39;A&#39; + i));                LockSupport.unpark(numThread);                LockSupport.park();            &#125;        &#125;, &quot;letterThread&quot;);        numThread = new Thread(() -&gt; &#123;            for (int i = 1; i &lt;= 26; i++) &#123;                System.out.print(i);                LockSupport.park();                LockSupport.unpark(letterThread);            &#125;        &#125;, &quot;numThread&quot;);        numThread.start();        letterThread.start();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盛最多水的容器</title>
      <link href="/2022/09/01/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>/2022/09/01/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><pre><code class="java">    public int maxArea(int[] height) &#123;        int i = 0, j = height.length - 1, res = 0;        while(i &lt; j) &#123;            res = height[i] &lt; height[j] ?                 Math.max(res, (j - i) * height[i++]):                 Math.max(res, (j - i) * height[j--]);         &#125;        return res;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接雨水</title>
      <link href="/2022/08/01/%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
      <url>/2022/08/01/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p>输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><pre><code class="java">public int trap(int[] height) &#123;    int left = 0, right = height.length - 1;    int ans = 0;    int left_max = 0, right_max = 0;    while (left &lt; right) &#123;        if (height[left] &lt; height[right]) &#123;            if (height[left] &gt;= left_max) &#123;                left_max = height[left];            &#125; else &#123;                ans += (left_max - height[left]);            &#125;            ++left;        &#125; else &#123;            if (height[right] &gt;= right_max) &#123;                right_max = height[right];            &#125; else &#123;                ans += (right_max - height[right]);            &#125;            --right;        &#125;    &#125;    return ans;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
