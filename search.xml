<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>带你升级打怪兽：写给工程师的十条精进原则</title>
      <link href="/2023/09/11/%E5%B8%A6%E4%BD%A0%E5%8D%87%E7%BA%A7%E6%89%93%E6%80%AA%E5%85%BD%EF%BC%9A%E5%86%99%E7%BB%99%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E5%8D%81%E6%9D%A1%E7%B2%BE%E8%BF%9B%E5%8E%9F%E5%88%99/"/>
      <url>/2023/09/11/%E5%B8%A6%E4%BD%A0%E5%8D%87%E7%BA%A7%E6%89%93%E6%80%AA%E5%85%BD%EF%BC%9A%E5%86%99%E7%BB%99%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E5%8D%81%E6%9D%A1%E7%B2%BE%E8%BF%9B%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h1><p>时间回到8年前，我人生中的第一份实习工作，是在某互联网公司的无线搜索部做一个C++工程师。当时的我可谓意气风发，想要大干一场，结果第一次上线就写了人生中第一个Casestudy。由于对部署环境的不了解，把SVN库里的配置文件错误地发到线上，并且上完线就去吃晚饭了，等吃饭回来发现师傅在焦头烂额地回滚配置。那次故障造成了一个核心服务20分钟不可用，影响了几百万的用户。</p><p>这仅仅是一个开始，在后来半年的时间里，我几乎把所有职场新人可能犯的错误都犯了个遍。架构师让我调研一个抓取性能提升方案，我闷头搞了两周，也没有得出任何结论；本来安排好的开发计划，由于我临时要回去写论文，搞得经理措手不及；参加项目座谈会，全程“打酱油”……那段时间，自己也很苦恼，几乎每天晚上11点多才走，很累很辛苦，但依然拿不到想要的结果。</p><p>8年过去了，自己从一个职场小白逐步成长为一名技术Leader。我发现团队中的很多同学在不停地重复犯着自己当年类似的错误。他们并不是不努力，到底是哪里出了问题？经过一段时间的观察与思考后，我想我找到了答案。那就是：我们大多数同学在工作中缺乏原则的指导。原则，犹如指引行动的“灯塔”，它连接着我们的价值观与行动。不久前，桥水基金创始人雷·达里奥在《原则》一书中所传达的理念，引爆了朋友圈。每个人都应该有自己的原则，当我们需要作出选择时，一定要坚持以原则为中心。但是在现实生活中，我们往往缺少对原则的总结，对于很多人来说这是一门“只可意会不可言传”的玄学，是属于老司机的秘密，其实不然。</p><p>“追求卓越”是美团的价值观。作为一名技术人员，我们应该如何践行呢？本文总结了十条精进原则，希望能够给大家带来一些启发，更好地指导我们的行动。</p><h1 id="原则一：Owner意识"><a href="#原则一：Owner意识" class="headerlink" title="原则一：Owner意识"></a>原则一：Owner意识</h1><p>“Owner意识”主要体现在两个层面：一是认真负责的态度，二是积极主动的精神。</p><p>认真负责是工作的底线。首先，要对我们交付的结果负责。项目中每一个设计文档、每一行代码都需要认真完成，要对它的质量负责。如果设计文档逻辑混乱，代码没有注释，测试时发现一堆Bug，影响的不仅仅是RD的工程交付质量，还会对协同工作的RD、QA、PM等产生不好的影响。久而久之，团队的整体交付质量、工作效率也会逐步下降，甚至会导致团队成员之间产生不信任感。其次，我们要对开发的系统负责。系统的架构是否需要改进，接口文档是否完善，日志是否完整，数据库是否需要扩容，缓存空间够不够等等，这些都是需要落地的事情。作为系统Owner，请一定要认真履行。</p><p>积极主动是“Owner意识”更高一级的要求。RD每天要面对大量的工作，而且很多并不在计划内，这就需要具备一种积极主动的精神。例如我们每天可能会面对大量的技术咨询，如果客户提出的问题很长时间得不到回应的话，就会带来不好的客户体验。很多同学说忙于自己的工作没有时间处理，有同学觉得这件事不是很重要，也有很多同学是看到了，但是不知道怎么回答，更有甚者，看到了干脆装没看见。这些都是缺乏Owner意识的体现。正确的做法是积极主动地推动问题的解决，如果时间无法排开或者不知道如何解决，可以直接将问题反馈给能解决的同学。</p><p>积极主动还可以表现在更多方面。比如很多同学会自发地梳理负责服务的现状，根据接口在性能方面暴露的问题提出改进意见并持续推动解决；也有同学在跨团队沟通中主动承担起主R的角色，积极发现问题、暴露问题，推动合作团队的进度，保证项目顺利推进。这些同学无一不是团队的中坚力量。所以，我们在做好自己份内工作的同时，也应该积极主动地投入到“份外”的工作中去。一分耕耘一分收获，不要给自己设限，努力成为一个更加优秀的人。</p><h1 id="原则二：时间观念"><a href="#原则二：时间观念" class="headerlink" title="原则二：时间观念"></a>原则二：时间观念</h1><p>相信大家都有时间观念，但是真正能执行到位的可能并没有那么多。互联网是一个快速发展的行业，RD的研发效率是一个公司硬实力的重要体现。项目的按期交付是一项很重要的执行能力，在很大程度上决定着领导和同事对自己靠谱程度的评价。大家可能会问：难度几乎相同的项目，为什么有的同学经常Delay，而有的同学每次都能按时上线？一个很重要的原因，就是这些按时交付的同学往往具备如下两个特质：做事有计划，工作分主次。</p><p>工作安排要有计划性。通常，RD在设计评审之后就能预估出精确的开发时间，进而再合理地安排开发、联调、测试计划。如果是项目负责人，那么就会涉及协调FE、QA、PM等多个工种的同学共同完成工作。凡事预则立，不预则废。在计划制定过程中，要尽可能把每一项拆细一点（至少到pd粒度）。事实证明，粒度越细，计划就越精准，实际开发时间与计划之间的误差就会越小。</p><p>此外，务必要规定明确的可检查的产出，并在计划中设置一些关键的时间点进行核对。无数血淋淋的事实告诉我们，很多项目延期都是因为在一些关键交付点上双方存在分歧造成的。例如后台RD的接口文档计划在周五提供，FE认为是周五上午，而RD认为是周五下班前提交，无形中会给排期带来了1pd的误差。所以，我们要做到计划粒度足够细，关键时间点要可检查。</p><p>工作安排要分清楚主次。我们每天要面对很多的事情，要学会分辨这些工作的主次。可以尝试使用“艾森豪威尔法则”（四象限法则），把工作按照重要、紧急程度分成四象限。优先做重要紧急的事情；重要不紧急的事情可以暂缓做，但是要持续推进；紧急不重要的事情可以酌情委托给最合适的人做；不重要不紧急的事情可以考虑不做。很多项目无法按期交付的原因，都是因为执行人分不清主次。比如在开发中需要使用到ES，一些不熟悉ES的同学可能想系统性地学习一下这方面的知识，就会一头扎进ES的汪洋中。最后才发现，原本一天就能完成的工作被严重拖后。实际工作中，我们应当避免这种“本末倒置”的工作方式。在本例中，“系统性地学习ES”是一件重要但不紧急的事情。要学会分辨出这些干扰的工作项，保证重要紧急的事情能够按时交付。</p><h1 id="原则三：以终为始"><a href="#原则三：以终为始" class="headerlink" title="原则三：以终为始"></a>原则三：以终为始</h1><p>“以终为始”（Begin With The End In Mind），是史蒂芬·柯维在《高效能人士的七个习惯》中提到的一个习惯。它是以所有事物都经过两次创造的原则（第一次为心智上的创造，第二次为实际的创造）为基础的。直观的表达就是：先想清楚目标，然后努力实现。</p><p>在工作中，很多RD往往只是埋头走路，很少抬头看天。每次季度总结的时候，罗列了很多项目，付出很多努力。但是具体这些项目取得了哪些收益，对业务有哪些提升，却很难说出来。这就说明在工作中并没有遵守“以终为始”这一原则。此外，很多同学在做需求的过程中，对于目标与收益关注不够，系统上线之后，也没有持续地跟进使用效果。这一点在技术优化项目中体现的尤为明显。</p><p>例如在一个接口性能优化的项目中，经过RD的努力优化，系统TP99缩短了60%，支持QPS提升了2倍。但是系统到底需要优化到什么程度呢？是不是缩短60%，提升2倍就能满足需求呢？在优化之前，很多同学常常忘记设置一个预设的目标（TP99小于多少，支持QPS大于多少）。我们必须清楚，优化一定是有原因的，比如预期某节假日流量会暴增或者某接口超时比例过高，如果不进行优化，系统可能会存在宕机风险。解决特定的问题才是技术优化的最终目的，所以要根据问题设定目标，再进行优化。</p><p>“以终为始”，这一原则还可以作用于我们的学习中。很多同学看过很多技术文章，但是总是感觉自己依然一无所知。很重要的一个原因，就是没有带着目标去学习。在这个信息爆炸的时代，如果只是碎片化地接收各个公众号推送的文章，效果几乎可以忽略不计。在学习之前，我们一定要问自己，这次学习的目标是什么？是想把Redis的持久化原理搞清楚，还是把Redis的主从同步机制弄明白，亦或是想学习整个Redis Cluster的架构体系。如果我们能够带着问题与目标，再进行相关的资料搜集与学习，就会事半功倍。这种学习模式的效果会比碎片化阅读好很多。</p><h1 id="原则四：闭环思维"><a href="#原则四：闭环思维" class="headerlink" title="原则四：闭环思维"></a>原则四：闭环思维</h1><p>你是否遇到过这样的场景：参加了一个设计（或需求）评审，大家兴致勃勃地提了很多合理的意见，等到再次评审的时候，却发现第一次提的很多问题都没有得到改进，很多讨论过的问题需要从头再开始讨论。这种情况就是一种典型的工作不闭环。</p><p>之前看过一句话：一个人是否靠谱，就看他能否做到凡事有交代，件件有着落，事事有回音。这就是闭环思维的重要性。它强调的是一种即时反馈闭环，如果别人给我们分配了一个任务，不管完成的结果如何，一定要在规定的时间内给出明确的反馈。</p><p>例如在跨部门的沟通会议中，虽然各方达成了一致，会议发起者已经将最终的记录周知大家。但是，到这一步其实并没有完成真正的闭环，在落地执行过程中很可能还存在一些潜在的问题。例如，会议纪要是否经各方仔细核对并确认过？会议中明确的To Do进展是什么？完成结果有没有Check的机制？如果这些没有做到的话，就会陷入“沟通-发现问题-再沟通-再发现问题”的恶性循环中。</p><p>真正的闭环，要求我们对工作中的事情都能够养成良好的思维习惯，沟通要有结论，通知要有反馈，To Do要有验收。</p><p>“闭环思维”还要求能够定期主动进行阶段性的反馈。刚参加工作时，我接了一个工期为两个月的项目。整个项目需要独自完成，自己每天按照计划，有条不紊地进行开发。大概过了两周之后，Leader询问项目进度，虽然我已经跟他说没问题。然而，Leader告诉我，因为我每天对着电脑也不说话，让他心里很没底。</p><p>这时，我才意识到一个很重要的问题，我跟Leader之间存在信息不对称。从那以后，我就时不时得跟他汇报一下进度，哪怕就只有简短的一句话，也可以明显感觉，他对我的信心增加了很多。特别是我做Leader之后，对这种闭环反馈的理解，就更加深刻了。从Leader的角度看，其实只是想知道项目是否在正常推进，是否遇到问题需要他协助解决。</p><h1 id="原则五：保持敬畏"><a href="#原则五：保持敬畏" class="headerlink" title="原则五：保持敬畏"></a>原则五：保持敬畏</h1><p>“君子之心，常怀敬畏”，保持敬畏之心能够让我们少犯错误。在工作中存在各种各样的规范，例如代码规范、设计规范、上线规范等等。我们必须明白，这些规范的制定一定是基于某些客观原因的，它们都是历史上无数Case积累而来的经验。团队里的每一个成员都应该学习并严格遵守，这一点对于新人尤其重要。</p><p>当我们进入到一个新的团队，请先暂时忘掉之前的习惯，要尽快学习团队既有的规范，并且让自己与团队保持一致。以编码风格为例，很多同学往往习惯于自己之前的代码写作风格，在做新公司第一个项目时，也按照自己的习惯进行变量、包的命名等等。结果在代码Review过程中，被提了很多修改意见，不得不返工重写，得不偿失。如果能够保持敬畏之心，提前了解编码规范，这种问题完全可以避免。</p><p>类似的问题，还包括对上线流程的不了解，对回滚操作不熟悉，对SRE线上变更过程不了解等等。除了这些显而易见的规范，还有一些约定俗成的规则。个人建议是：如果有事情拿不准，不妨多问问其他同事，不要凭自己的感觉做事情。</p><p>保持敬畏之心并不意味着要“因循守旧”。在我们充分了解这些规范和约定之后，如果觉得存在不妥之处，可以跟全组同学讨论，是否采纳新的建议，然后及时去更新迭代。其实，让规范与约定与时俱进，也是另一种形式的敬畏。</p><h1 id="原则六：事不过二"><a href="#原则六：事不过二" class="headerlink" title="原则六：事不过二"></a>原则六：事不过二</h1><p>“事不过二”，是我们团队一贯坚持的原则，它可以解读为两层含义。</p><p>一层含义是“所有的评审与问题讨论，不要超过两次”。之所以有这样的要求，是因为我们发现，很多RD都把时间花费在一些无休止的评审与问题讨论中，真正投入到实际开发中的时间反而很少。在实际工作场景中，我们经常会遇到一些不是很成熟的需求评审。这些需求文档，要么是背景与目标含糊不清，要么是产品方案描述不够细化，或者存在歧义。RD与PM被迫反复进行讨论，我曾经遇到过一个需求评审，进行了三次还被打回。</p><p>同样的问题，在设计评审中也屡见不鲜。方案固然需要经过反复的讨论，但是如果迟迟不能达成一致，就会耗费很多RD与PM的宝贵时间，这就与提升研发效率的理念背道而驰。因此我们团队规定：所有的评审最多两次。通过这种方式，倒逼利益相关方尽可能地做好需求与方案设计。评审会议组织前，尝试与所有相关人员达成一致，询问对方的意见，并进行有针对性的讨论，这样能够很大提升评审会议的效率和质量。如果在第一次评审中不通过，那么就只有一次机会进行复审。一旦两次不通过，就需要进行Casestudy。</p><p>“事不过二”原则的另一层含义，是“同样的错误不能犯第二次”。每次故障之后，Casestudy都必须进行深刻的总结复盘，对故障原因进行5Why分析，给出明确可执行的To Do List。每次季度总结会，大家自我反省问题所在，在下个季度必须有所改善，不能再犯类似的错误。孔子云：“不迁怒，不贰过”，在错误中反思与成长，才能让我们成为更优秀的人。</p><h1 id="原则七：设计优先"><a href="#原则七：设计优先" class="headerlink" title="原则七：设计优先"></a>原则七：设计优先</h1><p>“设计优先”这条原则，相对来说更加具体一些。之所以单列一项，是因为架构设计太重要了。Uncle Bob曾说过：“软件架构的目标，是为了让构建与维护系统的所需人力资源最小化。”</p><p>架构设计，并不仅仅关系到系统的质量，还关乎团队的效能问题。很多团队也有明文规定，开发周期在3pd以上的项目必须有设计文档，开发周期在5pd以上的项目必须有设计评审。在具体的执行过程中，由于各种原因，设计往往并不能达到预期的效果。究其原因，有的是因为项目周期紧，来不及设计的足够详细；有的是因为RD主观上认为项目比较简单，设计草草了事。无数事实证明，忽略了前期设计，往往会导致后续开发周期被大幅拉长，给项目带来了很大的Delay风险。而且最可怕的是，不当的设计会给项目带来巨大的后期维护成本，我们不得不腾出时间，专门进行项目的优化与重构。因此，无论什么时候都要记住“设计优先”这一原则。磨刀不误砍柴工，前期良好的设计，会给项目开发以及后期维护带来极大的收益。</p><p>“设计优先”这一原则，要求写别人看得懂的设计。我们了解一个系统最直接的途径就是结合设计文档与代码。在实际工作中，很多同学的设计文档让大家看得一头雾水，通篇下来，看不出系统整体的设计思路。其实，设计的过程是一种智力上的创造，我们更希望它能成为个人与集体智慧的结晶。如何才能让我们的设计变得通俗易懂？我个人认为，设计应该尽量使用比较合理的逻辑，进而把设计中的一些点组织起来。比如可以使用从抽象到具体，由总到分的结构来组织材料。在设计过程中，要以需求为出发点，通过合理的抽象把问题简化，讲清楚各个模块之间的关系，再详细分述模块的实现细节。做完设计之后，可以发给比较资深的RD或者PM审阅一下，根据他们的反馈再进行完善。好的设计，一定是逻辑清晰易懂、细节落地可执行的。</p><h1 id="原则八：P-PC平衡"><a href="#原则八：P-PC平衡" class="headerlink" title="原则八：P&#x2F;PC平衡"></a>原则八：P&#x2F;PC平衡</h1><p>“P&#x2F;PC平衡”原则，即产出与产能平衡原则。伊索寓言中讲述了一个《生金蛋的鹅》的故事。产出好比“金蛋”，产能好比“会下金蛋的鹅”。“重蛋轻鹅”的人，最终可能连产蛋的资产都保不住；“重鹅轻蛋”的人，最终可能会被饿死。产出与产能必须平衡，才能达到真正的高效能。为了让大家更清晰的了解这一原则，本文举两个例子。</p><p>从系统的角度看，每一个系统都是通过持续不断地叠加功能，来实现其产出，而系统的产能是通过系统架构的可扩展性、稳定性等一系列特性来表征。为了达到产出与产能的平衡，需要在不断支持业务需求的过程中，持续进行技术架构层面的优化。如果一味地做业务需求，经过一定的时间，系统会越来越慢，最终影响业务的稳定性；反之，一个没有任何业务产出的系统，最终会消亡。</p><p>再从RD的角度来看这个问题，RD通过做需求来给公司创造价值，实现自己的产出。而RD的产能是指技术能力、软素质、身体健康状况，有这些资本后，我们才能进行持续的产出。在日常工作中，我发现很多RD往往只重视产出。他们也在很努力地做项目，但是每一个项目所使用的方法，还是沿用自己先前一贯的思路。最终，不仅项目做得一般，还会抱怨自己得不到任何成长。这就是P&#x2F;PC不平衡的体现。如果能在做项目的过程中，通过学习和总结持续提升自己的技术能力和软素质，并将其应用于项目实施交付中，相信一定会取得双赢的结果。</p><p>“P&#x2F;PC平衡”原则还适用于很多其他的领域，例如团队、家庭等，我本人也非常推崇这一原则。希望大家也能将其作为自身的一项基本原则，努力寻找到产出与产能的平衡点。</p><h1 id="原则九：善于提问"><a href="#原则九：善于提问" class="headerlink" title="原则九：善于提问"></a>原则九：善于提问</h1><p>“善于提问”，首先要勤于提问。求知欲源于好奇心，是人类的一种本能。在工作中要养成勤于提问的好习惯，不懂就问，不要因为自己一时懒惰或者碍于情面，就放弃提问的机会。当遇到不同的观点时，也要礼貌地问出来。波克定理告诉我们，只有在争辩中，才可能诞生最好的主意和最好的决定。</p><p>在设计评审、代码评审这类体现集体智慧的活动中，遇到有问题的地方一定要提出来。我经常看到，很多同学评审全程一言不发，这就是浪费大家的时间。设计评审的目的，是让大家针对方案提出改进意见并达成一致，如果全程“打酱油”，那就失去了评审的意义。我们鼓励大家多提问，把自己内心的疑惑表达出来，然后通过交流的方式得到答案。</p><p>“善于提问”，还要懂得如何提问。为什么同样是参加设计评审，有的同学就能提出很好的问题，而有的同学却提不出任何问题？除了知识储备、专业技能、经验等方面的差异外，还有一点很重要：这就是批判性思维。</p><p>批判性思维主张通过批判性思考达到理性思维，即对事物本质的认知和掌握。关于如何进行批判性思维，大家可以参考一些经典的图书如《批判性思维》、《学会提问》等。在工作中面临一项决策时，会有各种各样的意见摆在你面前，所以我们必须要学会使用批判性思维来进行分析，每个人的论据是否可靠，论证是否合理，是否有隐含的立场。同样，在阅读一篇技术博客的时候，也要使用批判性的思维，多问几个为什么，作者得出的结论是否合理？论据是否充分？只有这样，才能不断地获取真正的知识。</p><h1 id="原则十：空杯心态"><a href="#原则十：空杯心态" class="headerlink" title="原则十：空杯心态"></a>原则十：空杯心态</h1><p>“满招损，谦受益”，“空杯心态”是最后一项原则。我觉得这也是一个人能够持续成长的前提。做技术的人，骨子里通常有股傲气，并且会随着资历、成绩的提升而不断增加。初入职场的小白，可能会非常谦虚，但是工作几年之后，专业技能逐步提升，可能还取得了一些小成就，人就会越来越自信。这时候，如果不能始终保持“空杯心态”，这种自信就会逐步演变为自满。自满的人，往往表现为工作中把别人的建议当成是批评，不接受任何反对意见，学习上也缺乏求知的动力，总是拿自己的长处去跟别人的短处做比较。其实每个人多少都会有一些自满，可怕的是不知道甚至不愿承认自满。</p><p>保持“空杯心态”这一原则要求我们时刻进行自我检视与反省。在工作中，多去跟不同级别的同学聊一聊，或者做一个360度评估，这有助于我们更加客观地评价自己。在横向对比中，多向那些优秀的同学看齐，学习他人的优点。很多同学在设计评审或者代码Review过程中，针对别人提出的问题与建议，往往都采用一种对立的态度。错误地认为别人是在挑刺，是在针对自己。诚然，在某些方面，我们可能确实比其他人想得深入，但是这不代表在所有方面都能考虑周全。对于别人的建议，建议使用“善于提问”原则里提到的批判性思维仔细分析一下，虚心地吸取那些好的建议。</p><p>工作学习就像“练级打怪”，技能储备的越多，就越容易走到最后。保持空杯心态，可以让我们发现很多以前注意不到的新能力，我们要做的就是努力学习它，将它们转化为自己能力库的一部分。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上，是我总结的工作与学习的十条基本原则。其中有的侧重于个人做事情的方法，如“Owner意识”、“时间观念”、“以终为始”、”闭环思维”；有的侧重于团队工作标准规范，如“保持敬畏”、“事不过二”、“设计优先”；有的侧重于团队或个人效能提升，如“P&#x2F;PC平衡”、“善于提问”、“空杯心态”。这些原则是我多年在工作与学习中，不断总结得来的经验。希望在大家面临选择时，这些原则能够起到一定的帮助和指导作用。</p><p>以原则为中心地工作与生活，让自己与团队变得更加强大。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大数据架构演进之路</title>
      <link href="/2023/09/07/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF/"/>
      <url>/2023/09/07/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h1><p>1998 年，一篇名为《大数据科学的可视化》的文章在美国《自然》杂志上发表，大数据作为一个专用名词正式出现在公共刊物之中，至今已经发展了二十余年。根据维基百科的定义，大数据是指无法在可承受的时间范围内用常规软件工具进行处理的数据集合，具有规模性（Volume）、多样性（Varity）、高速性（Velocity）和价值性（Value）等四个方面的典型特征，即所谓的 “4V”。</p><p><img src="/images/bigdata-arch-1.png" alt="img"></p><p>为了有效解决大规模数据存储、计算、分析的诸多难点，诞生了以 Hadoop 为代表的一系列产品，整个大数据生态系统庞大而复杂，而大数据架构则是连接、组织这一庞大生态的核心。在大数据的下一个十年即将来临之际，本文将对这二十年中具有代表性的大数据架构进行一个阶段性总结，回顾历史，拥抱未来。</p><h1 id="02-大数据架构的早期发展"><a href="#02-大数据架构的早期发展" class="headerlink" title="02 大数据架构的早期发展"></a>02 大数据架构的早期发展</h1><p>在上世纪 90 年代，随着互联网浪潮带动的数据持续增长，传统的数据库技术遇到了瓶颈。美国的 Teradata 天睿公司推出了可以储存 TB 级数据的关系型数据库管理系统，这是对 MPP（大规模并行处理）架构的最初雏形使用。这一时期，大数据系统主要以存储结构化数据为主，处在一个缓慢发展的阶段。</p><p><img src="/images/bigdata-arch-2.png" alt="img"></p><p>1990 年，Bill Inmon 提出了数据仓库这一概念：面向主题的、集成的、随时间变化的、非易失的数据集合，用于支持管理者的决策。很多大型企业开始着手搭建自己的数据仓库。但是受限于技术，这一时期只能将业务数据库的数据通过 ETL 管道抽取到基于关系型数据库搭建的数据仓库中，分析手段十分有限。</p><p><img src="/images/bigdata-arch-3.png" alt="img"></p><p>真正给大数据体系带来变革的，是 Hadoop 的出现。</p><h2 id="2-1-Haoop-的发展史"><a href="#2-1-Haoop-的发展史" class="headerlink" title="2.1 Haoop 的发展史"></a>2.1 Haoop 的发展史</h2><p>Hadoop 的发展可以追溯到 2001 年，当时 Lucene 框架被创建，这是一个用 Java 写的开源软件，提供了全文搜索功能。</p><p>2003 年，Nutch 项目启动，它的目标是创建一个开源的搜索引擎，包括网页抓取、索引、查询等功能。然而，随着网页数量的增加，Nutch 遇到了可扩展性的问题。</p><p>同年，Google 发表了关于 GFS 的论文，这是一种分布式文件系统，可用于处理海量网页的存储。</p><p>2004 年，Google 又发表了关于 MapReduce 的论文，这是一种分布式计算框架，可用于处理海量网页的索引计算问题。这为解决 Nutch 的可扩展性问题提供了可能。</p><p>2005 年，Lucene 的子项目 Nutch 的一部分正式引入 Apache 基金会。同年，Hadoop 成为 Lucene 的子项目。</p><p>2006 年，Google 发表了关于 Bigtable 的论文，这是一种分布式数据库，可以在局部几台服务器崩溃的情况下继续提供高性能的服务。</p><p>2008 年 1 月，Hadoop 成为 Apache 顶级项目，迎来了它的快速发展期。</p><blockquote><p>在这里，推荐花点时间阅读一下被称为 “大数据三驾马车” 的三篇论文。它们是分布式文件系统，分布式计算，分布式数据库的思想雏形，Hadoop 之父 Doug Cutting 基于前两篇论文完成了 Hadoop 项目早期的工程实现。</p></blockquote><ul><li>The Google File System（<a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/gfs-sosp2003.pdf%EF%BC%89">https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/gfs-sosp2003.pdf）</a></li><li>MapReduce: Simplified Data Processing on Large Clusters（<a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/bigtable-osdi06.pdf%EF%BC%89">https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/bigtable-osdi06.pdf）</a></li><li>Bigtable: A Distributed Storage System for Structured Data（<a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf%EF%BC%89">https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf）</a></li></ul><p>现在，Hadoop 已经发展成为一个包括 HDFS、MapReduce、HBase 等众多项目的庞大生态系统。有趣的是，Hadoop 这一名字的来源是作者 Doug Cutting 的儿子的玩具大象，因此 Hadoop 生态的很多组件的 logo 上都出现了黄色大象这一元素。</p><p><img src="/images/bigdata-arch-4.png" alt="img"></p><h2 id="2-2-Hadoop-生态下的离线数仓架构"><a href="#2-2-Hadoop-生态下的离线数仓架构" class="headerlink" title="2.2 Hadoop 生态下的离线数仓架构"></a>2.2 Hadoop 生态下的离线数仓架构</h2><p>下面我们来具体介绍一下基于 Hadoop 体系的传统大数据架构。</p><p>在 Hadoop 生态发展初期，一个主流的解决方案是通过 Flume、Sqoop 等工具，将数据以 ETL 的形式抽取到 HDFS 中，并通过 MapReduce 完成数据计算。MapReduce 虽然解决了大规模数据场景下的分布式计算这一问题，但是存在很多缺陷：</p><ul><li>数据计算过程中产生的数据大量落盘，磁盘 IO 严重，性能不佳</li><li>基于 Map 和 Reduce 接口的编程模型过于简单，很多复杂的业务逻辑难以实现，开发者无法专注于业务逻辑的编写</li><li>MapReduce 作业需要使用 Java 语言进行开发并打包部署，存在很高的技术门槛，整体的开发效率非常低下</li><li>无法迭代式计算，不能够很好的支持机器学习场景的任务</li></ul><p>2007 年，Facebook 研发了数据仓库工具 Hive，在一定程度上解决了 MapReduce 的一些问题。Hive 是建立在 HDFS 之上的，支持标准化 SQL，并自动转换为 MapReduce 任务，屏蔽了底层框架细节，而且在存储层、计算层都做了不少的优化。</p><p>2008 年，Hive 正式开源，很快成为大数据领域构建离线数仓的统一标准。</p><p><img src="/images/bigdata-arch-5.png" alt="img"></p><p>通常，我们以 T+1 的周期调度 Hive SQL 脚本，在 Hive 数仓中进行分层处理，并最终产出离线指标和数据集市表供业务使用。</p><p>Hive 虽然对计算层做了很多优化，但是并没有改变 MapReduce 基于磁盘进行数据计算这一本质，因此还是存在严重的性能问题。在这种情况下，一个新的离线计算框架出现了，它就是 Spark。</p><p>2009 年，Spark 诞生于伯克利大学 AMP Lab 的一个研究性项目。</p><p>2010 年，Spark 正式开源，并于 2014 年成为 Aparch 基金会的顶级项目，整个过程不到五年时间。</p><p>和 MapReduce 相比，Spark 具有很多优势：</p><ul><li>实现了高效的 DAG 执行引擎，引入了对内存的使用。和 MapReduce 相比，Spark 基于内存的运算要快 100 倍以上，而基于硬盘的运算也要快 10 倍以上。</li><li>支持 Java、Python 和 Scala 的 API，支持 Spark SQL，给不同语言的开发者提供了更多选择。</li><li>丰富的生态，支持几十种上下游存储系统，支持近百种机器学习算法。</li><li>抽象出了 RDD（弹性分布式数据集）这一概念，支持迭代式计算，大幅提升了机器学习模型的训练速度。</li></ul><p>在之后的几年时间里，Spark + Hive  的离线数仓架构逐渐成熟，时至今日仍然是构建离线数仓的一种主流解决方案。</p><h1 id="03-实时架构的兴起"><a href="#03-实时架构的兴起" class="headerlink" title="03 实时架构的兴起"></a>03 实时架构的兴起</h1><h2 id="3-1-Flink-实时计算引擎"><a href="#3-1-Flink-实时计算引擎" class="headerlink" title="3.1 Flink 实时计算引擎"></a>3.1 Flink 实时计算引擎</h2><p>Hadoop 体系的离线批处理架构天然具有数据延迟的问题，无论是 MapReduce、Hive 还是 Spark，都无法满足互联网时代快速获取最新数据的需求，比如电商双 11 大屏的实时销售额展示。因此，相继出现了 Storm、Spark Streaming、Flink 这三个实时计算引擎，它们的对比如下：</p><p><img src="/images/bigdata-arch-6.png" alt="img"></p><p>Spark 本身是一个离线计算引擎，通过微批处理（Micro batch）实现对实时计算的支持。和 Storm、Flink 这两个专为实时计算而生的引擎相比，Spark 的延迟较高。在早期，大部分实时任务都是基于 Storm 开发的。Flink 开源后，它先进的设计理念和一些关键能力，比如状态管理、容错机制、精确一次处理、毫秒级延迟等，加上 Flink SQL、Flink CDC、Flink ML 等生态的建设以及背后商业化公司阿里巴巴的大量资源支持，在短短几年的时间内就成为了实时计算领域的事实标准。有了 Flink，建设端到端秒级延迟的实时数仓成为了可能。</p><h2 id="3-2-早期的实时数仓架构"><a href="#3-2-早期的实时数仓架构" class="headerlink" title="3.2 早期的实时数仓架构"></a>3.2 早期的实时数仓架构</h2><p>Flink 解决了计算层的延迟问题，但是实际上用户需要的是端到端的时效性。在存储层，我们需要选择一种低延迟的存储介质替换掉 Hive。实践中，Kafka 作为主流的分布式流平台，无论是吞吐量还是延迟都非常优秀，因此基于 Flink +  Kafka 的实时数仓架构很快流行起来。</p><p>在这个架构中，我们通过 ETL 工具将原始数据传输到 Kafka 中，形成 ODS 层，并使用 Flink 进行分层处理。为了加快处理速度，DIM 层的维度数据通常是存在 Redis、HBase 等高性能 KV 库中的，基于 Flink 的多流 Join 能力进行打宽。为了提升查询的速度，最终的指标数据存储到基于 OLAP 引擎的 ADS 层，供用户使用。</p><p>Flink +  Kafka 的实时数仓架构，只能提供非常短时间内的数据。通常来说，ODS 层 Topic 的存储周期可能是七天或者是更短。因此更长时间跨度的指标，还是基于离线数仓的数据产出。这种离线数仓和实时数仓割裂的架构很快就遇到了结果不一致的问题：如果一个用户日活量指标，实时数仓产出的是 1 亿，离线数仓产出的是 1 亿 5 千万，业务该采用哪个呢？实际情况中，实时数仓可能只统计了主站的日活，而离线数仓把一些生态的日活也统计进去了，这就是口径不一致的问题。考虑到实时数仓和离线数仓通常是两个独立的团队，这一问题很难避免。</p><p><img src="/images/bigdata-arch-7.png" alt="img"></p><p>同时，实时计算的资源消耗显著大于离线计算，这种离线 + 实时数仓共存的架构，会导致大数据相关的成本倍数级增长，中小型公司很难接受。</p><p>为了解决实时和离线不一致、资源消耗大的问题，业界分别设计出了 Lamdba 和 Kappa 两种架构，以及基于这两种架构的一些变种。今天，我们在市面上所能看到的数仓架构，大部分都是在 Lamdba 和 Kappa 两种架构的基础上，根据业务诉求改良而来的。</p><h2 id="3-3-Lamdba-架构"><a href="#3-3-Lamdba-架构" class="headerlink" title="3.3 Lamdba 架构"></a>3.3 Lamdba 架构</h2><p>Lambda 架构由 Twitter 工程师 Nathan Marz 提出，是一种经典的、实施广泛的技术架构。它打通了原先割裂的实时和离线体系，通过提供给用户一个统一的视图，解决了实时和离线结果不一致的问题。</p><p><img src="/images/bigdata-arch-8.png" alt="img"></p><p>Lambda 架构由批处理层（Batch Layer）、速度处理层（Speed Layer）和用于响应查询的服务层（Serving Layer）组成。</p><ol><li>批处理层（Batch Layer）：负责存储和管理主数据集以及预先批处理计算好的视图。它使用可处理大量数据的分布式处理系统预先计算结果。通过处理所有的历史数据，这一层能够确保数据的准确性，并修复历史错误，然后更新现有的数据视图。</li><li>速度处理层（Speed Layer）：负责实时处理新来的大数据。它通过提供最新数据的实时视图来最小化延迟。当同样的数据在批处理层处理完成后，在速度层的数据就可以被替代掉了。这一层弥补了批处理层所导致的数据视图滞后。</li><li>服务层（Serving Layer）：负责响应查询。它从批处理层和速度处理层获取预先计算好的结果或者实时计算的数据视图，然后返回给用户。</li></ol><p>Lambda 架构的优缺点如下：</p><ul><li>优点：<ul><li>极高的稳定性，发生问题时可以直接通过离线链路补回数据，实时链路消费最新的数据即可。</li><li>保留了实时和离线两条链路，可以支持复杂的数据处理和分析。</li></ul></li><li>缺点：<ul><li>通过引入服务层来统一实时和离线结果不一致的问题，只是对用户来说统一了查询，没有从根本上解决问题。对于开发人员来说，还是要维护两条链路，并且还要额外维护一个服务层，增加了系统复杂度。</li><li>资源开销大，成本问题仍然存在。</li></ul></li></ul><h2 id="3-4-Kappa-架构"><a href="#3-4-Kappa-架构" class="headerlink" title="3.4 Kappa 架构"></a>3.4 Kappa 架构</h2><p><img src="/images/bigdata-arch-9.png" alt="img"></p><p>为了解决 Lamdba 架构过于复杂的问题，LinkedIn 公司的 Jay Kreps 结合实际经验与个人思考提出了 Kappa 架构。</p><p>Kappa 架构的核心是通过改进实时链路中计算、存储的部分来解决全量的问题，使得流处理和批处理可以共用一套代码。Kappa 架构认为对于历史数据的重复计算几率是很小的，即使需要，可以通过启用不同的实例的方式来做重复计算。</p><p>具体改进的地方包括：</p><ul><li>用 Kafka 等支持重放的消息队列系统收集各种各样的数据，需要几天的数据量就保存几天。</li><li>当需要全量重新计算时，重新起一个流计算实例，从头开始读取数据进行处理，并输出到一个新的结果存储中。</li><li>当新的实例做完后，停止老的流计算实例，并把一些老的结果删除。</li></ul><p>Kappa 架构 与 Lambda 架构相比，其优缺点是：</p><ul><li>优点：<ul><li>只需维护一套代码，开发、维护成本低。</li></ul></li><li>缺点：<ul><li>无法支持长时间跨度的数据处理。</li><li>一旦发生故障，重新计算的效率低。</li><li>流处理作业难以调试，出问题的概率高，对研发人员、运维人员的技术水平要求高。</li></ul></li></ul><p>Lambda 和 Kappa 都属于实时架构，因此都可以满足业务对实时性的要求，同时在资源成本、重计算成本、运维成本方面各有一些 trade-off。为了优化这两种架构的缺陷部分对业务的影响，诞生了一些改良后的版本，例如 Lambda+、Kappa+。同时，各大互联网公司也都有更贴合自家业务的魔改版。</p><p>但是，无论在 Lambda 和 Kappa 的基础上怎么改，实时和离线无法统一的根本问题始终没有得到解决。而在可预见的时间内，实时计算在大规模数据处理、机器学习等场景下无法完全取代离线计算，只能是互补的关系。在这种背景下，能够统一实时和离线的流批一体架构被寄予希望。</p><p>从上面的讲述中我们知道，Lambda 架构实现了流批一体的服务层，使得用户的体验是统一的，但是计算层和存储层仍然是割裂的。而 Kappa 架构下的批处理局限性很大。如果说我们能够吸收 Lambda 架构的理念，并且做到计算层和存储层的流批一体，那么问题是不是就得到解决了呢？</p><p>下面讲一讲如何实现流批一体的计算和存储。</p><h2 id="3-5-流批一体计算"><a href="#3-5-流批一体计算" class="headerlink" title="3.5 流批一体计算"></a>3.5 流批一体计算</h2><p>流批一体计算是指在大数据处理领域中，将流处理（Streaming）和批处理（Batch）结合在一起，使得同一套计算逻辑能够同时应用于两种处理模式，使得计算过程更加简洁和高效，并在最终结果上保持一致。</p><p>在 3.1 章节，我们已经讲过，Flink 是一个开源的实时计算引擎。虽然在 Flink 的早期版本中，对批处理也有一定程度的支持，但是总的来说，和 Spark 对比起来，Spark 批强流弱，Flink  流强批弱，二者无法独占分布式计算市场。</p><p>为了支持流批一体，Flink 做了以下几点改造：</p><ul><li>2015 年，阿里巴巴对 Spark 和 Flink 做了大量调研，认为 Flink Streaming 的概念优于 Spark Micro Batch 的概念。之后，阿里巴巴重投入大量人力开发基于 Flink 的内部版本 Blink，在 Flink DataStream、DataSet 底层 API 的基础上，强化了对 SQL 和 Table API 的支持，并在 2019 年将 Blink 的实现捐献给 到 Flink 社区。经过社区几个大版本的迭代，DataStream API 可以同时支持流和批，DataSet API 退出了历史舞台，Flink 终于能够提供统一的流批一体语义。</li></ul><p><img src="/images/bigdata-arch-10.png" alt="img"></p><ul><li>推出子项目 Flink CDC，借助于 Flink SQL 和 DataStream API 强大的流批一体语义，在数据集成环节实现流批一体。</li><li>推出 Flink Batch 模式，用户只需要配置一个 Mode 即可自由实现批和流的切换。在性能上，实现了自适应批处理调度器、动态分区裁剪、推测执行、混合 Shuffle 等，能够提供不弱于 Spark 的批处理能力。</li><li>推出 Flink Catalog，强化对离线数仓生态的支持。</li></ul><p>在计算层，Flink 实现了流和批的统一，我们还需要让存储层支持流批一体，而无论是离线的 Hive 还是实时的 Kafka，都难以做到，因此需要新的存储系统来解决这个问题。目前，主要有两种主流存储架构可以提供流批一体：流式数据湖和统一实时数仓，下面我们分别讲一讲。</p><h2 id="3-6-流批一体存储"><a href="#3-6-流批一体存储" class="headerlink" title="3.6 流批一体存储"></a>3.6 流批一体存储</h2><h3 id="3-6-1-流式数据湖架构"><a href="#3-6-1-流式数据湖架构" class="headerlink" title="3.6.1 流式数据湖架构"></a>3.6.1 流式数据湖架构</h3><p>数据湖这个概念出现于2010年，旨在解决传统数据仓库和数据集市所面临的两大难题。首先，它希望通过统一的元数据存储来解决数据集市之间的数据孤岛问题，让所有数据都能够相互连接和共享。其次，数据湖还希望存储原始数据，包括结构化、半结构化和非结构化数据，而不是存储经过裁剪后的数据集市，以确保不会丢失数据的原始信息。</p><p>数据湖主要经历了四个发展阶段：</p><ol><li>早期，数据湖直接构建于 HDFS 之上，主要应用于机器学习所需要的大规模数据存储。由于缺乏有效的元数据管理，人们很难从中提取出有价值的信息。缺乏维护、管理的数据湖，随着大量低价值密度数据的涌入，会很快退化为数据沼泽，难以支持 BI（商业智能）业务。</li><li>随着云计算的发展， 2015 年，各个云厂商推出了基于对象存储（OSS）的云产品。对象存储具有大规模、高可用和低成本的优势，逐步替代了 HDFS 成为云上统一存储的主流选择。</li><li>2019 年前后，随着 Databricks、Uber 等公司陆续推出被称为数据湖三剑客的 Delta Lake、Hudi 和 Iceberg 湖格式，数据湖得到了广泛的应用。通过在数据湖的原始数据之上再构建一层元数据层、索引层的方式，解决了数据湖上数据的可靠性、一致性和性能等问题。</li><li>2020 年，以数据湖三剑客为代表的湖格式，生态建立在 Hadoop 和 Spark 的基础上，对批处理的支持较好。2022 年，随着 Paimon、Hudi 等湖格式支持 Changelog，并加强 Flink 的生态建设，数据湖内的数据可以实时流动起来，流式数据湖的概念推广起来。</li></ol><p>数据湖的特性包括：</p><ul><li>ACID 事务：同一张表经常会同时有多个工作流来读写，事务保证了我们能够读、写到正确的数据。</li><li>Schema Evolution：允许修改表的字段信息（如增删字段，修改字段类型和描述等）。</li><li>支持结构 &#x2F; 非结构数据，支持多类 API：湖仓架构能够支持半 &#x2F; 非结构化数据（如 JSON，图像，语音等）的存储，以及提供除了基本 SQL 之外丰富的 API 来处理数据，应用在如机器学习等场景。</li><li>流批一体：用数据湖架构替代 Lambda 架构，能够有效的简化流式和离线两条数据链路的开发和运维成本。</li><li>采用 ELT（提取 - 加载 - 转换）过程，而不是传统数仓的 ETL（提取 - 转换 - 加载）过程。</li><li>存算分离：存储和计算可以按需伸缩，并且使用廉价的 OSS、HDFS、MinIO 等存储介质，降低整体成本。</li></ul><p><img src="/images/bigdata-arch-11.png" alt="img"></p><p>在国内，Hudi 和 Iceberg 的使用更多一点，Paimon 作为 Flink 的生态项目，对 Flink 的支持更完善，目前还处于追赶阶段。</p><p>下面是一个基于 Hudi 的流式数据湖架构。它与 Kappa 架构很像，区别只是在于用 Hudi 替换了 Kafka 作为存储介质，以提供流批一体的存储能力，同时支持流读流写、批读批写。</p><p><img src="/images/bigdata-arch-12.png" alt="img"></p><p>上面介绍的流式数据湖架构因为底层还是 HDFS，在分析能力和数据入湖速度上都是较慢的：</p><ul><li>虽然号称是流式数据湖，但通常还是使用批的方式进行导入，以降低底层小文件合并的压力，整体延迟比实时数仓高。</li><li>Hudi 分析能力差，需要额外引入 Trino、Spark 等查询引擎，加上数据湖本身就是建立在 Hadoop 之上的，还要维护一个 Hadoop 集群，架构上更加复杂了。Paimon 虽然可以提供高性能的单表查询能力，一旦多表关联查询性能就会大幅下降。</li></ul><p>有没有更简单的架构可以支持存储、计算、分析的流批一体呢？</p><h3 id="3-6-2-统一数仓架构"><a href="#3-6-2-统一数仓架构" class="headerlink" title="3.6.2 统一数仓架构"></a>3.6.2 统一数仓架构</h3><p>2016 年后，随着 Clickhouse 和 Doris 这两款性能极其强大的 MPP 数据库的开源，基于 Clickhouse 和 Doris 的实时数仓架构快速取代了基于 Kafka 的实时数仓架构。以 Doris 为例，主要有以下几大优势：</p><ol><li>高性能的数据存储和数据分析能力，多表关联查询能力突出。</li><li>数据全量存储，可以基于任意时间节点进行数据回溯。</li><li>数仓自身即可实现数据集成和数据分层，存储、计算、分析一体，极简架构，运维成本低。</li><li>支持 Flink CDC 的流批一体写入，也支持 Kafka 流写入或 MySQL、HDFS 批写入。</li><li>支持联邦查询和数据湖加速。</li></ol><p><img src="/images/bigdata-arch-13.png" alt="img"></p><p>上图可以看到，基于 Doris 的数仓架构链路短、组件少，简单易用，因此又称这种架构为统一数仓架构。这么简单的架构，Doris 是怎么实现流批一体的呢？</p><p>首先，在流处理环节：</p><ul><li>存储层：Doris 借助于 Flink Connector 可以实现毫秒级的数据更新和表结构变更。</li><li>计算层：Doris基于 Unique、Aggregate 和 Duplicate 数据模型，加上物化视图等能力，可以实现毫秒级数据分层，或者微批调度实现分钟级数据分层。</li><li>分析层：Doris 可以实现毫秒级多表关联查询。</li></ul><p>在批处理环节：</p><ul><li>存储层：Doris 通过 Broker 组件可以实现大批量的离线数据导入导出。</li><li>计算层：通过周期性调度实现数据处理和分层。</li><li>分析层：Doris 本身的分析能力可以支持离线场景下的分析，也可以导出到外部系统进行分析，产出离线指标。</li></ul><p>因此在存储、计算、分析等环节，Doris 都是流批一体的。</p><p>那么基于 Doris 的统一实时数仓架构有没有什么问题呢？</p><p>主要还是实时数仓本身的一些固有问题：</p><ol><li>首先，是实时数仓分层困难、上层数据不准的问题。实时数仓能够支持的业务复杂度和数据模型的复杂度都是有限的，并且层数多了后，延迟和数据不准确也会增加。因此在实践中，不建议分太多层。<br> <img src="/images/bigdata-arch-14.png" alt="img"><ul><li>Doris 的存储主要使用 SSD，存储成本比较高。</li><li>Doris 不支持 Binlog 和 Changelog，因此不支持流读和时间旅行（数据多版本），数据一旦被更新，旧的数据就丢失了。</li><li>Doris 对非架构化数据、半结构化数据的支持不佳。</li></ul></li></ol><p>以上的一些问题，很多已经列入了 Doris 2023 年的 Roadmap，在未来发展规划上，Doris 将借鉴数据湖的优秀特性，同时继续强化已有的数仓能力。正在开发中的一些关键能力包括：</p><ol><li>在已有的冷热分层功能的基础上，推出存算分离架构，大幅降低 Doris 集群的成本，用户可以在成本和性能上自主权衡。</li><li>实现 Changelog 和数据版本功能，在此基础上可以实现流读、消息订阅、时间旅行等，成为类似于 Paimon、Hudi 流式数据湖一样的流式数仓。</li><li>实现多表物化视图，在此基础上，实时数仓分层又多了一个新的选择。之前，单表的物化视图大部分情况下只能提供DWD层的分层。多表物化视图可以实现更高级别的分层，不再依赖调度系统进行微批处理，架构上更加统一了。</li><li>提升数据湖分析能力，增强对非结构化和半结构化数据的支持。</li><li>增强对高并发数据服务的支持，在中小规模业务场景下，Doris 可以直接对外提供数据服务，不再需要通过 KV 存储。</li></ol><p>未来，很期待 Doris 实现真正意义上的统一数仓，用 Doris 一个组件就可以实现实时数仓的搭建，成为中国的 Snowflake。</p><h1 id="05-新一代湖仓架构"><a href="#05-新一代湖仓架构" class="headerlink" title="05 新一代湖仓架构"></a>05 新一代湖仓架构</h1><p>最后，让我们展望一下未来几年湖仓架构发展的趋势。</p><h2 id="5-1-湖仓一体"><a href="#5-1-湖仓一体" class="headerlink" title="5.1 湖仓一体"></a>5.1 湖仓一体</h2><p>数据湖和数据仓库技术发展了二十年，各有优劣，谁也难以统一谁。在大型公司，通常数据湖、离线数据仓库，实时数据仓库都是要共同建设的，以满足不同业务线的需求。因此，湖仓一体这种湖和仓互相补充，协同工作的架构，在这几年被广泛推广。</p><p><img src="/images/bigdata-arch-15.png" alt="img"></p><p>湖仓一体，简单来说，就是将数据湖的数据和数仓的数据从架构上互相打通，数据以低成本在湖和仓之间流动。</p><p>对于如何实现湖仓一体架构，有很多种实现，包括：</p><ol><li>湖上建仓：数据先全量存储到数据湖中，再将湖中的数据清洗后存储到数据仓库中，在数仓中进行数据建模、数据分层、元数据管理。</li><li>湖内建仓：数据先全量存储到数据湖中，再将湖中的数据清洗后进行数据建模、数据分层、元数据管理。</li><li>仓上建湖：数据先存储到数据仓库中，再将仓中的数据存储到数据湖中。数据湖存储全量数据，数仓周期性清理历史数据，只保留近期的数据。</li><li>湖旁建仓：数据湖和数据仓库的数据来自不同数据源，但是可以互相访问和快速流通。MPP 类型的数据仓库可以对湖中的数据进行查询加速。</li></ol><p>以 Hudi、Paimon 为代表的流式数据湖架构，和以 Doris、Clickhouse 为代表的统一数仓架构，在这几年经历了快速的发展。数据仓库和数据湖的边界正在慢慢模糊，数据湖自身的治理能力、数据仓库延伸到外部存储的能力都在加强。相信在不远的将来，湖和仓会实现真实的融合。</p><h2 id="5-2-云原生湖仓"><a href="#5-2-云原生湖仓" class="headerlink" title="5.2 云原生湖仓"></a>5.2 云原生湖仓</h2><p>除了之前介绍的数据湖、数据仓库的开源产品之外，各大云厂商都在主推自己的云原生湖仓，例如 Snowflake、阿里的 Hologres、MaxCompute，字节的 LAS（基于 Hudi）等，这些云产品的典型特性包括免运维、弹性伸缩等，同时性能也非常强大，湖仓全面云原生化是一个大的趋势。</p><h2 id="5-3-流式湖仓"><a href="#5-3-流式湖仓" class="headerlink" title="5.3 流式湖仓"></a>5.3 流式湖仓</h2><p>基于 Streaming Lakehouse 理念，实现数仓不同层级之间的实时数据的高效流动，可以解决实时数仓分层问题。目前 Hudi、Paimon 先后提出了流式数据湖的概念，其他开源湖仓产品和云湖仓产品也在跟进。</p><h1 id="06-总结"><a href="#06-总结" class="headerlink" title="06 总结"></a>06 总结</h1><p>看到这里，相信你对大数据架构真的是非常感兴趣了！在本文最后，让我们回顾一下大数据架构整体的发展脉络：<br>传统数仓架构 -&gt; 离线大数据架构（数仓 &#x2F; 数据湖） -&gt; Lambda 数仓架构 -&gt; Kappa 数仓架构 -&gt; 新一代实时数仓 &#x2F; 流式数据湖 -&gt; 湖仓一体 -&gt; 湖仓融合 -&gt; 云原生湖仓</p><p><img src="/images/bigdata-arch-16.png" alt="img"></p><p>最后我想说的是：架构从来没有优劣之分，不要盲目选择最先进的技术架构，而是应当综合考虑业务核心诉求、人力和资源预算、团队技术栈、维护成本等多方面因素，仔细权衡后再做决定，并且随着业务的发展不断调整我们的架构。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
            <tag> Spark </tag>
            
            <tag> Doris </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大语言模型 SFT 效果验证</title>
      <link href="/2023/08/09/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%20SFT%20%E6%95%88%E6%9E%9C%E9%AA%8C%E8%AF%81/"/>
      <url>/2023/08/09/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%20SFT%20%E6%95%88%E6%9E%9C%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h2 id="数据集分割：一般情况下数据集分为训练集、测试集和评估集三个"><a href="#数据集分割：一般情况下数据集分为训练集、测试集和评估集三个" class="headerlink" title="数据集分割：一般情况下数据集分为训练集、测试集和评估集三个"></a>数据集分割：一般情况下数据集分为训练集、测试集和评估集三个</h2><h2 id="自动化验证评估：社区已有一些经验，目前Code方向详见：HumanEval-x自动化评测，其他方向正在建设中"><a href="#自动化验证评估：社区已有一些经验，目前Code方向详见：HumanEval-x自动化评测，其他方向正在建设中" class="headerlink" title="自动化验证评估：社区已有一些经验，目前Code方向详见：HumanEval-x自动化评测，其他方向正在建设中"></a>自动化验证评估：社区已有一些经验，目前Code方向详见：HumanEval-x自动化评测，其他方向正在建设中</h2><h2 id="人工评估：基本上就是通过人工打分方式来评估模型效果，比如认为区分三个等级：好的、一般、不好。通过有效占比来看模型效果。比如针对某个query，填写如下内容："><a href="#人工评估：基本上就是通过人工打分方式来评估模型效果，比如认为区分三个等级：好的、一般、不好。通过有效占比来看模型效果。比如针对某个query，填写如下内容：" class="headerlink" title="人工评估：基本上就是通过人工打分方式来评估模型效果，比如认为区分三个等级：好的、一般、不好。通过有效占比来看模型效果。比如针对某个query，填写如下内容："></a>人工评估：基本上就是通过人工打分方式来评估模型效果，比如认为区分三个等级：好的、一般、不好。通过有效占比来看模型效果。比如针对某个query，填写如下内容：</h2><ul><li>新模型结果：新模型打分（参考2，1，0，-1，2代表优质、1为可以接受，0代表差不满足但是不会带来负向影响，-1为误导错误信息）</li><li>旧模型结果：旧模型打分（参考2，1，0，-1）</li><li>新旧模型GBS对比（参考-2、-1、0、1、2五档打分，2代表新模型明显比旧模型好，1代表新模型略好，0代表新旧模型效果差不多）</li><li>新模型效果整体可接受率（一般为1+2的比例，特殊业务可以自己定义）</li><li>旧模型效果整体可接受率</li><li>目标效果可接收率</li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大语言模型精调范式</title>
      <link href="/2023/08/09/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%B2%BE%E8%B0%83%E8%8C%83%E5%BC%8F/"/>
      <url>/2023/08/09/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%B2%BE%E8%B0%83%E8%8C%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：什么是 Fine-tuning<br>在机器学习中，微调是一种迁移学习方法，其中将预训练模型的权重训练到新数据上。微调可以在神经网络的一部分层上进行，也可以在整个网络上进行。在第一种情况下，未进行微调的层被 &gt; “冻结”，在反向传播步骤中不会更新。</p><p>对于某些结构，如卷积神经网络，通常会保持较早的层冻结，因为它们已经被证明可以捕捉较低级别的特征，而与此不同的是，后面的层通常关注与模型训练任务更相关的高级特征。<br>微调在自然语言处理（NLP）领域也很常见，尤其是在语言建模领域。像 OpenAI 的 GPT-2 这样的大型语言模型可以通过对下游 NLP 任务进行微调来获得比预训练模型通常能达到的更好结果。通常通过在大型和通用语料库上预训练的模型，将模型的参数作为起点，并添加从零开始训练的任务特定层来进行微调。完全微调模型也很常见，通常会产生更好的结果，但这是一种更加计&gt; 算密集的方法。完全微调还更容易过拟合，并可能导致模型在离群值分布上表现不佳。</p><p>微调通常使用有监督学习方法进行，但也有使用弱监督方法微调模型的技术。最近，通过人类反馈的强化学习也被用于微调像 ChatGPT（这是 GPT-3 的微调版本）和 Sparrow 这样的语言模型。</p></blockquote><h1 id="1-Pre-train-Fine-tuning"><a href="#1-Pre-train-Fine-tuning" class="headerlink" title="1. Pre-train + Fine-tuning"></a>1. Pre-train + Fine-tuning</h1><h2 id="1-1-为什么要精调"><a href="#1-1-为什么要精调" class="headerlink" title="1.1 为什么要精调"></a>1.1 为什么要精调</h2><ol><li>对于数据集本身很小的情况，从头开始训练具有几亿、几十亿甚至上百亿参数的大型神经网络是不现实的，因为越大的模型对数据量的要求越大，过拟合无法避免。这时候如果还想用上大型神经网络的超强特征提取能力，只能靠精调已经训练好的模型。</li><li>可以降低训练成本（时间成本、计算架构成本、大语料成本）：如果使用导出特征向量的方法进行迁移学习，后期的训练成本非常低，用低配 GPU 就可以训练。</li><li>前人花很大精力训练出来的模型在大概率上会比你自己从零开始搭的模型要强悍，没有必要重复造轮子。</li></ol><p>人工智能的快速发展推动了大模型的广泛应用，在语言、视觉、语音等领域的应用效果已经越来越好。但是，训练一个大模型需要巨大的计算资源和时间成本（计算架构壁垒、大语料壁垒），为了减少这种资源的浪费，模型精调已经成为一种流行的技术。</p><p>模型精调是指在预训练模型的基础上，通过在小数据集上的训练来适应新的任务。</p><p>传统的线性过程思维是” 因果一一对应 “，我们设定了什么规则和指令，结果就是完全一一按照我们的规则 &#x2F; 指令生成的，不会产生模糊和意外之外的结果。但是到了神经网络，尤其是超大型神经网络中，由于参数空间和语料库都十分巨大，因此在超高维的参数空间中，知识的储存是以一种很抽象 &#x2F; 高维的形式存在。通俗上理解就是：大模型通过学习了大语料之后，储存了大语料中包含的深层次知识，这些知识在不同的子领域都具备一定程度的迁移能力。所谓精调，本质上就是通过新领域语料库对模型的权重参数进行指向性精调（或者是增加一些新的结构，在新的结构上进行精调），从而使新的大模型具备在新的垂直领域上的预测路径。</p><h2 id="1-2-如何进行精调"><a href="#1-2-如何进行精调" class="headerlink" title="1.2 如何进行精调"></a>1.2 如何进行精调</h2><p>AIGC（AI 芯片）的出现进一步加快了大模型的推广，可以提供更快的计算速度和更大的存储容量，精调主要有如下几种分类：</p><ul><li>精调所有层：将预训练模型的所有层都参与精调，以适应新的任务。</li><li>精调顶层：只精调预训练模型的顶层，以适应新的任务。</li><li>冻结底层：将预训练模型的底层固定不变，只对顶层进行精调。</li><li>逐层精调：从底层开始，逐层精调预训练模型，直到所有层都被精调。</li><li>迁移学习：将预训练模型的知识迁移到新的任务中，以提高模型性能。（这种方法通常使用精调顶层或冻结底层的方法。）<br>以下使用 Paddle 实现五种精调方法：</li></ul><h3 id="1-2-1-精调所有层"><a href="#1-2-1-精调所有层" class="headerlink" title="1.2.1 精调所有层"></a>1.2.1 精调所有层</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line"><span class="keyword">from</span> paddlenlp.transformers <span class="keyword">import</span> GPT2Model, GPT2ForPretraining, GPT2PretrainingCriterion</span><br></pre></td></tr></table></figure><h4 id="加载预训练模型"><a href="#加载预训练模型" class="headerlink" title="加载预训练模型"></a>加载预训练模型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = GPT2ForPretraining.from_pretrained (<span class="string">&#x27;gpt2-medium-en&#x27;</span>)</span><br><span class="line">tokenizer = GPT2Tokenizer.from_pretrained (<span class="string">&#x27;gpt2-medium-en&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="定义新的分类头"><a href="#定义新的分类头" class="headerlink" title="定义新的分类头"></a>定义新的分类头</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class_num = <span class="number">2</span></span><br><span class="line">cls = paddle.nn.Linear (model.config [<span class="string">&quot;hidden_size&quot;</span>], class_num)</span><br></pre></td></tr></table></figure><h4 id="将新的分类头添加到模型中"><a href="#将新的分类头添加到模型中" class="headerlink" title="将新的分类头添加到模型中"></a>将新的分类头添加到模型中</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.cls = cls</span><br></pre></td></tr></table></figure><h4 id="通过精调所有层来适应新任务"><a href="#通过精调所有层来适应新任务" class="headerlink" title="通过精调所有层来适应新任务"></a>通过精调所有层来适应新任务</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimizer = paddle.optimizer.Adam (learning_rate=<span class="number">1e-5</span>, parameters=model.parameters ())</span><br><span class="line">criterion = GPT2PretrainingCriterion ()</span><br></pre></td></tr></table></figure><h3 id="1-2-2-精调顶层"><a href="#1-2-2-精调顶层" class="headerlink" title="1.2.2 精调顶层"></a>1.2.2 精调顶层</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line"><span class="keyword">from</span> paddlenlp.transformers <span class="keyword">import</span> GPT2Model, GPT2ForPretraining, GPT2PretrainingCriterion</span><br></pre></td></tr></table></figure><h4 id="加载预训练模型-1"><a href="#加载预训练模型-1" class="headerlink" title="加载预训练模型"></a>加载预训练模型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = GPT2ForPretraining.from_pretrained (<span class="string">&#x27;gpt2-medium-en&#x27;</span>)</span><br><span class="line">tokenizer = GPT2Tokenizer.from_pretrained (<span class="string">&#x27;gpt2-medium-en&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="固定模型底层，只精调顶层"><a href="#固定模型底层，只精调顶层" class="headerlink" title="固定模型底层，只精调顶层"></a>固定模型底层，只精调顶层</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> model.parameters ():</span><br><span class="line">    param.trainable = <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="定义新的分类头-1"><a href="#定义新的分类头-1" class="headerlink" title="定义新的分类头"></a>定义新的分类头</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class_num = <span class="number">2</span></span><br><span class="line">cls = paddle.nn.Linear (model.config [<span class="string">&quot;hidden_size&quot;</span>], class_num)</span><br></pre></td></tr></table></figure><h4 id="将新的分类头添加到模型中-1"><a href="#将新的分类头添加到模型中-1" class="headerlink" title="将新的分类头添加到模型中"></a>将新的分类头添加到模型中</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.cls = cls</span><br></pre></td></tr></table></figure><h4 id="通过精调顶层来适应新任务"><a href="#通过精调顶层来适应新任务" class="headerlink" title="通过精调顶层来适应新任务"></a>通过精调顶层来适应新任务</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> model.cls.parameters ():</span><br><span class="line">    param.trainable = <span class="literal">True</span></span><br><span class="line">optimizer = paddle.optimizer.Adam (learning_rate=<span class="number">1e-5</span>, parameters=model.cls.parameters ())</span><br><span class="line">criterion = paddle.nn.CrossEntropyLoss ()</span><br></pre></td></tr></table></figure><h3 id="1-2-3-冻结底层"><a href="#1-2-3-冻结底层" class="headerlink" title="1.2.3 冻结底层"></a>1.2.3 冻结底层</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line"><span class="keyword">import</span> paddle.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> paddlenlp.transformers <span class="keyword">import</span> GPTForPretraining, GPTChineseTokenizer</span><br></pre></td></tr></table></figure><h4 id="加载预训练模型和分词器"><a href="#加载预训练模型和分词器" class="headerlink" title="加载预训练模型和分词器"></a>加载预训练模型和分词器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = GPTForPretraining.from_pretrained (<span class="string">&#x27;gpt-cpm-large-cn&#x27;</span>)</span><br><span class="line">tokenizer = GPTChineseTokenizer.from_pretrained (<span class="string">&#x27;gpt-cpm-large-cn&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="构造数据集和数据加载器"><a href="#构造数据集和数据加载器" class="headerlink" title="构造数据集和数据加载器"></a>构造数据集和数据加载器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">train_ds = [[<span class="string">&#x27; 今天天气不错 &#x27;</span>], [<span class="string">&#x27; 明天要下雨 &#x27;</span>], [<span class="string">&#x27; 这个季节很适合旅游 &#x27;</span>]]</span><br><span class="line">train_ds = [&#123;<span class="string">&#x27;text&#x27;</span>: text&#125; <span class="keyword">for</span> text <span class="keyword">in</span> train_ds]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">batch_iter</span> (data, batch_size):</span><br><span class="line">    num_batches = <span class="built_in">len</span> (data) //batch_sizeif <span class="built_in">len</span> (data) % batch_size != <span class="number">0</span>:</span><br><span class="line">        num_batches += <span class="number">1</span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (num_batches):</span><br><span class="line">        batch = data [i * batch_size: (i + <span class="number">1</span>) * batch_size]</span><br><span class="line">        <span class="keyword">yield</span> batch</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">2</span></span><br><span class="line">train_loader = paddle.io.DataLoader (train_ds, batch_size=batch_size, shuffle=<span class="literal">True</span>, drop_last=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="构造优化器和损失函数"><a href="#构造优化器和损失函数" class="headerlink" title="构造优化器和损失函数"></a>构造优化器和损失函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimizer = paddle.optimizer.AdamW (parameters=model.parameters (), learning_rate=<span class="number">1e-4</span>)</span><br><span class="line">criterion = F.cross_entropy</span><br></pre></td></tr></table></figure><h4 id="冻结底层"><a href="#冻结底层" class="headerlink" title="冻结底层"></a>冻结底层</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> model.layers [:<span class="number">6</span>]:</span><br><span class="line">    layer.<span class="built_in">eval</span> ()</span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> layer.parameters ():</span><br><span class="line">        param.trainable = <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="精调模型"><a href="#精调模型" class="headerlink" title="精调模型"></a>精调模型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> train_loader:</span><br><span class="line">        texts = [example [<span class="string">&#x27;text&#x27;</span>] <span class="keyword">for</span> example <span class="keyword">in</span> batch]</span><br><span class="line">        encoded_inputs = tokenizer (texts, return_attention_mask=<span class="literal">True</span>, return_length=<span class="literal">True</span>, padding=<span class="literal">True</span>)</span><br><span class="line">        input_ids = paddle.to_tensor (encoded_inputs [<span class="string">&#x27;input_ids&#x27;</span>])</span><br><span class="line">        attention_mask = paddle.to_tensor (encoded_inputs [<span class="string">&#x27;attention_mask&#x27;</span>])</span><br><span class="line">        logits = model (input_ids, attention_mask=attention_mask)[<span class="number">0</span>]</span><br><span class="line">        loss = criterion (logits.reshape (-<span class="number">1</span>, logits.shape [-<span class="number">1</span>]), input_ids.reshape (-<span class="number">1</span>))</span><br><span class="line">        loss.backward ()</span><br><span class="line">        optimizer.step ()</span><br><span class="line">        optimizer.clear_grad ()</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">f&#x27;Epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>: loss=<span class="subst">&#123;loss.numpy ():<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="保存精调后的模型"><a href="#保存精调后的模型" class="headerlink" title="保存精调后的模型"></a>保存精调后的模型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paddle.save (model.state_dict (), <span class="string">&#x27;gpt-cpm-large-cn-finetuned</span></span><br></pre></td></tr></table></figure><h4 id="1-2-4-逐层精调"><a href="#1-2-4-逐层精调" class="headerlink" title="1.2.4 逐层精调"></a>1.2.4 逐层精调</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line"><span class="keyword">import</span> paddle.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> paddlenlp.transformers <span class="keyword">import</span> GPTForPretraining, GPTChineseTokenizer</span><br></pre></td></tr></table></figure><h4 id="加载预训练模型和分词器-1"><a href="#加载预训练模型和分词器-1" class="headerlink" title="加载预训练模型和分词器"></a>加载预训练模型和分词器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = GPTForPretraining.from_pretrained (<span class="string">&#x27;gpt-cpm-large-cn&#x27;</span>)</span><br><span class="line">tokenizer = GPTChineseTokenizer.from_pretrained (<span class="string">&#x27;gpt-cpm-large-cn&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="构造数据集和数据加载器-1"><a href="#构造数据集和数据加载器-1" class="headerlink" title="构造数据集和数据加载器"></a>构造数据集和数据加载器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">train_ds = [[<span class="string">&#x27; 今天天气不错 &#x27;</span>], [<span class="string">&#x27; 明天要下雨 &#x27;</span>], [<span class="string">&#x27; 这个季节很适合旅游 &#x27;</span>]]</span><br><span class="line">train_ds = [&#123;<span class="string">&#x27;text&#x27;</span>: text&#125; <span class="keyword">for</span> text <span class="keyword">in</span> train_ds]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">batch_iter</span> (data, batch_size):</span><br><span class="line">    num_batches = <span class="built_in">len</span> (data) //batch_sizeif <span class="built_in">len</span> (data) % batch_size != <span class="number">0</span>:</span><br><span class="line">        num_batches += <span class="number">1</span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (num_batches):</span><br><span class="line">        batch = data [i * batch_size: (i + <span class="number">1</span>) * batch_size]</span><br><span class="line">        <span class="keyword">yield</span> batch</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">2</span></span><br><span class="line">train_loader = paddle.io.DataLoader (train_ds, batch_size=batch_size, shuffle=<span class="literal">True</span>, drop_last=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="构造优化器和损失函数-1"><a href="#构造优化器和损失函数-1" class="headerlink" title="构造优化器和损失函数"></a>构造优化器和损失函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimizer = paddle.optimizer.AdamW (parameters=model.parameters (), learning_rate=<span class="number">1e-4</span>)</span><br><span class="line">criterion = F.cross_entropy</span><br></pre></td></tr></table></figure><h4 id="迁移学习精调模型"><a href="#迁移学习精调模型" class="headerlink" title="迁移学习精调模型"></a>迁移学习精调模型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> train_loader:</span><br><span class="line">        texts = [example [<span class="string">&#x27;text&#x27;</span>] <span class="keyword">for</span> example <span class="keyword">in</span> batch]</span><br><span class="line">        encoded_inputs = tokenizer (texts, return_attention_mask=<span class="literal">True</span>, return_length=<span class="literal">True</span>, padding=<span class="literal">True</span>)</span><br><span class="line">        input_ids = paddle.to_tensor (encoded_inputs [<span class="string">&#x27;input_ids&#x27;</span>])</span><br><span class="line">        attention_mask = paddle.to_tensor (encoded_inputs [<span class="string">&#x27;attention_mask&#x27;</span>])</span><br><span class="line">        logits = model (input_ids, attention_mask=attention_mask)[<span class="number">0</span>]</span><br><span class="line">        loss = criterion (logits.reshape (-<span class="number">1</span>, logits.shape [-<span class="number">1</span>]), input_ids.reshape (-<span class="number">1</span>))</span><br><span class="line">        loss.backward ()</span><br><span class="line">        optimizer.step ()</span><br><span class="line">        optimizer.clear_grad ()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>: loss=<span class="subst">&#123;loss.numpy ():<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="保存精调后的模型-1"><a href="#保存精调后的模型-1" class="headerlink" title="保存精调后的模型"></a>保存精调后的模型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paddle.save(model.state_dict (), <span class="string">&#x27;gpt-cpm-large-cn-finetuned-transfer-learning.pdparams&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="2-Lightweight-finetuning-技术"><a href="#2-Lightweight-finetuning-技术" class="headerlink" title="2. Lightweight-finetuning 技术"></a>2. Lightweight-finetuning 技术</h1><p>随着计算算力的不断增加，以 transformer 为主要架构的预训练模型进入了百花齐放的时代。经过海量数据训练的模型相比于一般的深度模型而言，包含更多的参数，动辄数十亿、数百亿。在针对不同下游任务做精调时，存储和训练这种大模型是十分昂贵且耗时的。更麻烦的是，如果每一个垂直领域都要重新训练一个新的” 庞然大物 “出来，显然在时间和空间上都是不可接受的。<br>为了解决这个问题，各种 lightweight-finetuning 的方法被提了出来，相比于全参数精调，只需要以一个较小的训练和存储代价就可以取得和全模型精调相当的结果，大幅度降低了资源和时间成本。</p><h2 id="2-1-Adapters-tune"><a href="#2-1-Adapters-tune" class="headerlink" title="2.1 Adapters-tune"></a>2.1 Adapters-tune</h2><p><img src="/images/%E6%A8%A1%E5%9E%8B%E7%B2%BE%E8%B0%83-1.png" alt="img"></p><p>首先，adapter 方法的原理并不复杂，它是通过在原始的预训练模型中的每个 transformer block 中加入一些参数可训练的模块实现的。<br>假设原始的预训练模型的参数为 ω，加入的 adapter 参数为 υ，在针对不同下游任务进行调整时，只需要将预训练参数固定住，只针对 adapter 参数 υ 进行训练。通常情况下，参数量 υ&lt;&lt;ω, 因此在对多个下游任务调整时，只需要调整极小数量的参数，大大的提高了预训练模型的扩展性和实用性。<br>对于 adapter 模块的网络组成，不同文章中针对不同任务略有不同。但是比较一致的结论是，bottleneck 形式的两层全连接神经网络就已经可以满足要求。每个 transformer 层中有两个 adapter 模块，在每个 adapter 模块中，先将经过多头注意力和前馈层输出的 output 做一个降维的映射。经过一个非线性激活层后，再将特征矢量映射回原始的维度。在下游训练任务中，只更新 adapter 模块和 layer Norm 层（下图中的绿色部分）。</p><p><img src="/images/%E6%A8%A1%E5%9E%8B%E7%B2%BE%E8%B0%83-2.png" alt="img"></p><p>相比于预训练模型的全参数精调，Adapter 方法的优势十分明显：</p><ul><li>针对不同下游任务可保持预训练模型不变，仅需训练 adapter 模块的少量参数，训练代价小，可移植性强。</li><li>对于不同任务的连续学习（continual learning）而言，由于在训练不同任务时只需要训练不同的 adapter，其他模型参数保持不变，避免了在学习新任务时对过往任务的遗忘。</li></ul><p>huggingface 开源了 transformer 库，在原来框架的基础上增添了 adapter 模块的训练和扩展，只需要在原来的训练脚本中更改不超过两行的代码，就可以针对不同的下游任务无缝训练新的 adapter 模块，并且整个 adapter 模块的参数和原始的预训练模型参数是完全独立存储的。</p><h1 id="3-Pre-train-Prompt-tuning-Predict"><a href="#3-Pre-train-Prompt-tuning-Predict" class="headerlink" title="3. Pre-train + Prompt-tuning + Predict"></a>3. Pre-train + Prompt-tuning + Predict</h1><h2 id="3-1-什么是-Prompt-Tuning"><a href="#3-1-什么是-Prompt-Tuning" class="headerlink" title="3.1 什么是 Prompt-Tuning"></a>3.1 什么是 Prompt-Tuning</h2><p>自从 GPT、EMLO、BERT 的相继提出，以 Pre-training + Fine-tuning 的模式在诸多自然语言处理（NLP）任务中被广泛使用，其先在 Pre-training 阶段通过一个模型在大规模无监督语料上预先训练一个预训练语言模型（Pre-trained Language Model，PLM），然后在 Fine-tuning 阶段基于训练好的语言模型在具体的下游任务上再次进行精调（Fine-tuning），以获得适应下游任务的模型。这种模式在诸多任务的表现上超越了传统的监督学习方法，不论在工业生产、科研创新中均作为新的主流方式。然而，这套模式也存在着一些问题：</p><ul><li>在大多数的下游任务精调时，下游任务的目标与预训练的目标差距过大导致提升效果不明显</li><li>精调过程中依赖大量的监督语料等</li></ul><p>因此，以 GPT-3、PET 为首提出了 Prompt-Tuning（一种基于预训练语言模型的新的精调范式），其旨在通过添加模板的方法来避免引入额外的参数，从而让语言模型可以在小样本（Few-shot）或零样本（Zero-shot）场景下达到理想的效果。</p><p>Prompt-Tuning 又可以称为 Prompt、Prompting、Prompt-based Fine-tuning 等。</p><p>简单的来说，Prompt-Tuning 的动机旨在解决目前传统 Fine-tuning 的两个痛点问题：</p><ul><li>降低语义差异（Bridge the gap between Pre-training and Fine-tuning）：预训练任务主要以 Masked Language Modeling（MLM）为主，而下游任务则重新引入新的训练参数，因此两个阶段的目标通常有较大差异。</li><li>避免过拟合（Overfitting of the head）：由于在 Fine-tuning 阶段需要新引入额外的参数以适配相应的任务需要，因此在样本数量有限的情况容易发生过拟合，降低了模型的泛化能力。</li></ul><h2 id="3-2-Prompt-Tuning-的基本过程"><a href="#3-2-Prompt-Tuning-的基本过程" class="headerlink" title="3.2 Prompt-Tuning 的基本过程"></a>3.2 Prompt-Tuning 的基本过程</h2><p>Prompt-Tuning 执行如下步骤：</p><ul><li>构建模板（Template Construction）：通过人工定义、自动搜索、文本生成等方法，生成与给定句子相关的一个含有 [MASK] 标记的模板。例如 It was [MASK].，并拼接到原始的文本中，获得 Prompt-Tuning 的输入：[CLS] I like the Disney films very much. [SEP] It was [MASK]. [SEP]。将其喂入 BERT 模型中，并复用预训练好的 MLM 分类器，即可直接得到 [MASK] 预测的各个 token 的概率分布。</li><li>标签词映射（Label Word Verbalizer）：因为 [MASK] 部分我们只对部分词感兴趣，因此需要建立一个映射关系。例如如果 [MASK] 预测的词是 “great”，则认为是 positive 类，如果是 “terrible”，则认为是 negative 类。不同的句子应该有不同的模板和标签词，因为每个句子可能期望预测出来的标签词都不同，因此如何最大化的寻找当前任务更加合适的模板和标签词是 Prompt-tuning 非常重要的挑战。</li><li>训练：根据 Verbalizer，则可以获得指定标签词的预测概率分布，并采用交叉信息熵进行训练。此时因为只对预训练好的 MLM head 进行精调，所以避免了过拟合问题。</li></ul><blockquote><p>引入的模板和标签词本质上也属于一种数据增强，通过添加提示的方式引入先验知识。prompt-tuning 相比于传统的 fine-tune 范式，最大的创新点就在于引入了”context template“的概念，通过预定义的模板，大幅度限定了模型精调的优化方向，减少了搜索空间，使得 fine-tune 出来的模型在具体的任务领域有更好的泛化性能，甚至具备 zero-shot 的能力。</p></blockquote><h2 id="3-3-Prompt-Tuning-的本质"><a href="#3-3-Prompt-Tuning-的本质" class="headerlink" title="3.3 Prompt-Tuning 的本质"></a>3.3 Prompt-Tuning 的本质</h2><p>最初的 Prompt-Tuning 主旨在于设计 Template 和 Verbalizer（即 Pattern-Verbalizer Pair）来解决基于预训练模型的小样本文本分类，然而事实上，NLP 领域涉及到很多除了分类以外其他大量复杂的任务，例如抽取、问答、生成、翻译等。这些任务都有独特的任务特性，并不是简单的 PVP 就可以解决的，<br>以下为三个关于 Prompt 的本质：</p><ul><li>一种对任务的指令，可以作为一种信息增强。</li><li>一种对预训练任务的复用，实现基于 Prompt 的统一范式。</li><li>一种参数有效性学习。</li></ul><h3 id="3-3-1-一种对任务的指令，可以作为一种信息增强"><a href="#3-3-1-一种对任务的指令，可以作为一种信息增强" class="headerlink" title="3.3.1 一种对任务的指令，可以作为一种信息增强"></a>3.3.1 一种对任务的指令，可以作为一种信息增强</h3><blockquote><p>简单的来说，就是告诉模型需要做什么任务，输出什么内容。</p></blockquote><p>当数据集不同（乃至样本不同）的时候，我们期望模型能够自适应的选择不同的模板，这也相当于说不同的任务会有其对应的提示词信息。这一类具备任务特性的模板可以称之为指令（Instruction）。</p><p>下面展示几个任务设计的指令模板：</p><p><img src="/images/%E6%A8%A1%E5%9E%8B%E7%B2%BE%E8%B0%83-3.png" alt="img"></p><p>看似设计指令是一件容易的事情，但是在真实使用过程中，预训练模型很难 “理解” 这些指令，根据研究工作发现，主要总结如下几个原因：</p><ul><li>预训练模型不够大：我们常使用的 BERT-base、BERT-large、RoBERTa-base 和 RoBERTa-large 只有不到 10 亿参数，相比于现如今 GPT-3、OPT 等只能算作小模型，有工作发现，小模型在进行 Prompt Tuning 的时候会比 Fine-tuning 效果差，是因为小模型很容易受到模板的影响。对比一下传统的 Fine-tuning，每个样本的输入几乎都是不同的，然而基于 Prompt 的方法中，所有的样本输入都会包含相同的指令，这就导致小模型很容易受到这些指令带来的干扰。</li><li>缺乏指令相关的训练：这些小模型在预训练阶段没有专门学习过如何理解一些特殊的指令。</li></ul><h4 id="3-3-2-一种对预训练任务的复用，实现基于-Prompt-的统一范式"><a href="#3-3-2-一种对预训练任务的复用，实现基于-Prompt-的统一范式" class="headerlink" title="3.3.2 一种对预训练任务的复用，实现基于 Prompt 的统一范式"></a>3.3.2 一种对预训练任务的复用，实现基于 Prompt 的统一范式</h4><p>我们需要思考，上述所讲的内容为什么要设计 Template（和 Verbalizer）。<br>回顾之前我们介绍的几个预训练语言模型，我们发现目前绝大多数的双向预训练语言模型都包含 Masked Language Modeling（MLM），单向预训练语言模型都包含 Autoregressive Language Modeling（ALM），这些任务是预训练目标，本质上是预测被 mask 的位置的词，在训练时让模型理解语言的上下文信息。之所以设计模板和指令，就是希望在下游任务时能够复用这些预训练的目标，避免引入新的参数而导致过拟合。</p><p>因此，我们可以将 Prompt 升华到一个新的高度，即 Prompt Tuning 的本质是复用预训练语言模型在预训练阶段所使用的目标和参数。<br>由于绝大多数的语言模型都采用 MLM 或 ALM 进行训练，所以我们现如今所看到的大多数基于 Prompt 的分类都要设计 Template 和 Verbalizer。那么我们是否可以极大化地利用 MLM 和 ALM 的先验知识在不同的下游任务上获得更好的表现？是否可以设计一个全新的预训练任务来满足一些下游任务的需求呢？</p><p>我们介绍几个充分利用这个思想的方法：</p><ul><li>万物皆可生成：将所有任务统一为文本生成，极大化利用单向语言模型目标。</li><li>万物皆可抽取：将所有任务统一为抽取式阅读理解，并设计抽取式预训练目标。</li><li>万物皆可推理：将所有任务建模为自然语言推断（Natural Language Inference）或相似度匹配任务。</li></ul><h5 id="3-3-2-1-万物皆可生成-——-基于生成的-Prompt-范式统一"><a href="#3-3-2-1-万物皆可生成-——-基于生成的-Prompt-范式统一" class="headerlink" title="3.3.2.1 万物皆可生成 —— 基于生成的 Prompt 范式统一"></a>3.3.2.1 万物皆可生成 —— 基于生成的 Prompt 范式统一</h5><p>在含有单向 Transformer 的语言模型中（例如 GPT、BART），都包含自回归训练目标，即基于上一个 token 来预测当前的 token，而双向语言模型中的 MLM 可以视为只生成一个 token 的自回归模型，为此，我们则可以将分类任务视为一种特殊的文本生成，并配上 Verbalizer，这样，所有的 NLP 任务都可以统一为生成任务。针对不同的任务，只需要提供对应的指令和模板即可（由于是使用单向语言模型，因此没有 mask token，需要生成的部分置于文本末尾）。</p><p>下面给出几个事例：<br><img src="/images/%E6%A8%A1%E5%9E%8B%E7%B2%BE%E8%B0%83-4.png" alt="img"></p><h5 id="3-3-2-2-万物皆可抽取-——-基于抽取式阅读理解的-Prompt-范式统一"><a href="#3-3-2-2-万物皆可抽取-——-基于抽取式阅读理解的-Prompt-范式统一" class="headerlink" title="3.3.2.2 万物皆可抽取 —— 基于抽取式阅读理解的 Prompt 范式统一"></a>3.3.2.2 万物皆可抽取 —— 基于抽取式阅读理解的 Prompt 范式统一</h5><p>基于生成的方法存在如下缺点：</p><ul><li>必须让待生成的部分置于文本末尾，此时会约束指令和模板的设计，不利于灵活运用。</li><li>由于是开放式生成，生成的内容无法控制，且依赖于文本的长度等。</li><li>对于一些具有条件限制的任务，例如多项选择、信息抽取等，生成的内容或许不符合这些条件。例如在做实体抽取的时候，需要确保生成的实体是在文本中出现的。</li></ul><p>为此，“万物皆可抽取” 的思想可以解决此类问题，其思想指将所有自然语言理解任务转换为抽取式阅读理解的形式，下面给出形式化的定义：</p><p><img src="/images/%E6%A8%A1%E5%9E%8B%E7%B2%BE%E8%B0%83-5.png" alt="img"></p><p>除了抽取式阅读理解任务外，其他 NLP 任务如何转换为这个形式呢？本质上还是在如何设计模板和指令。<br>下面给出几个事例： </p><p><img src="/images/%E6%A8%A1%E5%9E%8B%E7%B2%BE%E8%B0%83-6.png" alt="img"></p><p>可以发现，如果是分类型的任务，只需要通过指令和模板的形式将所有类别罗列起来即可。在训练时，可以采用两种方法：</p><ul><li>设计抽取式预训练目标，在无标注语料上进行自监督训练。</li><li>按照阅读理解的形式统一所有任务范式，并混合所有任务进行 Cross-task Learning，再在新的任务上进行测试。</li></ul><h5 id="3-3-2-3-万物皆可推理-——-基于-NLI-的-Prompt-范式统一"><a href="#3-3-2-3-万物皆可推理-——-基于-NLI-的-Prompt-范式统一" class="headerlink" title="3.3.2.3 万物皆可推理 —— 基于 NLI 的 Prompt 范式统一"></a>3.3.2.3 万物皆可推理 —— 基于 NLI 的 Prompt 范式统一</h5><p>另外一个方法则是将所有任务建模为 NLI 形式，其与上文介绍的 MPT 比较类似，除了 MPT 以外，《Entailment as Few-Shot Learner》（EFL）和 NSP-BERT 也是类似的方法，其思想是复用 BERT 中的 Next Sentence Prediction（NSP）的预训练目标。下面给出几个事例：</p><p><img src="/images/%E6%A8%A1%E5%9E%8B%E7%B2%BE%E8%B0%83-7.png" alt="img"></p><h3 id="3-3-3-参数有效性学习"><a href="#3-3-3-参数有效性学习" class="headerlink" title="3.3.3 参数有效性学习"></a>3.3.3 参数有效性学习</h3><p>实现 Prompt-Tuning 只需要考虑如何设计模板或指令，而模型和训练目标则都是复用预训练阶段的，即在整个训练过程中，无须添加任何参数（或只需要添加非常少量的与模板有关的参数），而其他参数都是训练好的。基于这个思想，我们再一次将 Prompt 升华到更高的层面 ——Prompt 的本质是参数有效性学习（Parameter-Efficient Learning，PEL）。</p><ul><li>参数有效性学习的背景：在一般的计算资源条件下，大规模的模型（例如 GPT-3）很难再进行精调，因为所有的参数都需要计算梯度并进行更新，消耗时间和空间资源。为了解决这个问题，参数有效性学习被提出，其旨在确保模型效果不受太大影响的条件下尽可能地提高训练的时间和空间效率。</li><li>参数有效性训练：在参数有效性学习过程中，大模型中只需要指定或额外添加少量的可训练参数，而其余的参数全部冻结，这样可以大大提高模型的训练效率的同时，确保指标不会受到太大影响。</li></ul><h3 id="3-4-面向超大规模模型的-Prompt-Tuning"><a href="#3-4-面向超大规模模型的-Prompt-Tuning" class="headerlink" title="3.4 面向超大规模模型的 Prompt-Tuning"></a>3.4 面向超大规模模型的 Prompt-Tuning</h3><p>Prompt-Tuning 发展的过程中，有诸多工作发现，对于超过 10 亿参数量的模型来说，Prompt-Tuning 所带来的增益远远高于标准的 Fine-tuning，小样本甚至是零样本的性能也能够极大地被激发出来。</p><ul><li>得益于这些模型的参数量足够大</li><li>训练过程中使用了足够多的语料</li><li>同时设计的预训练任务足够有效</li></ul><p>下面介绍几个面向超大规模的 Prompt-Tuning 方法，分别为：</p><ul><li>上下文学习 In-Context Learning（ICL）：直接挑选少量的训练样本作为该任务的提示。</li><li>指令学习 Instruction-tuning：构建任务指令集，促使模型根据任务指令做出反馈。</li><li>思维链 Chain-of-Thought（CoT）：给予或激发模型具有推理和解释的信息，通过线性链式的模式指导模型生成合理的结果。详见：ICL、CoT、ToT、AutoGPT</li></ul><h4 id="3-4-1-In-Context-Learning（上下文学习）"><a href="#3-4-1-In-Context-Learning（上下文学习）" class="headerlink" title="3.4.1 In-Context Learning（上下文学习）"></a>3.4.1 In-Context Learning（上下文学习）</h4><p><img src="/images/%E6%A8%A1%E5%9E%8B%E7%B2%BE%E8%B0%83-8.png" alt="img"></p><p>目前，向语言模型通过 prompting 可以在小样本场景下得到很大的成功，例如 GPT-3。然而原始的语言模型在预训练时并没有针对 in-context 进行优化。<br>在 fine-tuning 阶段，给定一系列的训练任务，每一个任务都有相应的指令，并对应的少量样本（输入 &#x2F; 输出对）。在测试阶段，给定一个新的不可见任务，包含对应的指令和少量样本（输入 &#x2F; 输出对），旨在让模型能够对测试样本预测其类别。<br>如下图，给定一个情感分析任务：</p><p><img src="/images/%E6%A8%A1%E5%9E%8B%E7%B2%BE%E8%B0%83-9.png" alt="img"></p><h3 id="3-4-2-Instruction-tuning（指令学习）"><a href="#3-4-2-Instruction-tuning（指令学习）" class="headerlink" title="3.4.2 Instruction-tuning（指令学习）"></a>3.4.2 Instruction-tuning（指令学习）</h3><p>面向超大规模模型第二个 Prompt 技术是指令学习。Prompt 的本质之一是任务的一种指令，因此，在对大规模模型进行精调时，可以为各种类型的任务定义指令，并进行训练，来提高模型对不同任务的泛化能力。什么是指令呢？如下图所示：</p><p><img src="/images/%E6%A8%A1%E5%9E%8B%E7%B2%BE%E8%B0%83-10.png" alt="img"></p><p>假设是一个 Question Generation 任务，那么可以为这个任务定义一些指令：</p><ul><li>Title：任务的名称；</li><li>Definition：任务的定义，说明这个任务的本质和目的；</li><li>Things to avoid：说明这个任务的注意事项，例如需要避免什么等等；</li><li>Positive &#x2F; Negative Examples：给出正确和错误的例子，作为提示；</li><li>Prompt：当前任务的提示信息；</li></ul><p>当许多任务都按照这种模式定义好模板，让模型在指令化后的数据上进行精调，模型将可以学会如何看到指令做预测。</p><p>InstructionGPT：</p><blockquote><p>三个步骤：（1）监督微调（SFT），（2）奖励模型（RM）训练，以及（3）通过该奖励模型上的近端策略优化（PPO）进行强化学习</p></blockquote><p><img src="/images/%E6%A8%A1%E5%9E%8B%E7%B2%BE%E8%B0%83-11.png" alt="img"></p><h1 id="4-LoRA（Low-Rank-Adaptation）"><a href="#4-LoRA（Low-Rank-Adaptation）" class="headerlink" title="4. LoRA（Low-Rank Adaptation）"></a>4. LoRA（Low-Rank Adaptation）</h1><p>精调大规模语言模型到特殊领域和任务是自然语言处理的重要课题之一。但随着模型规模的不断扩大，精调模型的所有参数（所谓 full fine-tuning）的可行性变得越来越低。关于什么是 LoRA 可以参考原始论文。</p><h2 id="4-1-为何引入-LoRA"><a href="#4-1-为何引入-LoRA" class="headerlink" title="4.1 为何引入 LoRA"></a>4.1 为何引入 LoRA</h2><p>为解决精调大规模语言模型到不同领域和任务的挑战，如上文提到已有多种方案。但这些方法存在如下问题：</p><ul><li>Adapters 引入额外的推理延迟 (由于增加了模型层数)</li><li>Prefix-Tuning 难于训练，且预留给 prompt 的序列挤占了下游任务的输入序列空间，影响模型性能</li></ul><h3 id="4-1-1-Adapter-引入推理延迟"><a href="#4-1-1-Adapter-引入推理延迟" class="headerlink" title="4.1.1 Adapter 引入推理延迟"></a>4.1.1 Adapter 引入推理延迟</h3><p>显然，使用 Adapter 增加模型层数会增加推理的时长。<br>简单来说，adapter 就是固定原有的参数，并添加一些额外参数用于精调。Adapter 会在原始的 transformer block 中添加 2 个 adapter，一个在多头注意力后面，另一个这是 FFN 后面。显然，adapter 会在模型中添加额外的层，这些层会导致大模型在推理时需要更多的 GPU 通信，而且也会约束模型并行。这些问题都将导致模型推理变慢。</p><h3 id="4-1-2-很难直接优化-Prompt"><a href="#4-1-2-很难直接优化-Prompt" class="headerlink" title="4.1.2 很难直接优化 Prompt"></a>4.1.2 很难直接优化 Prompt</h3><p>prefix-tuning 方法是受语言模型 in-context learning 能力的启发，只要有合适的上下文则语言模型可以很好的解决自然语言任务。但是，针对特定的任务找到离散 token 的前缀需要花费很长时间，prefix-tuning 提出使用连续的 virtual token embedding 来替换离散 token。</p><p>具体来说，对于 transformer 中的每一层，都在句子表征前面插入可训练的 virtual token embedding。对于自回归模型（GPT 系列），在句子前添加连续前缀，prefix-tuning 并没有添加太多的额外参数。但是，prefix-tuning 难以优化，且会减少下游任务的序列长度，一定程度上会影响模型性能。 </p><h2 id="4-2-LoRA-的原理简介"><a href="#4-2-LoRA-的原理简介" class="headerlink" title="4.2 LoRA 的原理简介"></a>4.2 LoRA 的原理简介</h2><p>LoRA 本质是对大模型精调的一种方法，当预训练大模型很大时，重新训练所有模型参数的精调变得不可太行，例如 GPT3 的 175B。提出的 LoRA 采用低秩分解矩阵，冻结了预训练模型的权重，并将低秩分解矩阵注入到 transformer 的每一层，减少了训练参数量。</p><p><img src="/images/%E6%A8%A1%E5%9E%8B%E7%B2%BE%E8%B0%83-12.png" alt="img"></p><p>如上图所示们对于某个线性层而言，左边是模型原有的参数，在训练过程中是冻结不变的，右边是 LoRA 方法增加的低秩分解矩阵。<br>在原始 PLM 旁边增加一个旁路，做一个降维再升维的操作，来模拟所谓的 intrinsic rank。训练的时候固定 PLM 的参数，只训练降维矩阵 A 与升维矩阵 B。而模型的输入输出维度不变，输出时将 BA 与 PLM 的参数叠加。用随机高斯分布初始化 A，用 0 矩阵初始化 B，保证训练的开始此旁路矩阵依然是 0 矩阵。</p><p>训练过程中，优化器只优化右边这一部分的参数，两边的矩阵会共用一个模型的输入，分别进行计算，最后将两边的计算结果相加作为模块的输出。不同于之前的参数高效精调的 adapter：</p><ul><li>adapter 是在模块的后面接上一个 mlp，对模块的计算结果进行一个后处理。</li><li>LoRA 是和模块的计算并行的去做一个 mlp，和原来的模块共用一个输入。<br>大模型其实是过参数化的， 有更小的一个内在维度，大模型在任务适配（instruction-tune）过程中，参数的改变量是低秩的。</li></ul><p>总之，基于大模型的内在低秩特性，增加旁路矩阵来模拟全模型参数精调，LoRA 通过简单有效的方案来达成轻量精调的目的。 </p><p>引申一下，GPT 的本质是对训练数据的有效压缩，从而发现数据内部的逻辑与联系，LoRA 的思想与之有相通之处，原模型虽大，但起核心作用的参数是低秩的，通过增加旁路，达到事半功倍的效果。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LoRA：大语言模型的低阶自适应方法</title>
      <link href="/2023/08/08/LoRA%EF%BC%9A%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BD%8E%E9%98%B6%E8%87%AA%E9%80%82%E5%BA%94%E6%96%B9%E6%B3%95/"/>
      <url>/2023/08/08/LoRA%EF%BC%9A%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BD%8E%E9%98%B6%E8%87%AA%E9%80%82%E5%BA%94%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>神经网络包含很多全连接层，其借助于矩阵乘法得以实现，然而，很多全连接层的权重矩阵都是满秩的。当针对特定任务进行微调后，模型中权重矩阵其实具有很低的本征秩（intrinsic rank），因此，论文的作者认为权重更新的那部分参数矩阵尽管随机投影到较小的子空间，仍然可以有效的学习，可以理解为针对特定的下游任务这些权重矩阵就不要求满秩。</p><h2 id="2-技术原理"><a href="#2-技术原理" class="headerlink" title="2. 技术原理"></a>2. 技术原理</h2><p>LoRA方法的核心思想就是通过低秩分解来模拟参数的改变量，从而以极小的参数量来实现大模型的间接训练。<br>在涉及到矩阵相乘的模块，在原始的PLM旁边增加一个新的通路，通过前后两个矩阵A,B相乘，第一个矩阵A负责降维，第二个矩阵B负责升维，中间层维度为r，从而来模拟所谓的本征秩（intrinsic rank）。</p><p><img src="/images/lora-1.png" alt="img"></p><p>可训练层维度和预训练模型层维度一致为d，先将维度d通过全连接层降维至r，再从r通过全连接层映射回d维度，其中，r&lt;&lt;d，r是矩阵的秩，这样矩阵计算就从d x d变为d x r + r x d，参数量减少很多。</p><p><img src="/images/lora-2.png" alt="img"></p><p>在下游任务训练时，固定模型的其他参数，只优化新增的两个矩阵的权重参数，将PLM跟新增的通路两部分的结果加起来作为最终的结果（两边通路的输入跟输出维度是一致的），即h&#x3D;Wx+BAx。第一个矩阵的A的权重参数会通过高斯函数初始化，而第二个矩阵的B的权重参数则会初始化为零矩阵，这样能保证训练开始时新增的通路BA&#x3D;0从而对模型结果没有影响。</p><p><img src="/images/lora-3.png" alt="img"></p><p>在推理时，将左右两部分的结果加到一起即可，h&#x3D;Wx+BAx&#x3D;(W+BA)x，所以只要将训练完成的矩阵乘积BA跟原本的权重矩阵W加到一起作为新权重参数替换原本PLM的W即可，对于推理来说，不会增加额外的计算资源。</p><p>此外，Transformer的权重矩阵包括Attention模块里用于计算query, key, value的Wq，Wk，Wv以及多头attention的Wo,以及MLP层的权重矩阵，LoRA只应用于Attention模块中的4种权重矩阵，而且通过消融实验发现同时调整 Wq 和 Wv 会产生最佳结果。</p><p>实验还发现，保证权重矩阵的种类的数量比起增加隐藏层维度r更为重要，增加r并不一定能覆盖更加有意义的子空间。</p><p><img src="/images/lora-4.png" alt="img"></p><p>那么关于秩的选择，通常情况下，rank为4，8，16即可。</p><p><img src="/images/lora-5.png" alt="img"></p><p>通过实验也发现，在众多数据集上LoRA在只训练极少量参数的前提下，最终在性能上能和全量微调匹配，甚至在某些任务上优于全量微调。</p><h2 id="3-论文原文"><a href="#3-论文原文" class="headerlink" title="3. 论文原文"></a>3. 论文原文</h2><p><a href="/file/lora.pdf">lora.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2023/08/07/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/08/07/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">            quickSort(arr, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[right];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left; j &lt; right; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                swap(arr, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩散模型-图像生成的一大进步</title>
      <link href="/2023/08/03/%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B-%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90%E7%9A%84%E4%B8%80%E5%A4%A7%E8%BF%9B%E6%AD%A5/"/>
      <url>/2023/08/03/%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B-%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90%E7%9A%84%E4%B8%80%E5%A4%A7%E8%BF%9B%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2022年被誉为是AIGC元年，在这一年，随着文心一格、ChatGPT等消费级AI应用的诞生，原本普通人难以接触到的人工智能技术终于走进了千家万户，其中ChatGPT更是创造了短短3个月用户量破亿的惊人表现，成为了史上最快达到亿级用户的应用。关于ChatGPT背后的技术，随着文心一言即将问世，厂内已经有很多大神进行了分享。今天，我们来聊一聊文生图（text2img）这项AI技术背后的机器学习算法支撑—扩散模型，及其改进版本—稳定扩散模型。读完这篇文章，也希望大家可以动动手，在实践中打造一款属于自己的AI应用~</p></blockquote><h2 id="生成式模型"><a href="#生成式模型" class="headerlink" title="生成式模型"></a>生成式模型</h2><p>扩散模型属于一个名叫「生成式模型」（Generative Models）的机器学习模型大家族，这个大家族里人员众多，细分成很多派别，有的擅长生成图像和声音，有的擅长生成代码片段。它们的分类也多种多样，比如按照学习方式分，可以分为有监督督学习模型的和无监督学习模型；按照模型结构分，可以分为基于概率的模型和基于神经网络的模型。常见的生成式模型包括生成对抗网络（GANs）、变分自编码器（VAEs）、扩散模型（DMs）等，广泛应用于图像生成、文本生成、语音合成等领域。</p><p><img src="/images/diffusion-1.png" alt="img"><br>它们的原理及区别如上图所示，以下对这几种生成式模型进行一个简单的介绍：</p><ul><li>生成对抗网络模型（GANs）是一种基于采样的生成式模型，由两个神经网络组成：一个是生成器（Generator），一个是判别器（Discriminator）。生成器的目标是从随机噪声中生成与真实数据相似的数据，判别器的目标是区分输入的数据是真实的还是生成的。两个网络相互博弈，不断提高自己的能力，最终达到一个平衡点，使得判别器无法区分真假数据。这种模型训练不稳定，多样性较少。</li><li>变量自动编码器模型（VAEs）是一种基于概率的生成式模型，它由一个编码器（Encoder）和一个解码器（Decoder）组成。编码器将输入数据映射为一个低维的潜在空间，这个空间通常是一个多元高斯分布，编码器的输出是这个分布的均值和方差。解码器将从潜在空间采样的随机向量重构为与输入数据相似的数据。变分自编码器通过最大化数据的边缘对数似然来训练，同时也最小化了输入数据和重构数据之间的差异。</li><li>扩散模型（DMs）是一种基于采样的生成式模型，它通过不断向数据添加噪声，使数据从原始分布变为简单分布，例如正态分布。然后，它通过学习一个逆扩散过程，从噪声中恢复出原始数据。</li></ul><p>用一句话简单概括，生成式模型是一类能够根据已有数据的分布情况，生成新的数据的统计模型。</p><h2 id="扩散模型"><a href="#扩散模型" class="headerlink" title="扩散模型"></a>扩散模型</h2><p>扩散模型是「生成式模型」算法家族的新成员。上一节我们已经简单介绍过几种生成式模型，这些模型通过学习给定的训练样本，可以学会如何生成数据，比如生成图片或者声音。它们的显著特点是，能生成一组样式不同的输出，这些输出与训练数据非常相似，但不是一模一样，更像是不同样本的组合。扩散模型是如何实现这一点的呢？让我们通过下方的图示，简单了解下通过扩散模型训练的过程：</p><p><img src="/images/diffusion-2.png" alt="img"></p><p>可以看到，通过不断向样本数据添加噪声，使数据从原始分布变为简单分布（如高斯分布）。然后进行逆扩散过程，通过多次迭代采样进行去噪，从简单分布中恢复出原始数据。<br>与GANs等模型相比，扩散模型的优点如下：</p><ul><li>可以生成高质量的图片，清晰度比其他生成式模型高</li><li>可以很容易地加入类别条件或文本条件</li><li>因为是用固定的程序学习的，而且隐变量具有高维度（与原始数据相同），这使得模型具有更好的可解释性</li></ul><p>但同时，使用该模型时因为有一个迭代采样的过程，导致模型训练和预测效率低，训练和推演成本高昂。这使得用户在使用时，在多样性和定制化上仍具有很大局限性。</p><p>目前已经有很多成熟的开源项目，可以让用户基于扩散模型进行训练，如美国抱抱脸公司开源的diffusers项目：<br><a href="https://github.com/huggingface/diffusers">https://github.com/huggingface/diffusers</a><br>该项目不但提供了预训练、亿级别样本的模型库，而且提供了可视化界面及用于模型训练的工具包。</p><h2 id="潜在扩散模型和稳定扩散模型"><a href="#潜在扩散模型和稳定扩散模型" class="headerlink" title="潜在扩散模型和稳定扩散模型"></a>潜在扩散模型和稳定扩散模型</h2><p>基于扩散模型存在的一些问题，Robin Rombach, Andreas Blattmann, Dominik Lorenz, Patrick Esser 和 Björn Ommer五位学者发表了名为「High-Resolution Image Synthesis with Latent Diffusion Models」的论文，提出了潜在扩散模型（Latent Diffusion Models）。</p><p> <img src="/images/diffusion-3.png" alt="img"></p><p><strong>潜在扩散模型（LDMs）</strong>在原始扩散模型的基础上进行了优化，引入低维潜在变量，可以在低维潜在空间中对图像进行编码和解码，从而提高生成质量和效率。潜在扩散模型的优点有：</p><ul><li>在复杂性降低和细节保留之间达到一个接近最优的点，极大地提高了视觉保真度</li><li>可以将扩散模型转化为强大而灵活的生成器，用于文本或边界框等一般条件反射输入，并以卷积方式实现高分辨率合成</li><li>与基于像素的扩散模型相比，显著减少了计算需求</li></ul><p><strong>稳定扩散模型（SDMs）</strong>是基于LDMs改进的扩散模型，它通过使用一个固定的噪声方差序列，使得每个扩散步骤都能保持数据的语义结构。提出该模型的CompVis研究组基于LDMs进行了扩大训练，在Laion-5B数据子集上使用了超大规模的约25 亿「文本 - 图像对」进行训练，取得了非常显著的效果。<br>基于稳定扩散模型的文生图原理如下图所示：</p><p> <img src="/images/diffusion-4.png" alt="img"></p><p>上述流程不难理解：我们输入文本提示，即「宇航员骑马」，Frozen CLIP Text Encoder组件对文本进行编码后，将文本embeddings传递给扩散模型，该模型将随机噪声添加到图像中，利用这些信息训练文本&#x2F;图像编码器。然后，编码器经过N次迭代，在图像块上添加更多的噪声。最后，Variational Autoencoders组件猜测文本和图像的哪个组合最能代表初始的文本提示。然后输出最佳匹配的图像。</p><p>这其中有一个很重要的组件叫做Frozen CLIP Text Encoder，它是一个基于「CLIP ViT-L&#x2F;14」神经网络的文本编码器。由于它的存在，稳定扩散模型具备了基于User Prompt生成图像的能力。CLIP本质上是一个预训练的「文本-图像对」神经网络。下图是CLIP训练的第一步，将N张图片的自然语言文字描述作为一个输入，图片本身作为另一个输入，对应的「文本-图像对」（N个）作为正激励，不对应的「文本-图像对」（N^2-N个）作为负激励，进行训练。CLIP详细的训练过程大家有兴趣可以深入研究，在此不再赘述。</p><p>稳定扩散模型作为一种深度学习文生图模型，有如下优点：</p><ul><li>可以生成更高质量和更多样化的图像</li><li>不会受到模式崩溃的影响，即不会生成重复或无意义的图像</li><li>可以与其他生成式模型（如GANs或VAEs）结合，提高生成效率和性能</li><li>可以在消费级 GPU 上的 10 GB VRAM 下运行，并在几秒钟内生成 512x512 像素的图像，无需预处理和后处理</li></ul><p>该模型已经在github上开源：<br><a href="https://github.com/CompVis/stable-diffusion">https://github.com/CompVis/stable-diffusion</a></p><p>为了进一步降低使用这一模型的门槛，诞生了很多开源项目为SDMs提供更符合普通用户使用的Web UI界面，简单来说就是对底层技术进行了封装，用户不再需要输入命令行，而是通过可视化界面去进行操作。比如由用户推出的AUTOMATIC1111版Web UI：<br><a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui">https://github.com/AUTOMATIC1111/stable-diffusion-webui</a></p><p>但是使用这一项目仍然需要具备一定的计算机编程基础。对于真正零算法基础的用户来说，即使能够通过可视化界面进行操作，前期安装python环境和各种库还是会有一定门槛。所以基于stable-diffusion-webui又诞生了各种插件和扩展，使用户可以在谷歌浏览器、Photoshop甚至PS5游戏机上通过远程调用的方式使用文生图进行创作。尤其是支持在Photoshop上进行图像生成并进行二次创作，能够切实提升设计师的生产力。总的来说，这项AI技术目前已经非常接近AI普惠的概念了。</p><h2 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h2><p>可以预期的是，Stable Diffusion绝不会止步于文生图、图生图领域，今明年可能就会进入短视频领域。随着未来算力的进一步解放，三维动画、建筑设计领域也将很快看到这一模型的身影。</p><p>内容创作是一个万亿级的市场，在很多人还对AIGC这一概念不甚了解的时候，一些敏锐的人已经开始尝试通过AIGC进行商业变现了，在AI的协助下交付广告创意、插画设计等，甚至出各种关于AI辅助创作的付费课程。不论你是设计师还是热爱创作的普通用户，相信今天介绍的这项AI技术都会给我们的工作带来很大助力，激发我们的创意（当然最终也可能会替代设计类工作-_-）</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stable Diffusion </tag>
            
            <tag> AIGC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构师谈技术影响力</title>
      <link href="/2023/08/02/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%B0%88%E6%8A%80%E6%9C%AF%E5%BD%B1%E5%93%8D%E5%8A%9B/"/>
      <url>/2023/08/02/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%B0%88%E6%8A%80%E6%9C%AF%E5%BD%B1%E5%93%8D%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下内容来自百度杰出架构师的内部分享</p></blockquote><h2 id="1-如何理解技术影响力"><a href="#1-如何理解技术影响力" class="headerlink" title="1. 如何理解技术影响力"></a>1. 如何理解技术影响力</h2><p>技术影响力可以理解为是我们工程师个人画像的一部分，是一种“品牌形象”。</p><p>技术影响力不仅仅是针对体现在公司外部的，也体现在内部。以及，它不需要我们到达一定的级别、辐射到很大的工作范围才应该去打造，它应该是贯穿我们的职业生涯的。技术影响力小可以体现在自己的team、大可以体现到 BU、公司、行业，在不同的职业发展阶段，都可以提升技术影响力。</p><p>我们经常讲——把自己的职业发展和人生轨迹当做一家公司去经营，我们要有经营技术影响力的意识，有了意识就会有可落地的方法，就要下功夫去打磨。</p><h2 id="2-如何有意识地培养技术影响力"><a href="#2-如何有意识地培养技术影响力" class="headerlink" title="2. 如何有意识地培养技术影响力"></a>2. 如何有意识地培养技术影响力</h2><p>要从小事做起，不轻易放过任何一次机会。</p><p>比如，新入职的时候，做一次认真、逻辑清晰的串讲。“你是我这么长时间以来见过的在这个模块里讲的最好的”，那这是一个漂亮的串讲，那技术影响力就潜移默化地被你打造了。</p><p>比如，积极在团队或公司内部做技术分享，在BIT授课，在社区、在行业大会做分享。针对这一点，你是否愿意去分享、能否把分享的知识讲的清晰透彻是很重要的，这个能力也是通过不断的实践锻炼出来的。</p><p>再比如，现在自媒体如火如荼，在内部知识库、内部“术说”栏目、外部公众号等输出一些干货文章。不仅对自己掌握技术知识有很大的帮助，个人技术影响力自然而然就积累起来了。</p><p>当然，打造技术影响力需要持续去做，不能急于求成、功利化。</p><p>关于技术分享，在这里想额外和大家聊两点好处：</p><p>1、技术分享有助于自己打造“内功”。掌握一项知识或技术，最高境界是把别人教会。对于工程师自己来说，透彻地掌握一项技术，是需要把知识结构化地整理出来并分享。学了——学了并整理——学了后整理并分享给别人，这是一个逐渐深入透彻的过程。</p><p>2、技术分享会潜移默化地提升个人技术影响力，并有助于后续团队协同。团队内部、团队和团队、部门之间经常会有协作，技术影响力的加持会在一定程度上让你更加容易地推动和落地事情。当然，这并不是说绝对的，前提是你的分享让对方觉得你确实很有多积累、心得和体会。</p><h2 id="3-打造技术影响力地渠道和方法"><a href="#3-打造技术影响力地渠道和方法" class="headerlink" title="3. 打造技术影响力地渠道和方法"></a>3. 打造技术影响力地渠道和方法</h2><p>打造技术影响力的渠道基本都在工作的环节中，不要轻易放弃任何一个机会。比如串讲、项目方案的评审、给 peer 团队分享技术设计、内部分享、项目汇报、到BIT讲授课程等，等积累到一定程度，还可以去报名行业大会。</p><p>我曾经也是这样走过来的，在工作五六年的时候，第一次报名参加了行业大会。只要进去那个大会的圈子，讲过几次后，以后自然就会有人在各种渠道邀请你继续分享。行业大会的官网每次会公开招募讲师，我的 mentor 之前在大会上分享过，考虑到技术话题比较新鲜，自己也有一些积累，想去跟同行去做交流和分享，所以当时我就通过邮件报了名，注明讲的内容和观众收益等。</p><p>早些年的发声渠道少，大会就那么几个，现在行业大会也多了，不管是文章还是演讲的渠道都会变多，就看你有没有这个意识去做。其实相比外部，内部是很好的机会。在内部锻炼后有了积累，对内容、流畅度、会场的把握就会不一样。没有人可以第一次就会讲好，要多锻炼、多积累。</p><h2 id="4-打造技术影响力需要具备哪些能力"><a href="#4-打造技术影响力需要具备哪些能力" class="headerlink" title="4. 打造技术影响力需要具备哪些能力"></a>4. 打造技术影响力需要具备哪些能力</h2><p>首先，要保有对技术有好奇心，有追根到底的精神，不能浅尝辄止。要把每个技术点研究的清晰透彻，做技术的积累。</p><p>其次，培养逻辑思维能力。比如做分享，要把这个分享议题的背景、来龙去脉、走向等思考清楚，提炼核心点，并能向别人快速清晰、有逻辑地讲明白。这里面还是有很多讲究，不同的受众（团队内、合作方、老板等）、不同的分享形式（文章、课程、分享等）和不同输出渠道，都会有一些差异。要多总结提炼，多实践，同时也推荐大家去读一读类似《金字塔原理》这些锻炼结构化思维能力的书。</p><p>最后，要有主动做知识沉淀和分享的意识。这里不是说一定要分享多少次，毕竟我们不是说让大家都变成布道师，而是要把握问题的本质，讲的有内容、有深度。</p><p>工程师不仅仅是要把代码写好，还要对技术有追求、对成长有方向、对机会要珍惜，那技术影响力的提升就不是难事。希望本篇文章，能够解答你关于技术影响力的一些困惑，重视并行动起来吧！</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习模型评价指标</title>
      <link href="/2023/07/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
      <url>/2023/07/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>机器学习问题之中，通常需要建立模型来解决具体问题，但对于模型的好坏，也就是模型的泛化能力，如何进行评估呢？<br>很简单，我们可以定一些评价指标，来度量模型的优劣。比如准确率、精确率、召回率、F1值、ROC、AUC等指标，但是你清楚这些指标的具体含义吗？下面我们一起来看看吧。</p></blockquote><h2 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h2><p>介绍各个指标之前，我们先来了解一下混淆矩阵。假如现在有一个二分类问题，那么预测结果和实际结果两两结合会出现如下四种情况：TP、FP、FN、TN<br>其中，T(True)代表正确、F(False)代表错误、P(Positive)代表1、N(Negative)代表0<br>TP：预测为1，实际为1，预测正确。<br>FP：预测为1，实际为0，预测错误。<br>FN：预测为0，实际为1，预测错误。<br>TN：预测为0，实际为0，预测正确。</p><h2 id="准确率"><a href="#准确率" class="headerlink" title="准确率"></a>准确率</h2><p>首先给出 <strong>准确率(Accuracy)</strong> 的定义，即预测正确的结果占总样本的百分比，表达式为 <strong>(TP+TN)&#x2F;(TP+TN+FP+FN)</strong></p><p>虽然准确率能够判断总的正确率，但是在样本不均衡的情况下，并不能作为很好的指标来衡量结果。</p><p>比如在样本集中，正样本有90个，负样本有10个，样本是严重的不均衡。对于这种情况，我们只需要将全部样本预测为正样本，就能得到90%的准确率，但是完全没有意义。对于新数据，完全体现不出准确率。因此，在样本不平衡的情况下，得到的高准确率没有任何意义，此时准确率就会失效。所以，我们需要寻找新的指标来评价模型的优劣。</p><h2 id="精确率"><a href="#精确率" class="headerlink" title="精确率"></a>精确率</h2><p><strong>精确率(Precision)</strong> 是针对预测结果而言的，其含义是在被所有预测为正的样本中实际为正样本的概率，表达式为 <strong>TP&#x2F;(TP+FP)</strong></p><p>精确率和准确率看上去有些类似，但是是两个完全不同的概念。精确率代表对正样本结果中的预测准确程度，准确率则代表整体的预测准确程度，包括正样本和负样本。</p><h2 id="召回率"><a href="#召回率" class="headerlink" title="召回率"></a>召回率</h2><p><strong>召回率(Recall)</strong> 是针对原样本而言的，其含义是在实际为正的样本中被预测为正样本的概率，表达式为 <strong>TP&#x2F;(TP+FN)</strong></p><p>下面我们通过一个简单例子来看看精确率和召回率。假设一共有10篇文章，里面4篇是你要找的。根据你的算法模型，你找到了5篇，但实际上在这5篇之中，只有3篇是你真正要找的。</p><p>那么算法的精确率是3&#x2F;5&#x3D;60%，也就是你找的这5篇，有3篇是真正对的。算法的召回率是3&#x2F;4&#x3D;75%，也就是需要找的4篇文章，你找到了其中三篇。以精确率还是以召回率作为评价指标，需要根据具体问题而定。</p><h2 id="F1分数"><a href="#F1分数" class="headerlink" title="F1分数"></a>F1分数</h2><p>精确率和召回率又被叫做查准率和查全率，可以通过P-R图进行表示。</p><p>如何理解P-R(精确率-召回率)曲线呢？或者说这些曲线是根据什么变化呢？</p><p>以逻辑回归举例，其输出值是0-1之间的数字。因此，如果我们想要判断用户的好坏，那么就必须定一个阈值。比如大于0.5指定为好用户，小于0.5指定为坏用户，然后就可以得到相应的精确率和召回率。但问题是，这个阈值是我们随便定义的，并不知道这个阈值是否符合我们的要求。因此为了寻找一个合适的阈值，我们就需要遍历0-1之间所有的阈值，而每个阈值都对应一个精确率和召回率，从而就能够得到上述曲线。</p><p>根据上述的P-R曲线，怎么判断最好的阈值点呢？首先我们先明确目标，我们希望精确率和召回率都很高，但实际上是矛盾的，上述两个指标是矛盾体，无法做到双高。因此，选择合适的阈值点，就需要根据实际问题需求，比如我们想要很高的精确率，就要牺牲掉一些召回率。想要得到很高的召回率，就要牺牲掉一些精准率。但通常情况下，我们可以根据他们之间的平衡点，定义一个新的指标：F1分数(F1-Score)。F1分数同时考虑精确率和召回率，让两者同时达到最高，取得平衡。F1分数表达式为 (2 * 精确率 * 召回率)&#x2F;(精确率+召回率)<br>上图P-R曲线中，平衡点就是F1值的分数。</p><p>F1值是精确率和召回率的调和均值，相当于精确率和召回率的综合评价指标</p><h2 id="ROC、AUC"><a href="#ROC、AUC" class="headerlink" title="ROC、AUC"></a>ROC、AUC</h2><p>正式介绍ROC和AUC之前，还需要再介绍两个指标，<strong>真正率(TPR)</strong> 和 <strong>假正率(FPR)</strong> 。</p><p><strong>真正率(TPR)</strong> &#x3D; <strong>灵敏度(Sensitivity)</strong> &#x3D; <strong>TP&#x2F;(TP+FN)</strong><br><strong>假正率(FPR)</strong> &#x3D; <strong>1-特异度(Specificity)</strong> &#x3D; <strong>FP&#x2F;(FP+TN)</strong></p><p>TPR和FPR分别是基于实际表现1、0出发的，也就是说在实际的正样本和负样本中来观察相关概率问题。因此，无论样本是否均衡，都不会被影响。</p><p>继续用上面例子，总样本中有90%的正样本，10%的负样本。TPR能够得到90%正样本中有多少是被真正覆盖的，而与那10%无关。同理FPR能够得到10%负样本中有多少是被覆盖的，而与那90%无关。因此我们从实际表现的各个结果出发，就能避免样本不平衡的问题，这就是为什么用TPR和FPR作为ROC、AUC指标的原因。</p><p>ROC曲线图横坐标为 <strong>假正率(FPR)</strong> ，纵坐标为 <strong>真正率(TPR)</strong> 。</p><p>与前面的P-R曲线类似，ROC曲线也是通过遍历所有阈值来绘制曲线的。如果我们不断的遍历所有阈值，预测的正样本和负样本是在不断变化的，相应的ROC曲线TPR和FPR也会沿着曲线滑动。</p><p>同时，我们也会思考，如何判断ROC曲线的好坏呢？我们来看，FPR表示模型虚报的程度，TPR表示模型预测覆盖的程度。理所当然的，我们希望虚报的越少越好，覆盖的越多越好。所以TPR越高，同时FPR越低，也就是ROC曲线越陡，那么模型的性能也就越好。</p><p>最后，我们来看一下，不论样本比例如何改变，ROC曲线都没有影响，也就是ROC曲线无视样本间的不平衡问题。</p><p><strong>AUC(Area Under Curve)</strong> 表示ROC中曲线下的面积，用于判断模型的优劣。如ROC曲线所示，连接对角线的面积刚好是0.5，对角线的含义也就是随机判断预测结果，正负样本覆盖应该都是50%。另外，ROC曲线越陡越好，所以理想值是1，即正方形。所以AUC的值一般是介于0.5和1之间的。AUC评判标准可参考如下</p><p>0.5-0.7：效果较低<br>0.7-0.85：效果一般<br>0.85-0.95：效果很好<br>0.95-1：效果非常好</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink Checkpoint 机制</title>
      <link href="/2023/06/30/Flink%20Checkpoint%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/06/30/Flink%20Checkpoint%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="checkpoint-的过程包含了-JobManager-和-Taskmanager-端-task-的执行过程，按照步骤为："><a href="#checkpoint-的过程包含了-JobManager-和-Taskmanager-端-task-的执行过程，按照步骤为：" class="headerlink" title="checkpoint 的过程包含了 JobManager 和 Taskmanager 端 task 的执行过程，按照步骤为："></a>checkpoint 的过程包含了 JobManager 和 Taskmanager 端 task 的执行过程，按照步骤为：</h2><ol><li><p>在 JobManager 端构建 ExecutionGraph 过程中会创建 CheckpointCoordinator，这是负责 checkpoint 的核心实现类，同时会给 job 添加一个监听器 CheckpointCoordinatorDeActivator（只有设置了 checkpoint 才会注册这个监听器），在 JobManager 端开始进行任务调度的时候，会对 job 的状态进行转换，由 CREATED 转成 RUNNING，job 监听器 CheckpointCoordinatorDeActivator 就开始启动 checkpoint 的定时任务了，最终会调用 CheckpointCoordinator.startCheckpointScheduler ()</p></li><li><p>CheckpointCoordinator 会部署一个定时任务，用于周期性的触发 checkpoint，这个定时任务就是 ScheduledTrigger，在触发 checkpoint 之前先做一遍检查，检查当前正在处理的 checkpoint 是否超过设置的最大并发 checkpoint 数量，检查 checkpoint 的间隔是否达到设置的两次 checkpoint 的时间间隔，在都没有问题的情况下向所有的 source task 去触发 checkpoint，远程调用 TaskManager 的 triggerCheckpoint () 方法</p></li><li><p>TaskManager 的 triggerCheckpoint () 方法首先获取到 source task（即 SourceStreamTask），调用 Task.triggerCheckpointBarrier ()，triggerCheckpointBarrier () 会异步的去执行一个独立线程，这个线程来负责 source task 的 checkpoint 执行。checkpoint 的核心实现在 StreamTask.performCheckpoint () 方法中，该方法主要有三个步骤：</p><ol><li>在 checkpoint 之前做一些准备工作，通常情况下 operator 在这个阶段是不做什么操作的</li><li>立即向下游广播 CheckpointBarrier，以便使下游的 task 能够及时的接收到 CheckpointBarrier 也开始进行 checkpoint 的操作</li><li>开始进行状态的快照，即 checkpoint 操作。<br> 注意以上操作都是在同步代码块里进行的，获取到的这个 lock 锁就是用于 checkpoint 的锁，checkpoint 线程和 task 任务线程用的是同一把锁，在进行 performCheckpoint () 时，task 任务线程是不能够进行数据处理的</li></ol></li><li><p>checkpoint 的执行过程是一个异步的过程，保证不能因为 checkpoint 而影响了正常数据流的处理。StreamTask 里的每个 operator 都会创建一个 OperatorSnapshotFutures，OperatorSnapshotFutures 里包含了执行 operator 状态 checkpoint 的 FutureTask，然后由另一个单独的线程异步的来执行这些 operator 的实际 checkpoint 操作，就是执行这些 FutureTask。这个异步线程叫做 AsyncCheckpointRunnable，checkpoint 的执行就是将状态数据推送到远程的存储介质中</p></li><li><p>对于非 Source Task，checkpoint 的标志性开始在接收到上游的 CheckpointBarrier，方法在 StreamTask 中的 CheckpointBarrierHandler.getNextNonBlocked ()。CheckpointBarrierHandler 会根据 CheckpointingMode 模式不同生成不同的 Handler，如果是 EXACTLY_ONCE，就会生成 BarrierBuffer，会进行 barrier 对齐，保证数据的一致性，BarrierBuffer 中的 CachedBufferBlocker 是用来缓存 barrier 对齐时从被阻塞 channel 接收到的数据。如果 CheckpointingMode 是 AT_LEAST_ONCE，那就会生成 BarrierTracker，不会进行 barrier 对齐，而是继续处理数据，在接收到上游 task 所有的 CheckpointBarrier 才开始进程 checkpoint，这样就会 checkpoint (n) 的状态会包含 checkpoint (n+1) 的数据，数据不一致。非 Source Task 的 checkpoint 执行跟步骤 3、4 是一样的，只不过触发的线程是 Task 工作线程，跟 source task 不一样</p></li><li><p>Task 在执行完 checkpoint 后会向 JobManager 上报 checkpoint 的元数据信息，JobManager 端的 CheckpointCoordinator 会调用 PendingCheckpoint.acknowledgeTask () 方法，该方法就是将 task 上报的元数据信息（checkpoint 的路径地址，状态数据大小等等）添加到 PendingCheckpoint 里</p></li><li><p>task 的 checkpoint 会一直进行到 sink task。JobManager 如果接收到了全部 task 上报的的 Ack 消息，就执行 completePendingCheckpoint ()，会将 checkpoint 元数据信息进行持久化，然后通知所有的 task 进行 commit 操作，一般来说，task 的 commit 操作其实不需要做什么，但是像那种 TwoPhaseCommitSinkFunction，比如 FlinkKafkaProducer 就会进行一些事物的提交操作等，或者像 FlinkKafkaConsumer 会进行 offset 的提交</p></li><li><p>所有 task 执行完 commit 操作后（实际上执行的是 operator.notifyCheckpointComplete () 方法），一个完整的 checkpoint 流程就完成了</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术规划50问</title>
      <link href="/2023/06/30/%E6%8A%80%E6%9C%AF%E8%A7%84%E5%88%9250%E9%97%AE/"/>
      <url>/2023/06/30/%E6%8A%80%E6%9C%AF%E8%A7%84%E5%88%9250%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/tag-bg.jpg" alt="img"></p><ol><li>如何调整技术方向如何平衡技术开发和业务交付精力？</li><li>技术规划应该包括哪些内容？</li><li>   如何做一个业务上能落地而且会落地，而不是高高在上的技术规划</li><li>   技术预研的舍与得如何去平衡（效率&amp;成本&amp;其他等等），开源以及自研技术，有哪些倾向性选择？</li><li>   技术规划如何更能接地气，可持续？</li><li>   技术规划有没有好的方法论或者最佳实践？</li><li>   如何推动技术规划真正落地，实现价值</li><li>   技术规划的出发点是什么？与产品规划如何同步？</li><li>如何合理的制定短期规划和长期规划？</li><li>技术规划如何能做到业界领先，如何能让高层信服，如何能保证高质量落地？</li><li>技术规划有什么机制保障尽可能的落地？</li><li>如何结合业界趋势，做出贴合业务带来收益的实际产品？这中间有没有什么方法论？</li><li>如何看到领域内远期的（3-5）年的技术&#x2F;产品趋势，如何评估是否靠谱&#x2F;能否落地&#x2F;能否产生收益？</li><li>如何让技术规划获得更广泛的支持认可；没有业务，即需要自己拓展业务时，如何做技术规划</li><li>一个优秀技术规划的产出流程一般是什么样子的</li><li>在技术规划中遇到自己不擅长的领域如何规划处理</li><li>如何避免过度设计；如何权衡长短期规划</li><li>越实际的问题就有越明确的技术方案，而技术规划要面临下一个周期提前布局，其中的潜在逻辑是什么。</li><li>技术规划的落地执行往往由于实际需求&#x2F;方向变化会产生变形，如何快速调整，说明意义。</li><li>技术的先进性和成熟度怎么平衡？</li><li>方法论上的东西都知道，但是真正做技术规划的时候，一些长期有价值的技术方向还是很难想出来，这个时候如何办？</li><li>技术规划中，如何加强跨BUBG的协同合作</li><li>技术规划中技术驱动的项目如何与业务发展与指标相匹配，落地节奏怎么安排</li><li>技术方向调整，技术与管理如何选择</li><li>业务成长出现困境，如何更好的突破困境，逆境中发现机会点</li><li>学海无涯，技术精进的道路没有止境，如何平衡工作学习和生活？</li><li>如何兼具技术架构与技术细节把我能力，同时具备产品化的思维方式？</li><li>如何让自己的技术架构能力 cover bg 级别或者一个中小厂的技术团队（目标）</li><li>面临层出不穷的一线新技术问题，关于架构师在保持技术敏感度方面该如何做？</li><li>如何在有限的资源下，增强团队凝聚力和战斗力？</li><li>小组各个同学技术方向不同，如何对其产出进行横向评比？</li><li>如何在日常繁杂的业务中脱身而出，拓展出具有影响力的技术？</li><li>最为技术人员一般都在讲”T”字型发展模式，如何选定一个有价值高回报的方向去深入了解</li><li>技术日行千里，如何保持个人进步的节奏</li><li>以架构师为个人成长目标，如何系统性的制订个人学习计划？平时需关注哪些提升的途径？</li><li>架构师和具体实现间怎么平衡？架构师是否必须要承担部分PM的职责？</li><li>偏后端的基础工程架构，如何能更主动的帮助到业务的发展，以及在业务sense上如何得到成长？</li><li>停留在T7&#x2F;T8级别，难于跨越的这条洪沟是什么？如何跨过呢？</li><li>如何拓宽知识的广度，如果没有实战经验，纯看书看论文理解应该不够深刻</li><li>技术规划的目标定义了，但是找路径的时候不知道怎么做？</li><li>如何设计一个高可用高可扩展的架构？如何能够控制系统复杂度？</li><li>如何结合现有业务做长期三年规划架构师如何在人力紧张或者没有人力的时候快速落地技术规划</li><li>架构师是一个技术岗位，我一直是技术驱动在做人做事。但与其说架构师是在管理技术，不如说是在管理人。管理团队的人与管理团队中的技术，我想明确这是不是两种不同的管理风格，应该如何侧重？</li><li>技术迭代速度快，架构师的视野是否会限制团队的技术演进；是需要架构师时刻紧跟各领域技术趋势，还是可以有机制保证业务技术先进性</li><li>工作中涉及到的业务功能较多时，作为架构师该如何找到技术能力与业务能力之间的平衡点</li><li>如何在涉及到广度的时候，保持敏锐的技术判断力如何能更快速有效的提升自己，抓大放小，以便于进一步优化工作效率。想听听过来人的经验</li><li>T9需要什么标准</li><li>技术规划的长短期价值怎么权衡，比如在人力时间资源上的分配？</li><li>项目复盘怎么做才能更好的帮助技术规划调整？</li><li>作为一个技术leader，如何帮助团队去判断产品方向？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink SQL TOP-N</title>
      <link href="/2022/12/04/Flink%20SQL%20TOP-N/"/>
      <url>/2022/12/04/Flink%20SQL%20TOP-N/</url>
      
        <content type="html"><![CDATA[<h2 id="1-创建-Source"><a href="#1-创建-Source" class="headerlink" title="1. 创建 Source"></a>1. 创建 Source</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `kafka_json_source_table` (</span><br><span class="line">  user_id        <span class="type">INT</span>,</span><br><span class="line">  item_id        <span class="type">INT</span>,</span><br><span class="line">  category_id    <span class="type">INT</span>,</span><br><span class="line">  user_behavior  <span class="type">VARCHAR</span>,</span><br><span class="line">  time_stamp     <span class="type">TIMESTAMP</span>(<span class="number">3</span>),</span><br><span class="line">  WATERMARK <span class="keyword">FOR</span> time_stamp <span class="keyword">AS</span> time_stamp <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="string">&#x27;3&#x27;</span> <span class="keyword">SECOND</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">  <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;kafka&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;topic&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;oceanus_advanced4_input&#x27;</span>,    <span class="comment">-- 替换为您要消费的 Topic</span></span><br><span class="line">  <span class="string">&#x27;scan.startup.mode&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;latest-offset&#x27;</span>, <span class="comment">-- 可以是 latest-offset / earliest-offset / specific-offsets / group-offsets / timestamp 的任何一种</span></span><br><span class="line">  <span class="string">&#x27;properties.bootstrap.servers&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;10.0.0.29:9092&#x27;</span>,  <span class="comment">-- 替换为您的 Kafka 连接地址</span></span><br><span class="line">  <span class="string">&#x27;properties.group.id&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;testGroup&#x27;</span>,     <span class="comment">-- 必选参数, 一定要指定 Group ID</span></span><br><span class="line">  <span class="string">&#x27;format&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;json.fail-on-missing-field&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;false&#x27;</span>,  <span class="comment">-- 如果设置为 false, 则遇到缺失字段不会报错。</span></span><br><span class="line">  <span class="string">&#x27;json.ignore-parse-errors&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;true&#x27;</span>      <span class="comment">-- 如果设置为 true，则忽略任何解析报错。</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="2-创建-Sink"><a href="#2-创建-Sink" class="headerlink" title="2. 创建 Sink"></a>2. 创建 Sink</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `jdbc_upsert_sink_table` (</span><br><span class="line">    win_start     <span class="type">TIMESTAMP</span>(<span class="number">3</span>),</span><br><span class="line">    category_id   <span class="type">INT</span>,</span><br><span class="line">    buy_count     <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (win_start,category_id) <span class="keyword">NOT</span> ENFORCED</span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">    <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;jdbc&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;url&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;jdbc:postgresql://10.0.0.236:5432/postgres?currentSchema=public&amp;reWriteBatchedInserts=true&#x27;</span>,              <span class="comment">-- 请替换为您的实际 MySQL 连接参数</span></span><br><span class="line">    <span class="string">&#x27;table-name&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;oceanus_advanced4_output&#x27;</span>, <span class="comment">-- 需要写入的数据表</span></span><br><span class="line">    <span class="string">&#x27;username&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>,                      <span class="comment">-- 数据库访问的用户名（需要提供 INSERT 权限）</span></span><br><span class="line">    <span class="string">&#x27;password&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;yourpassword&#x27;</span>,               <span class="comment">-- 数据库访问的密码</span></span><br><span class="line">    <span class="string">&#x27;sink.buffer-flush.max-rows&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;200&#x27;</span>,     <span class="comment">-- 批量输出的条数</span></span><br><span class="line">    <span class="string">&#x27;sink.buffer-flush.interval&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;2s&#x27;</span>       <span class="comment">-- 批量输出的间隔</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="3-创建临时视图，用于将原始数据过滤、窗口聚合"><a href="#3-创建临时视图，用于将原始数据过滤、窗口聚合" class="headerlink" title="3. 创建临时视图，用于将原始数据过滤、窗口聚合"></a>3. 创建临时视图，用于将原始数据过滤、窗口聚合</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> `kafka_json_source_view` <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  TUMBLE_START(time_stamp,<span class="type">INTERVAL</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">MINUTE</span>) <span class="keyword">AS</span> win_start,</span><br><span class="line">  category_id,</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">AS</span> buy_count</span><br><span class="line"><span class="keyword">FROM</span> `kafka_json_source_table`</span><br><span class="line"><span class="keyword">WHERE</span> user_behavior <span class="operator">=</span> <span class="string">&#x27;buy&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> TUMBLE(time_stamp,<span class="type">INTERVAL</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">MINUTE</span>),category_id;</span><br></pre></td></tr></table></figure><h2 id="4-统计每分钟-Top3-购买种类"><a href="#4-统计每分钟-Top3-购买种类" class="headerlink" title="4. 统计每分钟 Top3 购买种类"></a>4. 统计每分钟 Top3 购买种类</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `jdbc_upsert_sink_table`</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">b.win_start,</span><br><span class="line">b.category_id,</span><br><span class="line"><span class="built_in">CAST</span>(b.buy_count <span class="keyword">AS</span> <span class="type">INT</span>) <span class="keyword">AS</span> buy_count</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">          ,<span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> win_start <span class="keyword">ORDER</span> <span class="keyword">BY</span> buy_count <span class="keyword">DESC</span>) <span class="keyword">AS</span> rn</span><br><span class="line">      <span class="keyword">FROM</span> `kafka_json_source_view`</span><br><span class="line">      ) b</span><br><span class="line"><span class="keyword">WHERE</span> b.rn <span class="operator">&lt;=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本文使用 TUMBLE WINDOW 配合 ROW_NUMBER 函数，统计分析了每分钟内购买量前三的商品种类，用户可根据实际需求选择相应的窗口函数统计对应的 TopN。更多窗口函数的使用参考时间窗口函数。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 保证数据一致性</title>
      <link href="/2022/11/30/Flink%20%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/2022/11/30/Flink%20%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>在Flink中，会自动做检查点，用于故障时恢复一个应用。在恢复时，application的state信息可以根据最近完成的检查点进行重建，并继续运行。不过，仅将一个application的state进行重置并不足以满足exactly-once的保证。</p><p>为了给一个应用提供exactly-once保证，在应用根据检查点重置state时，它的每个source connector都应该有能力将它的read position重置到做检查点时的read position。在做一个检查点时，source operator将它的read position也持久化，并在恢复时根据此位置进行重置。对于这类可以重置read position的source connector，比较有代表性的有：</p><p>基于文件的源：可以存储读文件字节流时的偏移量<br>Kakfa：可以存储读入topic partition的偏移量</p><p>如果一个application从一个无法重置read position的source connector读数据，则在故障发生并恢复时，只能提供at-most-once 的保证。</p><p>Flink的检查点与恢复机制、结合可重置reading position的source connector，可以确保一个应用不会丢失任何数据。但是，此应用仍可能输出同一数据两次。因为若是应用故障发生在两次检查点之间，则必定会导致已经成功输出的数据再次输出一次。所以仅通过Flink与source connector的行为，并不足以提供端到端的exactly-once保证，即使application的state具有exactly-once的保证。</p><p>一个application若是需要提供端到端exactly-once 的保证，则需要特殊的sink connectors。对于sink connectors来说，有两种技术可以应用于不同的场景，用于达到exactly-once的保证，分别为：idempotent writes、以transactional writes。</p><h1 id="Idempotent-Writes"><a href="#Idempotent-Writes" class="headerlink" title="Idempotent Writes"></a>Idempotent Writes</h1><p>一个idempotent 操作可被执行多次，但是仅会产生一个变化。例如向一个hashmap中插入同样的key-value pair，这即为一个idempotent操作。因为仅有第一次操作会在hashmap中增加此条目，而之后的插入不会改变hashmap中的内容。一个非 idempotent 操作的例子如追加操作，即使是同样的数据，每次追加都会增加一条数据。在流应用中，idempotent write是一个很有特点的操作，它们可以多次执行，但并不改变最终的结果。所以在Flink根据检查点机制进行恢复时，可以在一定程度上缓解replay对结果造成的影响（或是没有影响）。</p><p>需要注意的是，若是一个应用依赖于idempotent sinks，以达到exactly-once 的结果，则必须保证的是：在replay时覆盖之前写的结果。一般来说，只要流应用在replay时正常执行并输出，在新的输出覆盖掉之前写的结果后，即可以正常到达一致状态。</p><h1 id="Transactional-Writes"><a href="#Transactional-Writes" class="headerlink" title="Transactional Writes"></a>Transactional Writes</h1><p>第二种实现端到端exactly-once 一致性的方法是基于transactional writes。这个方法基于的想法是：仅在最近一个检查点成功完成后，才将所有结果写入到一个外部的sink系统。这个行为可以实现端到端exactly-once的原因是因为：在故障发生时，应用会被重置到最近的检查点，并且在此检查点之后，没有任何结果被写入到外部sink系统。但是此方法会增加延时，因为结果仅能在一个检查点完成后才能看到。</p><p>Flink提供了两种方式分别实现transactional sink connectors – 一个通用的 write-ahead-log（WAL<br>）以及一个two-phase-commit（2PC）sink。WAL sink将所有result records写入应用的state，并在它收到了一个“检查点完成”的通知后，将结果输出到sink 系统。因为WAL sink会将result records缓存到state backend，所以它可以用于任何sink 系统中。然而，使用此方法实现的exactly-once仍会有些代价：增加了应用的state大小，并且sink 系统需要处理突增写入的模式。</p><p>与WAL不同的是，2PC sink需要sink system提供事务支持，或者提供模拟事务的支持。对于每个检查点，sink首先启动一个事务，将所有接收到的记录添加到事务中，并将它们写入sink系统，但是不提交（commit）。当它收到一个“检查点完成”的通知后，它提交事务，并将结果落盘。</p><p>2PC协议集成在Flink的检查点机制中。Checkpoint barriers便是启动一个新事务的通知，所有operators中对于它“自身检查点完成”的通知，即是它们的commit 投票。JobManager的对于“整个检查点完成”的消息，即为提交事务的指示。</p><p>相对于WAL sinks，2PC sinks是基于sink 系统以及sink的实现方式，达到exactly-once的输出保障。而 相对于WAL sink的突增写入模式，2PC sink为持续向sink 系统写入记录。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 数据倾斜优化</title>
      <link href="/2022/11/30/Flink%20%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E4%BC%98%E5%8C%96/"/>
      <url>/2022/11/30/Flink%20%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h1><p>当进行聚合运算时（GroupBy&#x2F;KeyBy + Agg），如果聚合所使用的key存在热点，则会导致数据倾斜。如统计某日各个省份的车流量，则负责运算北京、上海等一线城市的count subtask节点则会成为热点，处理数据的压力会比较大。</p><h1 id="2-危害"><a href="#2-危害" class="headerlink" title="2. 危害"></a>2. 危害</h1><h2 id="2-1-任务卡死"><a href="#2-1-任务卡死" class="headerlink" title="2.1 任务卡死"></a>2.1 任务卡死</h2><p>keyBy 或 rebalance 下游的算子，如果单个 subtask 存在热点并完全卡死，会把整个 Flink 任务卡死。看如下示例：<br>如下图所示，上游每个 Subtask 中会有 3 个 resultSubPartition，连接下游算子的 3 个 subtask。下游每个 subtask 会有 2 个 InputChannel，连接上游算子的 2 个 subtask。Local BufferPool为subtask中的ResultSubpartition&#x2F;InputChannel所共用，在正常运行过程中如果没有反压，所有的 buffer pool 是用不完的。</p><p>一旦subtask B0变成热点，则会引起反压，依次产生如下问题：</p><ol><li>Subtask B0 内的 A0 和 A1 两个 InputChannel 会被占满；Subtask B0 公共的 BufferPool 中可申请到的空间也被占满</li><li>Subtask A0 和 A1 的 B0 ResultSubPartition 被占满；Subtask A0 和 A1 公共的 BufferPool 中可申请到的空间也被占满</li><li>如图2所示，Subtask A0 的主线程会从上游读取数据消费，按照数据的 KeyBy 规则，将数据发送到 B0、B1、B2 三个 ResultSubpartition 中；可以看到，如果 B0 这个ResultSubpartition占满了，且 B0 在公共的 Local BufferPool 中可申请到的空间也被占满。现在有一条数据被keyby后发往B0，但是现在 B0 这个ResultSubpartition 没有空间了，所以主线程就会卡在申请 buffer 上，直到可以再申请到 buffer</li></ol><p>Subtask A0 的主线程被卡住，则不会往下游的任何subtask发送数据了，如图1所示，下游的Subtask B1和Subtask B2不再接收新数据。整个任务处于瘫痪状态</p><h2 id="2-2-Checkpoint时间变长"><a href="#2-2-Checkpoint时间变长" class="headerlink" title="2.2 Checkpoint时间变长"></a>2.2 Checkpoint时间变长</h2><p>checkpoint barrier也是一种特殊的数据，如果整个任务中各个可用buffer变少，则checkpoint barrier的传输也会因为找不到可用buffer而降低速度；由于checkpoint barrier的对齐机制，会造成当前checkpoint的barrier迟迟无法对齐，进而超时。</p><h2 id="2-3-State变大"><a href="#2-3-State变大" class="headerlink" title="2.3 State变大"></a>2.3 State变大</h2><p>对于有两个以上输入管道的 Operator，存在checkpoint barrier对齐机制，接受到较快的输入管道的 barrier 后，它后面数据会被缓存起来但不处理，直到较慢的输入管道的 barrier 也到达，这些被缓存的数据会被放到state 里面，导致 checkpoint 变大。</p><h1 id="3-解决办法"><a href="#3-解决办法" class="headerlink" title="3. 解决办法"></a>3. 解决办法</h1><h2 id="3-1-修改分区策略"><a href="#3-1-修改分区策略" class="headerlink" title="3.1 修改分区策略"></a>3.1 修改分区策略</h2><h3 id="3-1-1-目标"><a href="#3-1-1-目标" class="headerlink" title="3.1.1 目标"></a>3.1.1 目标</h3><p>让不需要shuffle的两个算子间进行shuffle，打乱数据，从而避免数据倾斜</p><h3 id="3-1-2-手段"><a href="#3-1-2-手段" class="headerlink" title="3.1.2 手段"></a>3.1.2 手段</h3><p>在Flink任务提交后，经常可以看到web ui中的一些算子之间采用的分区策略是forward，在该分区策略下很可能会存在数据倾斜现象。如以下情况：<br>某kafka topic统计每个省份的车次，针对每个省份都有一个partition，共计36个partition，同时设有36个source算子，36个flatmap算子。由于source和flatmap满足one-to-one关系，且并行度相同，则Flink默认会采用forward这个分区策略来关联source和flatmap这两个算子。<br>Flink默认设置forward分区策略有两个条件：</p><ol><li>两个算子满足one-to-one关系</li><li>两个算子并行度相同</li></ol><p>此时，北京和上海对应的flatmap算子必然会出现热点数据，由于source到flatmap算子之间并不需要有特定的对应关系，因此可以采用不同的分区策略来将数据打乱，让不同省份的车流数据落到所有的flatmap算子，消除数据倾斜。</p><p>因此，我们只需要破坏forward分区策略的条件即可</p><ol><li>修改两个算子的并行度</li><li>强行设定分区策略：<code>dataStream.rebalance();</code></li></ol><h2 id="3-2-两阶段聚合"><a href="#3-2-两阶段聚合" class="headerlink" title="3.2 两阶段聚合"></a>3.2 两阶段聚合</h2><p>所谓两阶段聚合，即在需要shuffle的两个算子之间，再加一层算子</p><h3 id="3-2-1-目标"><a href="#3-2-1-目标" class="headerlink" title="3.2.1 目标"></a>3.2.1 目标</h3><p>先进行一次聚合，减小算子2和算子3之间的数据量，减轻算子2和算子3之间的热点问题<br>新增新的shuffle，打散算子1和算子2之间的数据，减轻算子1和算子2之间的热点问题</p><h3 id="3-2-2-手段"><a href="#3-2-2-手段" class="headerlink" title="3.2.2 手段"></a>3.2.2 手段</h3><p>我们以sql的优化作为范例进行讲解，这样更加直观和简洁。DataStream API无非就是仿照sql的group by + agg模式，增加一层keyby + agg。</p><h4 id="3-2-2-1-修改sql"><a href="#3-2-2-1-修改sql" class="headerlink" title="3.2.2.1 修改sql"></a>3.2.2.1 修改sql</h4><p>有如下需求，按天统计每个类目的成交额</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    date_format(ctime, <span class="string">&#x27;%Y%m%d&#x27;</span>) <span class="keyword">as</span> cdate, <span class="comment">-- 将数据从时间戳格式（2018-12-04 15:44:54），转换为date格式(20181204)</span></span><br><span class="line">       category_id,</span><br><span class="line">    <span class="built_in">sum</span>(price) <span class="keyword">as</span> category_gmv</span><br><span class="line"><span class="keyword">FROM</span> src</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> date_format(ctime, <span class="string">&#x27;%Y%m%d&#x27;</span>), category_id; <span class="comment">--按照天做聚合</span></span><br></pre></td></tr></table></figure><p>以这个SQL为例，其数据流程图如下，一个小方块表示一条成交记录，不同颜色代表不同的category_id<br>Group By + Agg 模式中，SQL作业性能与数据分布非常相关，如果数据中存在数据倾斜，也就是某个key的数据异常的多，那么某个聚合节点就会成为瓶颈，作业就会有明显的反压及延时现象。<br>用两阶段聚合方法优化后的SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cdate,category_id,<span class="built_in">sum</span>(category_gmv_p) <span class="keyword">as</span> category_gmv</span><br><span class="line"><span class="keyword">FROM</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> </span><br><span class="line">        date_format(ctime, <span class="string">&#x27;%Y%m%d&#x27;</span>) <span class="keyword">as</span> cdate, <span class="comment">-- 将数据从时间戳格式（2018-12-04 15:44:54），转换为date格式(20181204)</span></span><br><span class="line">           category_id,</span><br><span class="line">        <span class="built_in">sum</span>(price) <span class="keyword">as</span> category_gmv_p</span><br><span class="line">    <span class="keyword">FROM</span> src</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> category_id, <span class="built_in">mod</span>(hash_code(<span class="built_in">FLOOR</span>(RAND(<span class="number">1</span>)<span class="operator">*</span><span class="number">1000</span>), <span class="number">256</span>),date_format(ctime, <span class="string">&#x27;%Y%m%d&#x27;</span>); <span class="comment">--按照天做聚合</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cdate,category_id</span><br></pre></td></tr></table></figure><p>SQL中做了将一个Group By+Agg拆称了两个，子查询里按照category_id和mod(hash_code(FLOOR(RAND(1)*1000), 256)分组，将同一个category_id上的数据打散成了256份，先做一层聚合。外层Group By+Agg，将子查询聚合后的结果再次做聚合。这样通过两层聚合的方式，即可大大缓解某聚合节点拥堵的现象。其数据流程图如下：<br>这种方法达到了两个优化目标，在日期的基础上再将数据分成256份，打散数据，减轻算子1和算子2之间的热点问题；在算子2进行了初步的sum聚合，减小了到达算子3的数据量，减轻了算子2和算子3之间的热点问题。 该方法通过取余的方式将数据进一步打散，另有给key添加随机数的方式进行打散</p><h4 id="3-2-2-2-Local-Global"><a href="#3-2-2-2-Local-Global" class="headerlink" title="3.2.2.2 Local-Global"></a>3.2.2.2 Local-Global</h4><p>LocalGlobal和PartialFinal其实都属于两阶段聚合，只不过封装了拆解逻辑，我们只需要对Flink SQL任务做简单的配置即可。</p><p>LocalGlobal优化可以用来解决聚合时的数据倾斜问题。其核心思想是，将聚合分为两个阶段执行，先在上游进行局部(本地&#x2F;Local)聚合，再在下游进行全局(Global)聚合，类似MapReduce的Combine + Reduce，即先进行一个本地Reduce，再进行全局Reduce。该方法，只完成了先进行一次聚合，减少数据量这个目标<br>以如下场景为例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> color, <span class="built_in">sum</span>(id)</span><br><span class="line"><span class="keyword">FROM</span> T</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> color</span><br></pre></td></tr></table></figure><p>开启LocalGlobal：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TableEnvironment</span> <span class="variable">tEnv</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> tEnv.getConfig().getConfiguration();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要使用LocalGlobal优化，需要先开启MiniBatch </span></span><br><span class="line">configuration.setString(<span class="string">&quot;table.exec.mini-batch.enabled&quot;</span>, <span class="string">&quot;true&quot;</span>); </span><br><span class="line">configuration.setString(<span class="string">&quot;table.exec.mini-batch.allow-latency&quot;</span>, <span class="string">&quot;5 s&quot;</span>);</span><br><span class="line">configuration.setString(<span class="string">&quot;table.exec.mini-batch.size&quot;</span>, <span class="string">&quot;5000&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启LocalGlobal</span></span><br><span class="line">configuration.setString(<span class="string">&quot;table.optimizer.agg-phase-strategy&quot;</span>, <span class="string">&quot;TWO_PHASE&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="3-2-2-3-Partial-Final"><a href="#3-2-2-3-Partial-Final" class="headerlink" title="3.2.2.3 Partial-Final"></a>3.2.2.3 Partial-Final</h4><p>LocalGlobal优化针对普通聚合（例如SUM、COUNT、MAX、MIN和AVG）有较好的效果，对于COUNT DISTINCT收效不明显，因为COUNT DISTINCT在Local聚合时，对于DISTINCT KEY的去重率不高，导致在Global节点仍然存在热点<br>如下场景，统计一天的UV</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">day</span>, <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> user_id)</span><br><span class="line"><span class="keyword">FROM</span> T</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">day</span></span><br></pre></td></tr></table></figure><p>如果user_id比较稀疏，即便开启了LocalGlobal优化，收效也并不明显，因为COUNT DISTINCT在Local阶段时，去重率并不高，这就导致在Global阶段仍然存在热点问题。不满足第一条目标和第二条目标。<br>为了解决这一问题，需要将原始聚合拆分成两层聚合:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">day</span>, <span class="built_in">SUM</span>(cnt)</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">day</span>, <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> user_id) <span class="keyword">as</span> cnt</span><br><span class="line">    <span class="keyword">FROM</span> T</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">day</span>, <span class="built_in">MOD</span>(HASH_CODE(user_id), <span class="number">1024</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">day</span></span><br></pre></td></tr></table></figure><p>现在Blink Planner提供了PartialFinal功能，无需自己拆解sql，只要简单的配置即可，配置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TableEnvironment</span> <span class="variable">tEnv</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> tEnv.getConfig().getConfiguration();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启MiniBatch </span></span><br><span class="line">configuration.setString(<span class="string">&quot;table.exec.mini-batch.enabled&quot;</span>, <span class="string">&quot;true&quot;</span>); </span><br><span class="line">configuration.setString(<span class="string">&quot;table.exec.mini-batch.allow-latency&quot;</span>, <span class="string">&quot;5 s&quot;</span>);</span><br><span class="line">configuration.setString(<span class="string">&quot;table.exec.mini-batch.size&quot;</span>, <span class="string">&quot;5000&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启LocalGlobal</span></span><br><span class="line">configuration.setString(<span class="string">&quot;table.optimizer.agg-phase-strategy&quot;</span>, <span class="string">&quot;TWO_PHASE&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启Split Distinct</span></span><br><span class="line">configuration.setString(<span class="string">&quot;table.optimizer.distinct-agg.split.enabled&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程常见问题</title>
      <link href="/2022/10/31/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2022/10/31/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="线程的状态有哪些？"><a href="#线程的状态有哪些？" class="headerlink" title="线程的状态有哪些？"></a>线程的状态有哪些？</h1><p>线程的生命周期大致分为5个阶段：<br>NEW（新建）：新建一个Thread对象时，此时还没有线程。<br>RUNNABLE（就绪）：调用start方法可以使线程进入就绪状态。<br>RUNNING（运行）：处于就绪状态的线程获得了CPU就可以执行业务，进入运行状态。<br>BLOCKED（阻塞）：处于运行状态的线程如果调用了sleep、wait方法或者竞争锁失败会进入阻塞状态。<br>TERMINATED（终止）：线程正常结束或者意外终止会进入终止状态。<br>线程的生命周期是比较基础的知识，一般是作为一个切入点有浅入深的问其他问题，在回答这个问题的时候不要干巴巴的只说5个状态单词，要把每个状态是怎么进入的也要讲一下。你如果不讲，面试官就会继续追问：那线程在哪些情况会进入阻塞状态呢？</p><h1 id="synchronized锁的升级机制"><a href="#synchronized锁的升级机制" class="headerlink" title="synchronized锁的升级机制"></a>synchronized锁的升级机制</h1><p>synchronized是JVM关键字，可以用来修饰代码块、方法（普通方法和静态方法），它是一个可重入的不可打断的锁。<br>线程竞争synchronized锁其实是对锁对象monitor的竞争，代码块是Object锁对象的monitor，方法是this monitor，静态方法是class monitor。<br>锁的升级机制：<br>synchronized在JDK1.5时锁竞争失败后会直接进入阻塞状态，线程上下文之间切换比较消耗CPU性能，在JDK1.5之后对锁进行了优化，引入了无锁，偏向锁，轻量级锁和重量锁。锁的升级过程即是无锁状态到重量级锁状态的变化过程。<br>锁对象头（Mark Word）有一个偏向标志，无锁状态时为0，当线程获取到锁时会把偏向标志修改为1，并且CAS把对象头中的线程ID修改为自己的线程ID，当下一个线程竞争锁时，发现偏向标志为1，且锁还未释放，则会复制对象头的信息到自己线程的Lock Record中，并且CAS修改对象头中的指针指向自己的LR，如果修改失败则自旋一定次数后（默认10次）升级为重量级锁，此时竞争失败的线程将会挂起。</p><h1 id="synchronized和lock的区别？"><a href="#synchronized和lock的区别？" class="headerlink" title="synchronized和lock的区别？"></a>synchronized和lock的区别？</h1><p>特点：synchronized是独占可重入锁，是非公平的竞争锁方式。ReentrantLock也是独占可重入锁，但是其可以指定为公平锁，默认是非公平锁。<br>用法：synchronized可以修饰方法和代码块，不需要显示的加锁和解锁。ReentrantLock修饰代码块，在lock()和unlock()方法中间的代码都是同步代码，需要显示的加锁和解锁，将锁的控制权交给了开发人员。<br>性能：基于JVM对关键字的支持，单线程下synchronized关键字性能要优于ReentrantLock，但是多线程环境下ReentrantLock性能优于synchronized。<br>高级特性：获取synchronized锁失败的线程会一直阻塞直到获取到锁，不能中断。ReentrantLock提供了可中断获取锁的方法lockInterruptibly()，而且还提供了获取锁失败不阻塞立即返回的方法tryLock()，如果开发场景中涉及到了高级应用，那就只能选择显示锁Lock了。</p><h1 id="两种锁的使用场景？"><a href="#两种锁的使用场景？" class="headerlink" title="两种锁的使用场景？"></a>两种锁的使用场景？</h1><p>在多数情况下会优先选择synchronized关键字，在必须要用到高级特性的时候选择Lock锁。另外一点就是要注意synchronized锁升级的不可逆性，并发量谷峰值差别较大的时候优先选择Lock锁。</p><h1 id="开发中你是怎么创建线程的？"><a href="#开发中你是怎么创建线程的？" class="headerlink" title="开发中你是怎么创建线程的？"></a>开发中你是怎么创建线程的？</h1><p>有4种创建方式，通常使用线程池的方式管理线程，并且线程的参数都是可配置的。</p><h1 id="线程池的参数有哪些？"><a href="#线程池的参数有哪些？" class="headerlink" title="线程池的参数有哪些？"></a>线程池的参数有哪些？</h1><p>corePoolSize：核心线程数量，即使线程池中的线程空闲也会一直保持此数量的线程，除非设置了allowCoreThreadTimeOut为true。<br>maximumPoolSize：线程池中允许的最大线程数量。<br>keepAliveTime：当线程池中的线程数量超过了核心线程的数量，在回收空闲的线程时线程将等待任务的最大时间，超过这个时间还没有任务执行，那么线程将会被回收。<br>unit：超过核心线程数量的线程空闲时等待任务的时间单位。<br>workQueue：用于存放提交任务的工作队列，这个队列只存放提交但是未执行的Runnable。<br>threadFactory：创建线程的工厂。<br>handler：当线程数量和队列元素都达到最大时，拒绝再次提交任务的策略。</p><h1 id="线程池的拒绝策略有哪些？开发中你是怎么选择的？"><a href="#线程池的拒绝策略有哪些？开发中你是怎么选择的？" class="headerlink" title="线程池的拒绝策略有哪些？开发中你是怎么选择的？"></a>线程池的拒绝策略有哪些？开发中你是怎么选择的？</h1><p>拒绝策略有4种：直接丢弃，丢弃队列中第一个任务，抛出异常，调用者执行。<br>前两个开发中一般较少选择，因为不可控。开发中勾勾用过后面两种：抛出异常捕获了记录日志。让主线程去执行保证任务一定被运行。</p><h1 id="开发中使用多线程要注意什么？"><a href="#开发中使用多线程要注意什么？" class="headerlink" title="开发中使用多线程要注意什么？"></a>开发中使用多线程要注意什么？</h1><p>避免死锁</p><h1 id="什么情况下会发生死锁？"><a href="#什么情况下会发生死锁？" class="headerlink" title="什么情况下会发生死锁？"></a>什么情况下会发生死锁？</h1><p>交叉锁互相等待肯定会死锁，还有比如内存不足导致线程无法执行，死循环导致的锁无法释放，显示锁开发人员忘记释放锁也会导致死锁。<br>问到这里可能面试官真的就多嘴一问：你们项目中遇到过死锁的情况吗，线上是怎么排查的？</p><h1 id="什么是乐观锁和悲观锁？"><a href="#什么是乐观锁和悲观锁？" class="headerlink" title="什么是乐观锁和悲观锁？"></a>什么是乐观锁和悲观锁？</h1><p>乐观锁和悲观锁都是一种思想，有对应的实现。乐观锁主要用于多读的场所，悲观锁主要用于多写的场所。<br>悲观锁：在修改数据之前先加锁，再对数据进行修改的加锁方式。在数据修改的整个过程中都会加锁。悲观锁又分为读锁和写锁。<br>乐观锁：在修改数据前不需要加锁，只有在对数据进行修改的时候才会进行检测。可以利用CAS实现乐观锁。<br>CAS比较并交换，但是会出现ABA的问题，如果不能接受ABA那么在比较的时候可以添加版本号。</p><h1 id="volatile关键字的作用？"><a href="#volatile关键字的作用？" class="headerlink" title="volatile关键字的作用？"></a>volatile关键字的作用？</h1><p>volatile关键字是一个轻量级锁，它可以保证可见性和有序性，但是不能保证原子性。<br>此时面试官可能会问：它是如何保证可见性和有序性的，为什么不能保证原子性？<br>读volatile修饰的变量时，会从主内存中取数据，然后在线程的工作内存中创建变量副本。写volatile修饰的变量时，会对总线lock加锁，此时其他CPU都不能访问到这个变量，当线程将修改后的数据写入主内存并通知其他CPU的数据失效后，对总线解锁。其他线程在后续的过程中因为变量失效不得不从主内存再次获取数据，从而保证了可见性。<br>有序性就是通过内存屏障实现的。</p><h1 id="ThreadLocal原理是什么？"><a href="#ThreadLocal原理是什么？" class="headerlink" title="ThreadLocal原理是什么？"></a>ThreadLocal原理是什么？</h1><p>ThreadLocal可以实现线程之间的分离，ThreadLocal修饰的变量，每个线程都会复制一份，因此常用来修饰静态变量。ThreadLocal内部维护了Entry数组，其中key是当前线程，Value是用户存入的变量。<br>ThreadLocal内部类Entry继承了弱引用，key是weak的引用，一旦GC不管内存是否充足都会被回收，但是value是强引用，会存在null的key指向value，因而造成内存泄漏。因此使用结束需要手动的remove，避免内存泄漏。</p><h1 id="AQS的原理是什么？"><a href="#AQS的原理是什么？" class="headerlink" title="AQS的原理是什么？"></a>AQS的原理是什么？</h1><p>AQS是JUC工具类的核心，它内部维护了volatile的状态变量state，锁的竞争即是对state的竞争，竞争失败的线程会加入阻塞队列，它是一个先进先出的队列。AQS提供了不同的获取锁和释放锁的操作，包括独占模式（公平和非公平的获取锁方式），共享模式，条件等待模式。线程的node节点对象维护了4个状态：CANCLLED、SIGNAL、CONDITION、PROPAGATE ，决定了线程是否需要挂起和唤醒。</p><h1 id="CountDownLatch和CyclicBarrier的区别"><a href="#CountDownLatch和CyclicBarrier的区别" class="headerlink" title="CountDownLatch和CyclicBarrier的区别"></a>CountDownLatch和CyclicBarrier的区别</h1><ol><li>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset()</li><li>方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次</li><li>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。比如以下代码执行完之后会返回true</li><li>CountDownLatch会阻塞主线程，CyclicBarrier不会阻塞主线程，只会阻塞子线程。某线程中断CyclicBarrier会抛出异常，避免了所有线程无限等待</li></ol><h1 id="场景：如何实现三个线程顺序执行？"><a href="#场景：如何实现三个线程顺序执行？" class="headerlink" title="场景：如何实现三个线程顺序执行？"></a>场景：如何实现三个线程顺序执行？</h1><p>AQS实现类的用法一般都是给你描述个场景问你如何实现，比如题目的线程顺序执行，还有一个线程等待多个线程该如何实现，一个系统最多只能100个人登录如何实现？<br>就是想看看你是否了解Condition、CountDownLatch、CyclicBarrier、Semaphore的用法。<br>Condition只能由Lock锁创建，一般适用于两个线程之间的等待。<br>CountDownLatch是AQS共享模式的实现，state状态值表示计数器，await方法会使线程进入阻塞状态直到其他线程调用countdown方法将计数器减为0，CountDownLatch适用于一对多等待的场景。<br>CyclicBarrier常用来与CountDownLatch作比较，它也可以实现CountDownLatch一对多的等待，CyclicBarrier是一个栅栏，初始化指定屏障个数，所有的线程都到达屏障之后才可以继续执行，会使线程阻塞，且其可以重复使用。<br>Semaphore是许可证，常用来限制访问的数量，也是AQS共享模式的实现，state状态值用来表示许可证的数量。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库使用规范</title>
      <link href="/2022/09/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
      <url>/2022/09/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>单表索引利用率不高，部分为单字段索引，同时未避免索引失效</li><li>部分表单表数据过多，未进行及时拆表</li><li>索引建立未避过业务高峰时间</li><li>单次查询数据较多，未对数据量做限制</li><li>慢查询大多数集中在统计或分页场景下，具体原因在于扫描行数过多引起</li></ul><h1 id="后期规范"><a href="#后期规范" class="headerlink" title="后期规范"></a>后期规范</h1><h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><ul><li><strong>[强制]</strong> 数据库表、字段必须增加中文注释，字符编码集采用utf8mb4</li><li><strong>[强制]</strong> 数据库字段必须为非空，设置默认值</li><li><strong>[强制]</strong> 单表列数目不可超过25个，若超过则应考虑拆表存储</li><li>建议优先选择符合存储需求的最小数据类型，如unsigned无符号整型、char替换固定长度的varchar</li><li>避免使用TEXT、BLOB数据类型</li></ul><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><ul><li><strong>[强制]</strong> 查询数据必须限制数量级，不可频繁拉取大量数据；若业务需求，建议添加缓存层，以及相应的缓存更新机制</li><li><strong>[强制]</strong> 查询时指定所需的列，读取过多不需要的列会增加数据库的CPU、IO消耗，同时不能有效利用联合索引</li><li><strong>[强制]</strong> 对于分页场景需求，不推荐基于limit实现分页，容易触发深度分页；可根据主键id或其他自增字段实现查询分页</li><li>查询时应注意数据字段类型，避免隐式类型转换，从而导致无法利用索引的问题</li><li>查询时遵循索引最左匹配原则，避免索引失效情况，如：左模糊查询%like%、函数处理等；</li><li>建议单表数据量级不超过3000万，如查询过于复杂的表应考虑水平拆表</li><li>避免使用子查询，可把子查询优化为连表查询</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li><strong>[强制]</strong> 数据库表索引变更时，需在业务查询不频繁的时间进行，严禁在业务繁忙时进行索引变更</li><li><strong>[强制]</strong> 单表索引数量不超过8个，单个索引字段不超过5个，核心SQL优先考虑联合索引</li><li>索引顺序：1.区分度最高的字段放在索引左侧；2.查询频率高的字段放在索引左侧；3.字段长度小的字段放在索引左侧；</li><li>避免在更新比较频繁、区分度较小的列上单独建立索引</li><li>where条件使用范围查询时，索引最多用于一个范围条件，超过则不再使用索引</li><li>在较长的varchar字段上使用索引时，建议指定索引长度 </li><li>部分查询场景有排序需求时，order by字段需同样注意索引顺序，否则会出现慢查询；可通过explain查看sql执行计划，选取合适的字段或增加索引来满足排序需求</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程间通信</title>
      <link href="/2022/09/30/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2022/09/30/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="线程间通信常见问题"><a href="#线程间通信常见问题" class="headerlink" title="线程间通信常见问题"></a>线程间通信常见问题</h1><ol><li>三个线程分别打印 A，B，C，要求这三个线程一起运行，打印 n 次，输出形如“ABCABCABC…”</li><li>两个线程交替打印 0~100 的奇偶数</li><li>通过 N 个线程顺序循环打印从 0 至 100</li><li>多线程按顺序调用，A-&gt;B-&gt;C，AA 打印 5 次，BB 打印10 次，CC 打印 15 次，重复 10 次</li><li>用两个线程，一个输出字母，一个输出数字，交替输出 1A2B3C4D…26Z</li></ol><h2 id="Lock解法-第一题"><a href="#Lock解法-第一题" class="headerlink" title="Lock解法 第一题"></a>Lock解法 第一题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintABCUsingLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> times; <span class="comment">// 控制打印次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;   <span class="comment">// 当前状态值：保证三个线程之间交替打印</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintABCUsingLock</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.times = times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLetter</span><span class="params">(String name, <span class="type">int</span> targetNum)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i  &lt; times;)&#123;</span><br><span class="line">             lock.lock();</span><br><span class="line">             <span class="keyword">if</span> (state % <span class="number">3</span> == targetNum) &#123;</span><br><span class="line">                 state++;</span><br><span class="line">                 i++;</span><br><span class="line">                 System.out.print(name);</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//顺序打印10次</span></span><br><span class="line">        <span class="type">PrintABCUsingLock</span> <span class="variable">loopThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintABCUsingLock</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            loopThread.printLetter(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            loopThread.printLetter(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            loopThread.printLetter(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="wait-notify解法-第一题"><a href="#wait-notify解法-第一题" class="headerlink" title="wait&#x2F;notify解法 第一题"></a>wait&#x2F;notify解法 第一题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintABCUsingWaitNotify</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> times;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintABCUsingWaitNotify</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.times = times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLetter</span><span class="params">(String name, <span class="type">int</span> targetState)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++)</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">while</span> (state % <span class="number">3</span> != targetState) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            state++;</span><br><span class="line">            System.out.print(name);</span><br><span class="line">            LOCK.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">PrintABCUsingWaitNotify</span> <span class="variable">printABC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintABCUsingWaitNotify</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            printABC.printLetter(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            printABC.printLetter(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            printABC.printLetter(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="wait-notify解法-第二题"><a href="#wait-notify解法-第二题" class="headerlink" title="wait&#x2F;notify解法 第二题"></a>wait&#x2F;notify解法 第二题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.wideth.util.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OddEvenPrinter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    OddEvenPrinter(<span class="type">int</span> initCount, <span class="type">int</span> times) &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = initCount;</span><br><span class="line">        <span class="built_in">this</span>.limit = times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; limit)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;线程[%s]打印数字:%d&quot;</span>, Thread.currentThread().getName(), ++count));</span><br><span class="line">                monitor.notifyAll();</span><br><span class="line">                monitor.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//防止有子线程被阻塞未被唤醒，导致主线程不退出</span></span><br><span class="line">        monitor.notifyAll();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">OddEvenPrinter</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OddEvenPrinter</span>(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::print, <span class="string">&quot;odd&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::print, <span class="string">&quot;even&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="wait-notify解法-第五题"><a href="#wait-notify解法-第五题" class="headerlink" title="wait&#x2F;notify解法 第五题"></a>wait&#x2F;notify解法 第五题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.wideth.util.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumAndLetterPrinter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; printer(), <span class="string">&quot;numThread&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; printer(), <span class="string">&quot;letterThread&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().getName() == <span class="string">&quot;numThread&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">//打印数字1-26</span></span><br><span class="line">                    System.out.print((i + <span class="number">1</span>));</span><br><span class="line">                    <span class="comment">// 唤醒其他在等待的线程</span></span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 让当前线程释放锁资源，进入wait状态</span></span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Thread.currentThread().getName() == <span class="string">&quot;letterThread&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 打印字母A-Z</span></span><br><span class="line">                    System.out.print((<span class="type">char</span>) (<span class="string">&#x27;A&#x27;</span> + i));</span><br><span class="line">                    <span class="comment">// 唤醒其他在等待的线程</span></span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 让当前线程释放锁资源，进入wait状态</span></span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Condition解法-第一题"><a href="#Condition解法-第一题" class="headerlink" title="Condition解法 第一题"></a>Condition解法 第一题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.wideth.util.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintABCUsingLockCondition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> times;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">c1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">c2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">c3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintABCUsingLockCondition</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.times = times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintABCUsingLockCondition</span> <span class="variable">print</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintABCUsingLockCondition</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.printLetter(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>, c1, c2);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.printLetter(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>, c2, c3);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.printLetter(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>, c3, c1);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLetter</span><span class="params">(String name, <span class="type">int</span> targetState, Condition current, Condition next)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times;)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">while</span> (state % <span class="number">3</span> != targetState) &#123;</span><br><span class="line">                  current.await();</span><br><span class="line">               &#125;</span><br><span class="line">            state++;</span><br><span class="line">            i++;</span><br><span class="line">            System.out.print(name);</span><br><span class="line">            next.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore解法-第一题"><a href="#Semaphore解法-第一题" class="headerlink" title="Semaphore解法 第一题"></a>Semaphore解法 第一题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintABCUsingSemaphore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化许可数为1，A线程可以先执行</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphoreA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 初始化许可数为0，B线程阻塞</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphoreB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 初始化许可数为0，C线程阻塞</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphoreC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// A线程获得许可，同时semaphoreA的许可数减为0,进入下一次循环时</span></span><br><span class="line">                    <span class="comment">// A线程会阻塞，知道其他线程执行semaphoreA.release();</span></span><br><span class="line">                    semaphoreA.acquire();</span><br><span class="line">                    <span class="comment">// 打印当前线程名称</span></span><br><span class="line">                    System.out.print(Thread.currentThread().getName());</span><br><span class="line">                    <span class="comment">// semaphoreB许可数加1</span></span><br><span class="line">                    semaphoreB.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphoreB.acquire();</span><br><span class="line">                    System.out.print(Thread.currentThread().getName());</span><br><span class="line">                    semaphoreC.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphoreC.acquire();</span><br><span class="line">                    System.out.print(Thread.currentThread().getName());</span><br><span class="line">                    semaphoreA.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore解法-第三题"><a href="#Semaphore解法-第三题" class="headerlink" title="Semaphore解法 第三题"></a>Semaphore解法 第三题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoopPrinter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">THREAD_COUNT</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//最大数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Semaphore[] semaphores = <span class="keyword">new</span> <span class="title class_">Semaphore</span>[THREAD_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i  &lt; THREAD_COUNT; i++)&#123;           <span class="comment">//非公平信号量，每个信号量初始计数都为1</span></span><br><span class="line">            semaphores[i] = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (i != THREAD_COUNT - <span class="number">1</span>) &#123;</span><br><span class="line">               <span class="comment">//  System.out.println(i+&quot;===&quot;+semaphores[i].getQueueLength());</span></span><br><span class="line">               <span class="comment">//获取一个许可前线程将一直阻塞, for 循环之后只有 syncObjects[2] 没有被阻塞</span></span><br><span class="line">                 semaphores[i].acquire();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i  &lt; THREAD_COUNT; i++)&#123;          <span class="comment">// 初次执行，上一个信号量是 syncObjects[2]</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">lastSemphore</span> <span class="operator">=</span> i == <span class="number">0</span> ? semaphores[THREAD_COUNT - <span class="number">1</span>] : semaphores[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">currentSemphore</span> <span class="operator">=</span> semaphores[i];</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 初次执行，让第一个 for 循环没有阻塞的 syncObjects[2] 先获得令牌阻塞了</span></span><br><span class="line">                lastSemphore.acquire();</span><br><span class="line">                System.out.println(<span class="string">&quot;thread&quot;</span> + index + <span class="string">&quot;: &quot;</span> + result++);</span><br><span class="line">                <span class="keyword">if</span> (result &gt; maxNum) &#123;</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 释放当前的信号量，syncObjects[0] 信号量此时为 1，下次 for 循环中上一个信号量即为syncObjects[0]</span></span><br><span class="line">                currentSemphore.release();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LockSupport解法-第一题"><a href="#LockSupport解法-第一题" class="headerlink" title="LockSupport解法 第一题"></a>LockSupport解法 第一题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintABCUsingLockSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread threadA, threadB, threadC;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        threadA = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 打印当前线程名称</span></span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">                <span class="comment">// 唤醒下一个线程</span></span><br><span class="line">                LockSupport.unpark(threadB);</span><br><span class="line">                <span class="comment">// 当前线程阻塞</span></span><br><span class="line">                LockSupport.park();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        threadB = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 先阻塞等待被唤醒</span></span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">                <span class="comment">// 唤醒下一个线程</span></span><br><span class="line">                LockSupport.unpark(threadC);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        threadC = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 先阻塞等待被唤醒</span></span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">                <span class="comment">// 唤醒下一个线程</span></span><br><span class="line">                LockSupport.unpark(threadA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LockSupport解法-第五题"><a href="#LockSupport解法-第五题" class="headerlink" title="LockSupport解法 第五题"></a>LockSupport解法 第五题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumAndLetterPrinterByLockSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread numThread, letterThread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        letterThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>) (<span class="string">&#x27;A&#x27;</span> + i));</span><br><span class="line">                LockSupport.unpark(numThread);</span><br><span class="line">                LockSupport.park();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;letterThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        numThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) &#123;</span><br><span class="line">                System.out.print(i);</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                LockSupport.unpark(letterThread);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;numThread&quot;</span>);</span><br><span class="line">        numThread.start();</span><br><span class="line">        letterThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盛最多水的容器</title>
      <link href="/2022/08/31/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>/2022/08/31/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = height.length - <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        res = height[i] &lt; height[j] ? </span><br><span class="line">            Math.max(res, (j - i) * height[i++]): </span><br><span class="line">            Math.max(res, (j - i) * height[j--]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接雨水</title>
      <link href="/2022/07/31/%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
      <url>/2022/07/31/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p>输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left_max</span> <span class="operator">=</span> <span class="number">0</span>, right_max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[left] &gt;= left_max) &#123;</span><br><span class="line">                left_max = height[left];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += (left_max - height[left]);</span><br><span class="line">            &#125;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[right] &gt;= right_max) &#123;</span><br><span class="line">                right_max = height[right];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += (right_max - height[right]);</span><br><span class="line">            &#125;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
