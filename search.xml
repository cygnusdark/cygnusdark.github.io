<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>架构师谈技术影响力</title>
      <link href="/2023/08/03/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%B0%88%E6%8A%80%E6%9C%AF%E5%BD%B1%E5%93%8D%E5%8A%9B/"/>
      <url>/2023/08/03/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%B0%88%E6%8A%80%E6%9C%AF%E5%BD%B1%E5%93%8D%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-如何理解技术影响力"><a href="#1-如何理解技术影响力" class="headerlink" title="1. 如何理解技术影响力"></a>1. 如何理解技术影响力</h2><p>技术影响力可以理解为是我们工程师个人画像的一部分，是一种“品牌形象”。</p><p>技术影响力不仅仅是针对体现在公司外部的，也体现在内部。以及，它不需要我们到达一定的级别、辐射到很大的工作范围才应该去打造，它应该是贯穿我们的职业生涯的。技术影响力小可以体现在自己的team、大可以体现到 BU、公司、行业，在不同的职业发展阶段，都可以提升技术影响力。</p><p>我们经常讲——把自己的职业发展和人生轨迹当做一家公司去经营，我们要有经营技术影响力的意识，有了意识就会有可落地的方法，就要下功夫去打磨。</p><h2 id="2-如何有意识地培养技术影响力"><a href="#2-如何有意识地培养技术影响力" class="headerlink" title="2.如何有意识地培养技术影响力"></a>2.如何有意识地培养技术影响力</h2><p>要从小事做起，不轻易放过任何一次机会。</p><p>比如，新入职的时候，做一次认真、逻辑清晰的串讲。“你是我这么长时间以来见过的在这个模块里讲的最好的”，那这是一个漂亮的串讲，那技术影响力就潜移默化地被你打造了。</p><p>比如，积极在团队或公司内部做技术分享，在BIT授课，在社区、在行业大会做分享。针对这一点，你是否愿意去分享、能否把分享的知识讲的清晰透彻是很重要的，这个能力也是通过不断的实践锻炼出来的。</p><p>再比如，现在自媒体如火如荼，在内部知识库、内部“术说”栏目、外部公众号等输出一些干货文章。不仅对自己掌握技术知识有很大的帮助，个人技术影响力自然而然就积累起来了。</p><p>当然，打造技术影响力需要持续去做，不能急于求成、功利化。</p><p>关于技术分享，在这里想额外和大家聊两点好处：</p><p>1、技术分享有助于自己打造“内功”。掌握一项知识或技术，最高境界是把别人教会。对于工程师自己来说，透彻地掌握一项技术，是需要把知识结构化地整理出来并分享。学了——学了并整理——学了后整理并分享给别人，这是一个逐渐深入透彻的过程。</p><p>2、技术分享会潜移默化地提升个人技术影响力，并有助于后续团队协同。团队内部、团队和团队、部门之间经常会有协作，技术影响力的加持会在一定程度上让你更加容易地推动和落地事情。当然，这并不是说绝对的，前提是你的分享让对方觉得你确实很有多积累、心得和体会。</p><h2 id="3-打造技术影响力地渠道和方法"><a href="#3-打造技术影响力地渠道和方法" class="headerlink" title="3.打造技术影响力地渠道和方法"></a>3.打造技术影响力地渠道和方法</h2><p>打造技术影响力的渠道基本都在工作的环节中，不要轻易放弃任何一个机会。比如串讲、项目方案的评审、给 peer 团队分享技术设计、内部分享、项目汇报、到BIT讲授课程等，等积累到一定程度，还可以去报名行业大会。</p><p>我曾经也是这样走过来的，在工作五六年的时候，第一次报名参加了行业大会。只要进去那个大会的圈子，讲过几次后，以后自然就会有人在各种渠道邀请你继续分享。行业大会的官网每次会公开招募讲师，我的 mentor 之前在大会上分享过，考虑到技术话题比较新鲜，自己也有一些积累，想去跟同行去做交流和分享，所以当时我就通过邮件报了名，注明讲的内容和观众收益等。</p><p>早些年的发声渠道少，大会就那么几个，现在行业大会也多了，不管是文章还是演讲的渠道都会变多，就看你有没有这个意识去做。其实相比外部，内部是很好的机会。在内部锻炼后有了积累，对内容、流畅度、会场的把握就会不一样。没有人可以第一次就会讲好，要多锻炼、多积累。</p><h2 id="4-打造技术影响力需要具备哪些能力"><a href="#4-打造技术影响力需要具备哪些能力" class="headerlink" title="4.打造技术影响力需要具备哪些能力"></a>4.打造技术影响力需要具备哪些能力</h2><p>首先，要保有对技术有好奇心，有追根到底的精神，不能浅尝辄止。要把每个技术点研究的清晰透彻，做技术的积累。</p><p>其次，培养逻辑思维能力。比如做分享，要把这个分享议题的背景、来龙去脉、走向等思考清楚，提炼核心点，并能向别人快速清晰、有逻辑地讲明白。这里面还是有很多讲究，不同的受众（团队内、合作方、老板等）、不同的分享形式（文章、课程、分享等）和不同输出渠道，都会有一些差异。要多总结提炼，多实践，同时也推荐大家去读一读类似《金字塔原理》这些锻炼结构化思维能力的书。</p><p>最后，要有主动做知识沉淀和分享的意识。这里不是说一定要分享多少次，毕竟我们不是说让大家都变成布道师，而是要把握问题的本质，讲的有内容、有深度。</p><p>工程师不仅仅是要把代码写好，还要对技术有追求、对成长有方向、对机会要珍惜，那技术影响力的提升就不是难事。希望本篇文章，能够解答你关于技术影响力的一些困惑，重视并行动起来吧！</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度工程师职称标准</title>
      <link href="/2023/08/03/%E7%99%BE%E5%BA%A6%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%81%8C%E7%A7%B0%E6%A0%87%E5%87%86/"/>
      <url>/2023/08/03/%E7%99%BE%E5%BA%A6%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%81%8C%E7%A7%B0%E6%A0%87%E5%87%86/</url>
      
        <content type="html"><![CDATA[<h1 id="百度公司技术职称体系"><a href="#百度公司技术职称体系" class="headerlink" title="百度公司技术职称体系"></a>百度公司技术职称体系</h1><p>百度公司将工程师的技术职称分作12级：T1、T2、T3 ．．．．．．T12</p><p>其中职称和title的对应关系见下表：</p><table><thead><tr><th>职称级别</th><th>职称级别可选用Title</th><th>English Title</th></tr></thead><tbody><tr><td>T1</td><td>工程师</td><td>Software Engineer</td></tr><tr><td>T2</td><td>工程师</td><td>Software Engineer</td></tr><tr><td>T3</td><td>工程师</td><td>Software Engineer</td></tr><tr><td>T4</td><td>高级工程师</td><td>Senior Software Engineer</td></tr><tr><td>T5</td><td>高级工程师</td><td>Senior Software Engineer</td></tr><tr><td>T6</td><td>资深工程师</td><td>Staff Software Engineer</td></tr><tr><td>T7</td><td>资深工程师</td><td>Staff Software Engineer</td></tr><tr><td>T8</td><td>资深工程师</td><td>Staff Software Engineer</td></tr><tr><td>T9</td><td>主任架构师</td><td>Principal Architect</td></tr><tr><td>T10</td><td>杰出架构师</td><td>Distinguished Architect</td></tr><tr><td>T11</td><td>（领域）首席架构师</td><td>Chief Architect within the field</td></tr><tr><td>T12</td><td>首席架构师</td><td>Chief Architect</td></tr></tbody></table><p>注：职级后的中文描述对应于公司内部层级名称，工程师对外参加活动的title请参照hr部门的相关规定。</p><p>技术职称简要说明：</p><ul><li>技术职称每半年评定一次。</li><li>技术职称评定由技术委员会负责，具体的详细规定见百度技术委员会职称评定流程。</li><li>技术职称原则上不能跨级授予，特殊情况例外。高一级的职称应符合低一级职称的所有条件。</li><li>本职称标准为百度工程师职称体系总纲，根据工程师工作内容和工作性质的不同，各级tc还分别制定了一系列的《职称评定细则》。比如架构工程师职称评定细则，产品开发工程师职称评定细则、质量工程师职称评定细则、op工程师职称评定细则、系统工程师职称评定细则etc。</li><li>技术职称的评定主要依据个人专业能力、做出的贡献，按照《职称标准》、分专业《职称评定细则》进行评定。</li><li>技术职称评定是对工程师成长情况、团队梯队建设的一次综合考察，其中技术因素是最主要的，但是评价体系里面还包括我们团队的其他价值的体现：是否能够长期稳定输出、是否乐于参与团队建设和信息共享、项目的贡献，等等。</li></ul><p>各级别工程师标准的一般描述：<br>工程师——T1、T2、T3：</p><ul><li>掌握相关计算机编程知识；</li><li>能熟练编写高质量的计算机程序和文档。<br>T2：</li><li>合格的T2工程师需要满足如下要求：可以胜任一般模块的设计和实现，工作质量较高。<br>T3：</li><li>合格的T3工程师需要满足如下要求：重点在于——做事让人放心。</li><li>技术范围定义：模块级</li><li>符合我们对于工程师的基本要求：可以 独立自主 的完成一般难度的模块开发和调研工作；所谓“ 独立自主 ”，两重含义：<ul><li>技术指导人投入在指导这位工程师身上的时间和精力正常，没有明显过多之处；</li><li>工程师能够对自己负责的业务有一定的（短期）规划，思路合理、明确，并且有一定的产出。<br>高级工程师——T4、T5：</li></ul></li><li>高级工程师需要具备较强的专业背景和专业能力，能够严格遵守百度开发流程。</li><li>高级工程师的技术范围由一个中型方向扩展到一个乃至多个技术方向，在做技术规划和项目推进时能综合考虑技术方向内各因素，合理安排中长期工作，技术影响力也由中型方向扩展到技术方向。<br>T4：</li><li>合格的T4工程师需要满足如下要求：重点在于——独当一面。</li><li>技术范围定义：在一个较低难度的完整Topic上，或者是一个较难的Topic中的技术子集合上。</li><li>在上述技术范围定义下，能够把握 中期 的规划并且能够推动发展，具体包括：<ul><li>对 Topic 的思路明晰、做事方法清楚；</li><li>在该topic的工作上具备较充足的产出；</li><li>能清楚的掌握Topic若干方向的主次、重点、有条理；</li></ul></li><li>在技术方向的决策上可以做到：独当一面。<br>T5：</li><li>合格的高级I级工程师需要满足如下要求：重点在于Cover到周边Topic的面较广，或者在Topic内做得较深。</li><li>技术范围定义：一个重点的、或者难度高的topic 或者 一系列（&gt;2）的相关 Topic。</li><li>技术把握能力：t5的工程师需要做到如下两个条件之一：<ul><li>对于一个重点&#x2F;难的topic，基本可以分解为几个紧密关联的中型方向，工程师需要在其中一个方向独当一面并掌握得较深，并且能将成果积极应用到紧密关联的其他方向；</li><li>或者对于一系列的相关 Topic，工程师在其中多个Topic都能做到独挡一面，并能形成覆盖多个Topic的全局观点 。</li></ul></li><li>保证高质量的产出，代码&#x2F;文档&#x2F;调研质量都很高。</li></ul><p>资深工程师——T6、T7、T8：<br>T6：</p><ul><li>合格的t6级工程师需要满足如下要求：重点在于——完全把握一个技术方向。</li><li>技术范围定义 ：<ul><li>一个重点的、或者难度高的Topic；</li><li>或者一系列（&gt;2）的相关 Topic。</li></ul></li><li>技术把握能力：t6的工程师需要做到如下两个条件之一：<ul><li>对于一个重点&#x2F;难的topic，基本可以分解为几个紧密关联的中型方向，工程师需要有能力至少完全cover其中一个方向，并且对紧密关联的其他方向能够做到t4工程师的把握水平；</li><li>或者对于一系列的相关 Topic，工程师能够结合多个Topic去把握，不光是着眼于每一个Topic本身，且还有覆盖多个Topic的全局观点。</li></ul></li><li>在自己所在的topic内具备超出常人的产出。</li><li>在务实、自驱、follow through的精神等方面都表现突出。<br>T7：</li><li>合格的t7级工程师需要满足如下要求：重点在于对多个技术方向的掌控达到t6水平。</li><li>技术范围定义：多个（&gt;3）相关的Topic。</li><li>技术把握能力：每个Topic都能够完全把握达到t6水准。</li><li>技术影响力：在一个部门内的较大方向得到体现。</li><li>技术迁移能力：在已掌控的topic内证实了技术迁移能力，更够快速的迁移到相关方向，掌握这个方向的重点、主次、细节。</li><li>在自己所负责的多个topic内具备超出常人的产出。</li><li>在务实、自驱、follow through的精神等方面都表现突出。<br>T8：</li><li>除要达t7工程师全部要求外，最主要的区别是在技术抽象能力与技术迁移能力上，技术影响力也要扩展到公司内的某个重要技术部门。</li><li>合格的t8工程师重点在于——把握多个Topic 、技术深度、能力的迁移。</li><li>技术范围定义：多个（&gt;3）相关的Topic。</li><li>技术把握能力：每个Topic都能够完全把握，且能够抽象出更高层次的技术认识和方向规划。</li><li>技术影响力：要能够扩展到公司内的某个重要技术部门，对于非自己的领域，能够根据数据、介绍做出符合逻辑、科学的判断。</li><li>技术迁移能力：具备较强的技术迁移能力，新的技术方向和领域，能够快速的做起来，快速的形成自己解决此类问题的方法和手段。</li><li>在自己所负责的多个topic内具备超出常人的产出。</li><li>在务实、自驱、follow through的精神等方面都表现突出。</li></ul><p>主任架构师——T9、T10：<br>T9：</p><ul><li>合格的t9工程师具有系统级分析和设计能力，重点在于完全把握1到2个大的技术领域、技术深度充分，在某个大的技术领域是专家，具有不能替代的作用。</li><li>技术范围定义：大的技术领域，例如：网页搜索相关性；基础架构（存储、检索、平台等等），商业变现ctr预估等等。</li><li>技术把握能力：<ul><li>在大领域内能够完全把握，能够综合该领域所有技术方向（产品方向）给出技术决策、以及长期（至少1年以上）的规划；</li><li>能够在该领域内进行前瞻性的研究、开拓、规划；</li><li>对于非自己产品线的相关领域的问题，能够根据数据、介绍做出符合逻辑、科学的判断。</li></ul></li><li>技术影响力：<ul><li>能够扩展到公司的重要部门，以及整个技术部的相关领域；</li><li>其成果能够影响整个技术的相关领域，并有实际产出。</li></ul></li><li>技术迁移能力：具备大的技术领域之间的迁移能力。</li><li>梯队指导能力：具备指导T7以上工程师的能力，能够给T7的工程师以比较前瞻的指导。</li><li>技术视野：能够看到整个技术部的一些情况，并在必要的时候参与决策。</li><li>技术产出：在上述领域做出部门内其它人很难超越的成果和产出。<br>T10：</li><li>合格的t10工程师重点在于公司级别的专家，做出影响整个公司的成果和产出，具有不可替代的作用。</li><li>技术范围定义：百度公司技术发展所需要的完整的、核心的领域，例如：网页搜索涉及的核心领域；基础架构从底层到应用到运维；自然语言处理从底层到应用到前瞻；系统技术从底层到上层到前瞻到运营；搜索应用涉及的技术+产品，商业搜索变现涉及的核心技术etc。</li><li>技术把握能力：<ul><li>在上述领域内能够把握，对上述领域涉及的所有方面可以给出前瞻的开拓和规划，以及能够综合该领域所有技术方向（产品方向）符合百度技术部整体的发展方向的技术规划和判断；</li><li>能够在上述领域内进行前瞻性的研究、开拓、规划；</li><li>对于非自己产品线的相关领域的问题，能够给出判断、前瞻性意见。</li></ul></li><li>技术影响力：<ul><li>能够扩展到整个技术部的相关领域，有不可替代的作用；</li><li>业界有一定影响，可以代表百度形象。</li></ul></li><li>梯队指导能力：具备指导T8以上工程师的能力，能够给T8的工程师以比较前瞻的指导。</li><li>技术视野：<ul><li>能够在技术部范围内作出决策；</li><li>对业界情况掌握、了解，掌握业界动态，能够判断出并且将业界的新动态对百度有价值的部分引入技术部。</li></ul></li><li>技术产出：在自己所负责的领域内作出整个公司内其他人难以超越的成果和产出。</li><li>技术表达能力：能够在整个技术部和业界的会议上公开做presentation，能够代表百度技术部表达观点。</li></ul><p>首席架构师——T11、 T12：</p><ul><li>首席架构师（科学家）首先需要具备在业界世界范围内领先的成果和产出，并对公司有巨大帮助作为支撑。</li><li>作为工程师的最杰出代表，评定由公司最高管理层estaff负责，本标准中不详述其描述。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 公司制度 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 公司制度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习模型评价指标</title>
      <link href="/2023/07/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
      <url>/2023/07/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>机器学习问题之中，通常需要建立模型来解决具体问题，但对于模型的好坏，也就是模型的泛化能力，如何进行评估呢？<br>很简单，我们可以定一些评价指标，来度量模型的优劣。比如准确率、精确率、召回率、F1值、ROC、AUC等指标，但是你清楚这些指标的具体含义吗？下面我们一起来看看吧。</p></blockquote><h2 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h2><p>介绍各个指标之前，我们先来了解一下混淆矩阵。假如现在有一个二分类问题，那么预测结果和实际结果两两结合会出现如下四种情况：TP、FP、FN、TN<br>其中，T(True)代表正确、F(False)代表错误、P(Positive)代表1、N(Negative)代表0<br>TP：预测为1，实际为1，预测正确。<br>FP：预测为1，实际为0，预测错误。<br>FN：预测为0，实际为1，预测错误。<br>TN：预测为0，实际为0，预测正确。</p><h2 id="准确率"><a href="#准确率" class="headerlink" title="准确率"></a>准确率</h2><p>首先给出 <strong>准确率(Accuracy)</strong> 的定义，即预测正确的结果占总样本的百分比，表达式为 <strong>(TP+TN)&#x2F;(TP+TN+FP+FN)</strong></p><p>虽然准确率能够判断总的正确率，但是在样本不均衡的情况下，并不能作为很好的指标来衡量结果。</p><p>比如在样本集中，正样本有90个，负样本有10个，样本是严重的不均衡。对于这种情况，我们只需要将全部样本预测为正样本，就能得到90%的准确率，但是完全没有意义。对于新数据，完全体现不出准确率。因此，在样本不平衡的情况下，得到的高准确率没有任何意义，此时准确率就会失效。所以，我们需要寻找新的指标来评价模型的优劣。</p><h2 id="精确率"><a href="#精确率" class="headerlink" title="精确率"></a>精确率</h2><p><strong>精确率(Precision)</strong> 是针对预测结果而言的，其含义是在被所有预测为正的样本中实际为正样本的概率，表达式为 <strong>TP&#x2F;(TP+FP)</strong></p><p>精确率和准确率看上去有些类似，但是是两个完全不同的概念。精确率代表对正样本结果中的预测准确程度，准确率则代表整体的预测准确程度，包括正样本和负样本。</p><h2 id="召回率"><a href="#召回率" class="headerlink" title="召回率"></a>召回率</h2><p><strong>召回率(Recall)</strong> 是针对原样本而言的，其含义是在实际为正的样本中被预测为正样本的概率，表达式为 <strong>TP&#x2F;(TP+FN)</strong></p><p>下面我们通过一个简单例子来看看精确率和召回率。假设一共有10篇文章，里面4篇是你要找的。根据你的算法模型，你找到了5篇，但实际上在这5篇之中，只有3篇是你真正要找的。</p><p>那么算法的精确率是3&#x2F;5&#x3D;60%，也就是你找的这5篇，有3篇是真正对的。算法的召回率是3&#x2F;4&#x3D;75%，也就是需要找的4篇文章，你找到了其中三篇。以精确率还是以召回率作为评价指标，需要根据具体问题而定。</p><h2 id="F1分数"><a href="#F1分数" class="headerlink" title="F1分数"></a>F1分数</h2><p>精确率和召回率又被叫做查准率和查全率，可以通过P-R图进行表示。</p><p>如何理解P-R(精确率-召回率)曲线呢？或者说这些曲线是根据什么变化呢？</p><p>以逻辑回归举例，其输出值是0-1之间的数字。因此，如果我们想要判断用户的好坏，那么就必须定一个阈值。比如大于0.5指定为好用户，小于0.5指定为坏用户，然后就可以得到相应的精确率和召回率。但问题是，这个阈值是我们随便定义的，并不知道这个阈值是否符合我们的要求。因此为了寻找一个合适的阈值，我们就需要遍历0-1之间所有的阈值，而每个阈值都对应一个精确率和召回率，从而就能够得到上述曲线。</p><p>根据上述的P-R曲线，怎么判断最好的阈值点呢？首先我们先明确目标，我们希望精确率和召回率都很高，但实际上是矛盾的，上述两个指标是矛盾体，无法做到双高。因此，选择合适的阈值点，就需要根据实际问题需求，比如我们想要很高的精确率，就要牺牲掉一些召回率。想要得到很高的召回率，就要牺牲掉一些精准率。但通常情况下，我们可以根据他们之间的平衡点，定义一个新的指标：F1分数(F1-Score)。F1分数同时考虑精确率和召回率，让两者同时达到最高，取得平衡。F1分数表达式为 (2 * 精确率 * 召回率)&#x2F;(精确率+召回率)<br>上图P-R曲线中，平衡点就是F1值的分数。</p><p>F1值是精确率和召回率的调和均值，相当于精确率和召回率的综合评价指标</p><h2 id="ROC、AUC"><a href="#ROC、AUC" class="headerlink" title="ROC、AUC"></a>ROC、AUC</h2><p>正式介绍ROC和AUC之前，还需要再介绍两个指标，<strong>真正率(TPR)</strong> 和 <strong>假正率(FPR)</strong> 。</p><p><strong>真正率(TPR)</strong> &#x3D; <strong>灵敏度(Sensitivity)</strong> &#x3D; <strong>TP&#x2F;(TP+FN)</strong><br><strong>假正率(FPR)</strong> &#x3D; <strong>1-特异度(Specificity)</strong> &#x3D; <strong>FP&#x2F;(FP+TN)</strong></p><p>TPR和FPR分别是基于实际表现1、0出发的，也就是说在实际的正样本和负样本中来观察相关概率问题。因此，无论样本是否均衡，都不会被影响。</p><p>继续用上面例子，总样本中有90%的正样本，10%的负样本。TPR能够得到90%正样本中有多少是被真正覆盖的，而与那10%无关。同理FPR能够得到10%负样本中有多少是被覆盖的，而与那90%无关。因此我们从实际表现的各个结果出发，就能避免样本不平衡的问题，这就是为什么用TPR和FPR作为ROC、AUC指标的原因。</p><p>ROC曲线图横坐标为 <strong>假正率(FPR)</strong> ，纵坐标为 <strong>真正率(TPR)</strong> 。</p><p>与前面的P-R曲线类似，ROC曲线也是通过遍历所有阈值来绘制曲线的。如果我们不断的遍历所有阈值，预测的正样本和负样本是在不断变化的，相应的ROC曲线TPR和FPR也会沿着曲线滑动。</p><p>同时，我们也会思考，如何判断ROC曲线的好坏呢？我们来看，FPR表示模型虚报的程度，TPR表示模型预测覆盖的程度。理所当然的，我们希望虚报的越少越好，覆盖的越多越好。所以TPR越高，同时FPR越低，也就是ROC曲线越陡，那么模型的性能也就越好。</p><p>最后，我们来看一下，不论样本比例如何改变，ROC曲线都没有影响，也就是ROC曲线无视样本间的不平衡问题。</p><p><strong>AUC(Area Under Curve)</strong> 表示ROC中曲线下的面积，用于判断模型的优劣。如ROC曲线所示，连接对角线的面积刚好是0.5，对角线的含义也就是随机判断预测结果，正负样本覆盖应该都是50%。另外，ROC曲线越陡越好，所以理想值是1，即正方形。所以AUC的值一般是介于0.5和1之间的。AUC评判标准可参考如下</p><p>0.5-0.7：效果较低<br>0.7-0.85：效果一般<br>0.85-0.95：效果很好<br>0.95-1：效果非常好</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink Checkpoint机制</title>
      <link href="/2023/07/01/Flink%20Checkpoint%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/07/01/Flink%20Checkpoint%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="checkpoint的过程包含了JobManager和Taskmanager端task的执行过程，按照步骤为"><a href="#checkpoint的过程包含了JobManager和Taskmanager端task的执行过程，按照步骤为" class="headerlink" title="checkpoint的过程包含了JobManager和Taskmanager端task的执行过程，按照步骤为"></a>checkpoint的过程包含了JobManager和Taskmanager端task的执行过程，按照步骤为</h1><ol><li><p>在JobManager端构建ExecutionGraph过程中会创建CheckpointCoordinator，这是负责checkpoint的核心实现类，同时会给job添加一个监听器CheckpointCoordinatorDeActivator（只有设置了checkpoint才会注册这个监听器），在JobManager端开始进行任务调度的时候，会对job的状态进行转换，由CREATED转成RUNNING，job监听器CheckpointCoordinatorDeActivator就开始启动checkpoint的定时任务了，最终会调用CheckpointCoordinator.startCheckpointScheduler()</p></li><li><p>CheckpointCoordinator会部署一个定时任务，用于周期性的触发checkpoint，这个定时任务就是ScheduledTrigger，在触发checkpoint之前先做一遍检查，检查当前正在处理的checkpoint是否超过设置的最大并发checkpoint数量，检查checkpoint的间隔是否达到设置的两次checkpoint的时间间隔，在都没有问题的情况下向所有的source task去触发checkpoint，远程调用TaskManager的triggerCheckpoint()方法</p></li><li><p>TaskManager的triggerCheckpoint()方法首先获取到source task（即SourceStreamTask），调用Task.triggerCheckpointBarrier()，triggerCheckpointBarrier()会异步的去执行一个独立线程，这个线程来负责source task的checkpoint执行。checkpoint的核心实现在StreamTask.performCheckpoint()方法中，该方法主要有三个步骤</p></li></ol><ol><li><p>在checkpoint之前做一些准备工作，通常情况下operator在这个阶段是不做什么操作的</p></li><li><p>立即向下游广播CheckpointBarrier，以便使下游的task能够及时的接收到CheckpointBarrier也开始进行checkpoint的操作</p></li><li><p>开始进行状态的快照，即checkpoint操作。</p></li></ol><p>注意以上操作都是在同步代码块里进行的，获取到的这个lock锁就是用于checkpoint的锁，checkpoint线程和task任务线程用的是同一把锁，在进行performCheckpoint()时，task任务线程是不能够进行数据处理的</p><ol start="4"><li><p>checkpoint的执行过程是一个异步的过程，保证不能因为checkpoint而影响了正常数据流的处理。StreamTask里的每个operator都会创建一个OperatorSnapshotFutures，OperatorSnapshotFutures 里包含了执行operator状态checkpoint的FutureTask，然后由另一个单独的线程异步的来执行这些operator的实际checkpoint操作，就是执行这些FutureTask。这个异步线程叫做AsyncCheckpointRunnable，checkpoint的执行就是将状态数据推送到远程的存储介质中</p></li><li><p>对于非Source Task，checkpoint的标志性开始在接收到上游的CheckpointBarrier，方法在StreamTask中的CheckpointBarrierHandler.getNextNonBlocked()。CheckpointBarrierHandler会根据CheckpointingMode模式不同生成不同的Handler，如果是EXACTLY_ONCE，就会生成BarrierBuffer，会进行barrier对齐，保证数据的一致性，BarrierBuffer中的CachedBufferBlocker是用来缓存barrier对齐时从被阻塞channel接收到的数据。如果CheckpointingMode是AT_LEAST_ONCE，那就会生成BarrierTracker，不会进行barrier对齐，而是继续处理数据，在接收到上游task所有的CheckpointBarrier才开始进程checkpoint，这样就会checkpoint(n)的状态会包含checkpoint(n+1)的数据，数据不一致。非Source Task的checkpoint执行跟步骤3、4是一样的，只不过触发的线程是Task工作线程，跟source task不一样</p></li><li><p>Task在执行完checkpoint后会向JobManager上报checkpoint的元数据信息，JobManager端的CheckpointCoordinator会调用PendingCheckpoint.acknowledgeTask()方法，该方法就是将task上报的元数据信息（checkpoint的路径地址，状态数据大小等等）添加到PendingCheckpoint里</p></li><li><p>task的checkpoint会一直进行到sink task。JobManager如果接收到了全部task上报的的Ack消息，就执行completePendingCheckpoint()，会将checkpoint元数据信息进行持久化，然后通知所有的task进行commit操作，一般来说，task的commit操作其实不需要做什么，但是像那种TwoPhaseCommitSinkFunction，比如FlinkKafkaProducer就会进行一些事物的提交操作等，或者像FlinkKafkaConsumer会进行offset的提交</p></li><li><p>所有task执行完commit操作后（实际上执行的是operator.notifyCheckpointComplete()方法），一个完整的checkpoint流程就完成了</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术规划50问</title>
      <link href="/2023/07/01/%E6%8A%80%E6%9C%AF%E8%A7%84%E5%88%92/"/>
      <url>/2023/07/01/%E6%8A%80%E6%9C%AF%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/tag-bg.jpg" alt="img"></p><ol><li>如何调整技术方向如何平衡技术开发和业务交付精力？</li><li>技术规划应该包括哪些内容？</li><li>   如何做一个业务上能落地而且会落地，而不是高高在上的技术规划</li><li>   技术预研的舍与得如何去平衡（效率&amp;成本&amp;其他等等），开源以及自研技术，有哪些倾向性选择？</li><li>   技术规划如何更能接地气，可持续？</li><li>   技术规划有没有好的方法论或者最佳实践？</li><li>   如何推动技术规划真正落地，实现价值</li><li>   技术规划的出发点是什么？与产品规划如何同步？</li><li>如何合理的制定短期规划和长期规划？</li><li>技术规划如何能做到业界领先，如何能让高层信服，如何能保证高质量落地？</li><li>技术规划有什么机制保障尽可能的落地？</li><li>如何结合业界趋势，做出贴合业务带来收益的实际产品？这中间有没有什么方法论？</li><li>如何看到领域内远期的（3-5）年的技术&#x2F;产品趋势，如何评估是否靠谱&#x2F;能否落地&#x2F;能否产生收益？</li><li>如何让技术规划获得更广泛的支持认可；没有业务，即需要自己拓展业务时，如何做技术规划</li><li>一个优秀技术规划的产出流程一般是什么样子的</li><li>在技术规划中遇到自己不擅长的领域如何规划处理</li><li>如何避免过度设计；如何权衡长短期规划</li><li>越实际的问题就有越明确的技术方案，而技术规划要面临下一个周期提前布局，其中的潜在逻辑是什么。</li><li>技术规划的落地执行往往由于实际需求&#x2F;方向变化会产生变形，如何快速调整，说明意义。</li><li>技术的先进性和成熟度怎么平衡？</li><li>方法论上的东西都知道，但是真正做技术规划的时候，一些长期有价值的技术方向还是很难想出来，这个时候如何办？</li><li>技术规划中，如何加强跨BUBG的协同合作</li><li>技术规划中技术驱动的项目如何与业务发展与指标相匹配，落地节奏怎么安排</li><li>技术方向调整，技术与管理如何选择</li><li>业务成长出现困境，如何更好的突破困境，逆境中发现机会点</li><li>学海无涯，技术精进的道路没有止境，如何平衡工作学习和生活？</li><li>如何兼具技术架构与技术细节把我能力，同时具备产品化的思维方式？</li><li>如何让自己的技术架构能力 cover bg 级别或者一个中小厂的技术团队（目标）</li><li>面临层出不穷的一线新技术问题，关于架构师在保持技术敏感度方面该如何做？</li><li>如何在有限的资源下，增强团队凝聚力和战斗力？</li><li>小组各个同学技术方向不同，如何对其产出进行横向评比？</li><li>如何在日常繁杂的业务中脱身而出，拓展出具有影响力的技术？</li><li>最为技术人员一般都在讲”T”字型发展模式，如何选定一个有价值高回报的方向去深入了解</li><li>技术日行千里，如何保持个人进步的节奏</li><li>以架构师为个人成长目标，如何系统性的制订个人学习计划？平时需关注哪些提升的途径？</li><li>架构师和具体实现间怎么平衡？架构师是否必须要承担部分PM的职责？</li><li>偏后端的基础工程架构，如何能更主动的帮助到业务的发展，以及在业务sense上如何得到成长？</li><li>停留在T7&#x2F;T8级别，难于跨越的这条洪沟是什么？如何跨过呢？</li><li>如何拓宽知识的广度，如果没有实战经验，纯看书看论文理解应该不够深刻</li><li>技术规划的目标定义了，但是找路径的时候不知道怎么做？</li><li>如何设计一个高可用高可扩展的架构？如何能够控制系统复杂度？</li><li>如何结合现有业务做长期三年规划架构师如何在人力紧张或者没有人力的时候快速落地技术规划</li><li>架构师是一个技术岗位，我一直是技术驱动在做人做事。但与其说架构师是在管理技术，不如说是在管理人。管理团队的人与管理团队中的技术，我想明确这是不是两种不同的管理风格，应该如何侧重？</li><li>技术迭代速度快，架构师的视野是否会限制团队的技术演进；是需要架构师时刻紧跟各领域技术趋势，还是可以有机制保证业务技术先进性</li><li>工作中涉及到的业务功能较多时，作为架构师该如何找到技术能力与业务能力之间的平衡点</li><li>如何在涉及到广度的时候，保持敏锐的技术判断力如何能更快速有效的提升自己，抓大放小，以便于进一步优化工作效率。想听听过来人的经验</li><li>T9需要什么标准</li><li>技术规划的长短期价值怎么权衡，比如在人力时间资源上的分配？</li><li>项目复盘怎么做才能更好的帮助技术规划调整？</li><li>作为一个技术leader，如何帮助团队去判断产品方向？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 保证数据一致性</title>
      <link href="/2022/12/01/Flink%20%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/2022/12/01/Flink%20%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>在Flink中，会自动做检查点，用于故障时恢复一个应用。在恢复时，application的state信息可以根据最近完成的检查点进行重建，并继续运行。不过，仅将一个application的state进行重置并不足以满足exactly-once的保证。</p><p>为了给一个应用提供exactly-once保证，在应用根据检查点重置state时，它的每个source connector都应该有能力将它的read position重置到做检查点时的read position。在做一个检查点时，source operator将它的read position也持久化，并在恢复时根据此位置进行重置。对于这类可以重置read position的source connector，比较有代表性的有：</p><p>基于文件的源：可以存储读文件字节流时的偏移量<br>Kakfa：可以存储读入topic partition的偏移量</p><p>如果一个application从一个无法重置read position的source connector读数据，则在故障发生并恢复时，只能提供at-most-once 的保证。</p><p>Flink的检查点与恢复机制、结合可重置reading position的source connector，可以确保一个应用不会丢失任何数据。但是，此应用仍可能输出同一数据两次。因为若是应用故障发生在两次检查点之间，则必定会导致已经成功输出的数据再次输出一次。所以仅通过Flink与source connector的行为，并不足以提供端到端的exactly-once保证，即使application的state具有exactly-once的保证。</p><p>一个application若是需要提供端到端exactly-once 的保证，则需要特殊的sink connectors。对于sink connectors来说，有两种技术可以应用于不同的场景，用于达到exactly-once的保证，分别为：idempotent writes、以transactional writes。</p><h1 id="Idempotent-Writes"><a href="#Idempotent-Writes" class="headerlink" title="Idempotent Writes"></a>Idempotent Writes</h1><p>一个idempotent 操作可被执行多次，但是仅会产生一个变化。例如向一个hashmap中插入同样的key-value pair，这即为一个idempotent操作。因为仅有第一次操作会在hashmap中增加此条目，而之后的插入不会改变hashmap中的内容。一个非 idempotent 操作的例子如追加操作，即使是同样的数据，每次追加都会增加一条数据。在流应用中，idempotent write是一个很有特点的操作，它们可以多次执行，但并不改变最终的结果。所以在Flink根据检查点机制进行恢复时，可以在一定程度上缓解replay对结果造成的影响（或是没有影响）。</p><p>需要注意的是，若是一个应用依赖于idempotent sinks，以达到exactly-once 的结果，则必须保证的是：在replay时覆盖之前写的结果。一般来说，只要流应用在replay时正常执行并输出，在新的输出覆盖掉之前写的结果后，即可以正常到达一致状态。</p><h1 id="Transactional-Writes"><a href="#Transactional-Writes" class="headerlink" title="Transactional Writes"></a>Transactional Writes</h1><p>第二种实现端到端exactly-once 一致性的方法是基于transactional writes。这个方法基于的想法是：仅在最近一个检查点成功完成后，才将所有结果写入到一个外部的sink系统。这个行为可以实现端到端exactly-once的原因是因为：在故障发生时，应用会被重置到最近的检查点，并且在此检查点之后，没有任何结果被写入到外部sink系统。但是此方法会增加延时，因为结果仅能在一个检查点完成后才能看到。</p><p>Flink提供了两种方式分别实现transactional sink connectors – 一个通用的 write-ahead-log（WAL<br>）以及一个two-phase-commit（2PC）sink。WAL sink将所有result records写入应用的state，并在它收到了一个“检查点完成”的通知后，将结果输出到sink 系统。因为WAL sink会将result records缓存到state backend，所以它可以用于任何sink 系统中。然而，使用此方法实现的exactly-once仍会有些代价：增加了应用的state大小，并且sink 系统需要处理突增写入的模式。</p><p>与WAL不同的是，2PC sink需要sink system提供事务支持，或者提供模拟事务的支持。对于每个检查点，sink首先启动一个事务，将所有接收到的记录添加到事务中，并将它们写入sink系统，但是不提交（commit）。当它收到一个“检查点完成”的通知后，它提交事务，并将结果落盘。</p><p>2PC协议集成在Flink的检查点机制中。Checkpoint barriers便是启动一个新事务的通知，所有operators中对于它“自身检查点完成”的通知，即是它们的commit 投票。JobManager的对于“整个检查点完成”的消息，即为提交事务的指示。</p><p>相对于WAL sinks，2PC sinks是基于sink 系统以及sink的实现方式，达到exactly-once的输出保障。而 相对于WAL sink的突增写入模式，2PC sink为持续向sink 系统写入记录。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 数据倾斜优化</title>
      <link href="/2022/12/01/Flink%20%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E4%BC%98%E5%8C%96/"/>
      <url>/2022/12/01/Flink%20%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>当进行聚合运算时（GroupBy&#x2F;KeyBy + Agg），如果聚合所使用的key存在热点，则会导致数据倾斜。如统计某日各个省份的车流量，则负责运算北京、上海等一线城市的count subtask节点则会成为热点，处理数据的压力会比较大。</p><h1 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h1><h2 id="任务卡死"><a href="#任务卡死" class="headerlink" title="任务卡死"></a>任务卡死</h2><p>keyBy 或 rebalance 下游的算子，如果单个 subtask 存在热点并完全卡死，会把整个 Flink 任务卡死。看如下示例：<br>如下图所示，上游每个 Subtask 中会有 3 个 resultSubPartition，连接下游算子的 3 个 subtask。下游每个 subtask 会有 2 个 InputChannel，连接上游算子的 2 个 subtask。Local BufferPool为subtask中的ResultSubpartition&#x2F;InputChannel所共用，在正常运行过程中如果没有反压，所有的 buffer pool 是用不完的。</p><p>一旦subtask B0变成热点，则会引起反压，依次产生如下问题：</p><ol><li>Subtask B0 内的 A0 和 A1 两个 InputChannel 会被占满；Subtask B0 公共的 BufferPool 中可申请到的空间也被占满</li><li>Subtask A0 和 A1 的 B0 ResultSubPartition 被占满；Subtask A0 和 A1 公共的 BufferPool 中可申请到的空间也被占满</li><li>如图2所示，Subtask A0 的主线程会从上游读取数据消费，按照数据的 KeyBy 规则，将数据发送到 B0、B1、B2 三个 ResultSubpartition 中；可以看到，如果 B0 这个ResultSubpartition占满了，且 B0 在公共的 Local BufferPool 中可申请到的空间也被占满。现在有一条数据被keyby后发往B0，但是现在 B0 这个ResultSubpartition 没有空间了，所以主线程就会卡在申请 buffer 上，直到可以再申请到 buffer</li></ol><p>Subtask A0 的主线程被卡住，则不会往下游的任何subtask发送数据了，如图1所示，下游的Subtask B1和Subtask B2不再接收新数据。整个任务处于瘫痪状态</p><h2 id="Checkpoint时间变长"><a href="#Checkpoint时间变长" class="headerlink" title="Checkpoint时间变长"></a>Checkpoint时间变长</h2><p>checkpoint barrier也是一种特殊的数据，如果整个任务中各个可用buffer变少，则checkpoint barrier的传输也会因为找不到可用buffer而降低速度；由于checkpoint barrier的对齐机制，会造成当前checkpoint的barrier迟迟无法对齐，进而超时。</p><h2 id="State变大"><a href="#State变大" class="headerlink" title="State变大"></a>State变大</h2><p>对于有两个以上输入管道的 Operator，存在checkpoint barrier对齐机制，接受到较快的输入管道的 barrier 后，它后面数据会被缓存起来但不处理，直到较慢的输入管道的 barrier 也到达，这些被缓存的数据会被放到state 里面，导致 checkpoint 变大。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><h2 id="修改分区策略"><a href="#修改分区策略" class="headerlink" title="修改分区策略"></a>修改分区策略</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>让不需要shuffle的两个算子间进行shuffle，打乱数据，从而避免数据倾斜</p><h3 id="手段"><a href="#手段" class="headerlink" title="手段"></a>手段</h3><p>在Flink任务提交后，经常可以看到web ui中的一些算子之间采用的分区策略是forward，在该分区策略下很可能会存在数据倾斜现象。如以下情况：<br>某kafka topic统计每个省份的车次，针对每个省份都有一个partition，共计36个partition，同时设有36个source算子，36个flatmap算子。由于source和flatmap满足one-to-one关系，且并行度相同，则Flink默认会采用forward这个分区策略来关联source和flatmap这两个算子。<br>Flink默认设置forward分区策略有两个条件：</p><ol><li>两个算子满足one-to-one关系</li><li>两个算子并行度相同</li></ol><p>此时，北京和上海对应的flatmap算子必然会出现热点数据，由于source到flatmap算子之间并不需要有特定的对应关系，因此可以采用不同的分区策略来将数据打乱，让不同省份的车流数据落到所有的flatmap算子，消除数据倾斜。</p><p>因此，我们只需要破坏forward分区策略的条件即可</p><ol><li>修改两个算子的并行度</li><li>强行设定分区策略：<code>dataStream.rebalance();</code></li></ol><h2 id="两阶段聚合"><a href="#两阶段聚合" class="headerlink" title="两阶段聚合"></a>两阶段聚合</h2><p>所谓两阶段聚合，即在需要shuffle的两个算子之间，再加一层算子</p><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><p>先进行一次聚合，减小算子2和算子3之间的数据量，减轻算子2和算子3之间的热点问题<br>新增新的shuffle，打散算子1和算子2之间的数据，减轻算子1和算子2之间的热点问题</p><h3 id="手段-1"><a href="#手段-1" class="headerlink" title="手段"></a>手段</h3><p>我们以sql的优化作为范例进行讲解，这样更加直观和简洁。DataStream API无非就是仿照sql的group by + agg模式，增加一层keyby + agg。</p><h4 id="修改sql"><a href="#修改sql" class="headerlink" title="修改sql"></a>修改sql</h4><p>有如下需求，按天统计每个类目的成交额</p><pre><code class="sql">SELECT     date_format(ctime, &#39;%Y%m%d&#39;) as cdate, -- 将数据从时间戳格式（2018-12-04 15:44:54），转换为date格式(20181204)       category_id,    sum(price) as category_gmvFROM srcGROUP BY date_format(ctime, &#39;%Y%m%d&#39;), category_id; --按照天做聚合</code></pre><p>以这个SQL为例，其数据流程图如下，一个小方块表示一条成交记录，不同颜色代表不同的category_id<br>Group By + Agg 模式中，SQL作业性能与数据分布非常相关，如果数据中存在数据倾斜，也就是某个key的数据异常的多，那么某个聚合节点就会成为瓶颈，作业就会有明显的反压及延时现象。<br>用两阶段聚合方法优化后的SQL如下：</p><pre><code class="sql">SELECT cdate,category_id,sum(category_gmv_p) as category_gmvFROM(    SELECT         date_format(ctime, &#39;%Y%m%d&#39;) as cdate, -- 将数据从时间戳格式（2018-12-04 15:44:54），转换为date格式(20181204)           category_id,        sum(price) as category_gmv_p    FROM src    GROUP BY category_id, mod(hash_code(FLOOR(RAND(1)*1000), 256),date_format(ctime, &#39;%Y%m%d&#39;); --按照天做聚合)GROUP BY cdate,category_id</code></pre><p>SQL中做了将一个Group By+Agg拆称了两个，子查询里按照category_id和mod(hash_code(FLOOR(RAND(1)*1000), 256)分组，将同一个category_id上的数据打散成了256份，先做一层聚合。外层Group By+Agg，将子查询聚合后的结果再次做聚合。这样通过两层聚合的方式，即可大大缓解某聚合节点拥堵的现象。其数据流程图如下：<br>这种方法达到了两个优化目标，在日期的基础上再将数据分成256份，打散数据，减轻算子1和算子2之间的热点问题；在算子2进行了初步的sum聚合，减小了到达算子3的数据量，减轻了算子2和算子3之间的热点问题。 该方法通过取余的方式将数据进一步打散，另有给key添加随机数的方式进行打散</p><h4 id="Local-Global"><a href="#Local-Global" class="headerlink" title="Local-Global"></a>Local-Global</h4><p>LocalGlobal和PartialFinal其实都属于两阶段聚合，只不过封装了拆解逻辑，我们只需要对Flink SQL任务做简单的配置即可。</p><p>LocalGlobal优化可以用来解决聚合时的数据倾斜问题。其核心思想是，将聚合分为两个阶段执行，先在上游进行局部(本地&#x2F;Local)聚合，再在下游进行全局(Global)聚合，类似MapReduce的Combine + Reduce，即先进行一个本地Reduce，再进行全局Reduce。该方法，只完成了先进行一次聚合，减少数据量这个目标<br>以如下场景为例</p><pre><code class="sql">SELECT color, sum(id)FROM TGROUP BY color</code></pre><p>开启LocalGlobal：</p><pre><code class="java">TableEnvironment tEnv = ...Configuration configuration = tEnv.getConfig().getConfiguration();// 要使用LocalGlobal优化，需要先开启MiniBatch configuration.setString(&quot;table.exec.mini-batch.enabled&quot;, &quot;true&quot;); configuration.setString(&quot;table.exec.mini-batch.allow-latency&quot;, &quot;5 s&quot;);configuration.setString(&quot;table.exec.mini-batch.size&quot;, &quot;5000&quot;);// 开启LocalGlobalconfiguration.setString(&quot;table.optimizer.agg-phase-strategy&quot;, &quot;TWO_PHASE&quot;);</code></pre><h4 id="Partial-Final"><a href="#Partial-Final" class="headerlink" title="Partial-Final"></a>Partial-Final</h4><p>LocalGlobal优化针对普通聚合（例如SUM、COUNT、MAX、MIN和AVG）有较好的效果，对于COUNT DISTINCT收效不明显，因为COUNT DISTINCT在Local聚合时，对于DISTINCT KEY的去重率不高，导致在Global节点仍然存在热点<br>如下场景，统计一天的UV</p><pre><code class="sql">SELECT day, COUNT(DISTINCT user_id)FROM TGROUP BY day</code></pre><p>如果user_id比较稀疏，即便开启了LocalGlobal优化，收效也并不明显，因为COUNT DISTINCT在Local阶段时，去重率并不高，这就导致在Global阶段仍然存在热点问题。不满足第一条目标和第二条目标。<br>为了解决这一问题，需要将原始聚合拆分成两层聚合:</p><pre><code class="sql">SELECT day, SUM(cnt)FROM (    SELECT day, COUNT(DISTINCT user_id) as cnt    FROM T    GROUP BY day, MOD(HASH_CODE(user_id), 1024))GROUP BY day</code></pre><p>现在Blink Planner提供了PartialFinal功能，无需自己拆解sql，只要简单的配置即可，配置如下：</p><pre><code class="java">TableEnvironment tEnv = ...Configuration configuration = tEnv.getConfig().getConfiguration();// 开启MiniBatch configuration.setString(&quot;table.exec.mini-batch.enabled&quot;, &quot;true&quot;); configuration.setString(&quot;table.exec.mini-batch.allow-latency&quot;, &quot;5 s&quot;);configuration.setString(&quot;table.exec.mini-batch.size&quot;, &quot;5000&quot;);// 开启LocalGlobalconfiguration.setString(&quot;table.optimizer.agg-phase-strategy&quot;, &quot;TWO_PHASE&quot;);// 开启Split Distinctconfiguration.setString(&quot;table.optimizer.distinct-agg.split.enabled&quot;, &quot;true&quot;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程常见问题</title>
      <link href="/2022/11/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2022/11/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="线程的状态有哪些？"><a href="#线程的状态有哪些？" class="headerlink" title="线程的状态有哪些？"></a>线程的状态有哪些？</h1><p>线程的生命周期大致分为5个阶段：<br>NEW（新建）：新建一个Thread对象时，此时还没有线程。<br>RUNNABLE（就绪）：调用start方法可以使线程进入就绪状态。<br>RUNNING（运行）：处于就绪状态的线程获得了CPU就可以执行业务，进入运行状态。<br>BLOCKED（阻塞）：处于运行状态的线程如果调用了sleep、wait方法或者竞争锁失败会进入阻塞状态。<br>TERMINATED（终止）：线程正常结束或者意外终止会进入终止状态。<br>线程的生命周期是比较基础的知识，一般是作为一个切入点有浅入深的问其他问题，在回答这个问题的时候不要干巴巴的只说5个状态单词，要把每个状态是怎么进入的也要讲一下。你如果不讲，面试官就会继续追问：那线程在哪些情况会进入阻塞状态呢？</p><h1 id="synchronized锁的升级机制"><a href="#synchronized锁的升级机制" class="headerlink" title="synchronized锁的升级机制"></a>synchronized锁的升级机制</h1><p>synchronized是JVM关键字，可以用来修饰代码块、方法（普通方法和静态方法），它是一个可重入的不可打断的锁。<br>线程竞争synchronized锁其实是对锁对象monitor的竞争，代码块是Object锁对象的monitor，方法是this monitor，静态方法是class monitor。<br>锁的升级机制：<br>synchronized在JDK1.5时锁竞争失败后会直接进入阻塞状态，线程上下文之间切换比较消耗CPU性能，在JDK1.5之后对锁进行了优化，引入了无锁，偏向锁，轻量级锁和重量锁。锁的升级过程即是无锁状态到重量级锁状态的变化过程。<br>锁对象头（Mark Word）有一个偏向标志，无锁状态时为0，当线程获取到锁时会把偏向标志修改为1，并且CAS把对象头中的线程ID修改为自己的线程ID，当下一个线程竞争锁时，发现偏向标志为1，且锁还未释放，则会复制对象头的信息到自己线程的Lock Record中，并且CAS修改对象头中的指针指向自己的LR，如果修改失败则自旋一定次数后（默认10次）升级为重量级锁，此时竞争失败的线程将会挂起。</p><h1 id="synchronized和lock的区别？"><a href="#synchronized和lock的区别？" class="headerlink" title="synchronized和lock的区别？"></a>synchronized和lock的区别？</h1><p>特点：synchronized是独占可重入锁，是非公平的竞争锁方式。ReentrantLock也是独占可重入锁，但是其可以指定为公平锁，默认是非公平锁。<br>用法：synchronized可以修饰方法和代码块，不需要显示的加锁和解锁。ReentrantLock修饰代码块，在lock()和unlock()方法中间的代码都是同步代码，需要显示的加锁和解锁，将锁的控制权交给了开发人员。<br>性能：基于JVM对关键字的支持，单线程下synchronized关键字性能要优于ReentrantLock，但是多线程环境下ReentrantLock性能优于synchronized。<br>高级特性：获取synchronized锁失败的线程会一直阻塞直到获取到锁，不能中断。ReentrantLock提供了可中断获取锁的方法lockInterruptibly()，而且还提供了获取锁失败不阻塞立即返回的方法tryLock()，如果开发场景中涉及到了高级应用，那就只能选择显示锁Lock了。</p><h1 id="两种锁的使用场景？"><a href="#两种锁的使用场景？" class="headerlink" title="两种锁的使用场景？"></a>两种锁的使用场景？</h1><p>在多数情况下会优先选择synchronized关键字，在必须要用到高级特性的时候选择Lock锁。另外一点就是要注意synchronized锁升级的不可逆性，并发量谷峰值差别较大的时候优先选择Lock锁。</p><h1 id="开发中你是怎么创建线程的？"><a href="#开发中你是怎么创建线程的？" class="headerlink" title="开发中你是怎么创建线程的？"></a>开发中你是怎么创建线程的？</h1><p>有4种创建方式，通常使用线程池的方式管理线程，并且线程的参数都是可配置的。</p><h1 id="线程池的参数有哪些？"><a href="#线程池的参数有哪些？" class="headerlink" title="线程池的参数有哪些？"></a>线程池的参数有哪些？</h1><p>corePoolSize：核心线程数量，即使线程池中的线程空闲也会一直保持此数量的线程，除非设置了allowCoreThreadTimeOut为true。<br>maximumPoolSize：线程池中允许的最大线程数量。<br>keepAliveTime：当线程池中的线程数量超过了核心线程的数量，在回收空闲的线程时线程将等待任务的最大时间，超过这个时间还没有任务执行，那么线程将会被回收。<br>unit：超过核心线程数量的线程空闲时等待任务的时间单位。<br>workQueue：用于存放提交任务的工作队列，这个队列只存放提交但是未执行的Runnable。<br>threadFactory：创建线程的工厂。<br>handler：当线程数量和队列元素都达到最大时，拒绝再次提交任务的策略。</p><h1 id="线程池的拒绝策略有哪些？开发中你是怎么选择的？"><a href="#线程池的拒绝策略有哪些？开发中你是怎么选择的？" class="headerlink" title="线程池的拒绝策略有哪些？开发中你是怎么选择的？"></a>线程池的拒绝策略有哪些？开发中你是怎么选择的？</h1><p>拒绝策略有4种：直接丢弃，丢弃队列中第一个任务，抛出异常，调用者执行。<br>前两个开发中一般较少选择，因为不可控。开发中勾勾用过后面两种：抛出异常捕获了记录日志。让主线程去执行保证任务一定被运行。</p><h1 id="开发中使用多线程要注意什么？"><a href="#开发中使用多线程要注意什么？" class="headerlink" title="开发中使用多线程要注意什么？"></a>开发中使用多线程要注意什么？</h1><p>避免死锁</p><h1 id="什么情况下会发生死锁？"><a href="#什么情况下会发生死锁？" class="headerlink" title="什么情况下会发生死锁？"></a>什么情况下会发生死锁？</h1><p>交叉锁互相等待肯定会死锁，还有比如内存不足导致线程无法执行，死循环导致的锁无法释放，显示锁开发人员忘记释放锁也会导致死锁。<br>问到这里可能面试官真的就多嘴一问：你们项目中遇到过死锁的情况吗，线上是怎么排查的？</p><h1 id="什么是乐观锁和悲观锁？"><a href="#什么是乐观锁和悲观锁？" class="headerlink" title="什么是乐观锁和悲观锁？"></a>什么是乐观锁和悲观锁？</h1><p>乐观锁和悲观锁都是一种思想，有对应的实现。乐观锁主要用于多读的场所，悲观锁主要用于多写的场所。<br>悲观锁：在修改数据之前先加锁，再对数据进行修改的加锁方式。在数据修改的整个过程中都会加锁。悲观锁又分为读锁和写锁。<br>乐观锁：在修改数据前不需要加锁，只有在对数据进行修改的时候才会进行检测。可以利用CAS实现乐观锁。<br>CAS比较并交换，但是会出现ABA的问题，如果不能接受ABA那么在比较的时候可以添加版本号。</p><h1 id="volatile关键字的作用？"><a href="#volatile关键字的作用？" class="headerlink" title="volatile关键字的作用？"></a>volatile关键字的作用？</h1><p>volatile关键字是一个轻量级锁，它可以保证可见性和有序性，但是不能保证原子性。<br>此时面试官可能会问：它是如何保证可见性和有序性的，为什么不能保证原子性？<br>读volatile修饰的变量时，会从主内存中取数据，然后在线程的工作内存中创建变量副本。写volatile修饰的变量时，会对总线lock加锁，此时其他CPU都不能访问到这个变量，当线程将修改后的数据写入主内存并通知其他CPU的数据失效后，对总线解锁。其他线程在后续的过程中因为变量失效不得不从主内存再次获取数据，从而保证了可见性。<br>有序性就是通过内存屏障实现的。</p><h1 id="ThreadLocal原理是什么？"><a href="#ThreadLocal原理是什么？" class="headerlink" title="ThreadLocal原理是什么？"></a>ThreadLocal原理是什么？</h1><p>ThreadLocal可以实现线程之间的分离，ThreadLocal修饰的变量，每个线程都会复制一份，因此常用来修饰静态变量。ThreadLocal内部维护了Entry数组，其中key是当前线程，Value是用户存入的变量。<br>ThreadLocal内部类Entry继承了弱引用，key是weak的引用，一旦GC不管内存是否充足都会被回收，但是value是强引用，会存在null的key指向value，因而造成内存泄漏。因此使用结束需要手动的remove，避免内存泄漏。</p><h1 id="AQS的原理是什么？"><a href="#AQS的原理是什么？" class="headerlink" title="AQS的原理是什么？"></a>AQS的原理是什么？</h1><p>AQS是JUC工具类的核心，它内部维护了volatile的状态变量state，锁的竞争即是对state的竞争，竞争失败的线程会加入阻塞队列，它是一个先进先出的队列。AQS提供了不同的获取锁和释放锁的操作，包括独占模式（公平和非公平的获取锁方式），共享模式，条件等待模式。线程的node节点对象维护了4个状态：CANCLLED、SIGNAL、CONDITION、PROPAGATE ，决定了线程是否需要挂起和唤醒。</p><h1 id="CountDownLatch和CyclicBarrier的区别"><a href="#CountDownLatch和CyclicBarrier的区别" class="headerlink" title="CountDownLatch和CyclicBarrier的区别"></a>CountDownLatch和CyclicBarrier的区别</h1><ol><li>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset()</li><li>方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次</li><li>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。比如以下代码执行完之后会返回true</li><li>CountDownLatch会阻塞主线程，CyclicBarrier不会阻塞主线程，只会阻塞子线程。某线程中断CyclicBarrier会抛出异常，避免了所有线程无限等待</li></ol><h1 id="场景：如何实现三个线程顺序执行？"><a href="#场景：如何实现三个线程顺序执行？" class="headerlink" title="场景：如何实现三个线程顺序执行？"></a>场景：如何实现三个线程顺序执行？</h1><p>AQS实现类的用法一般都是给你描述个场景问你如何实现，比如题目的线程顺序执行，还有一个线程等待多个线程该如何实现，一个系统最多只能100个人登录如何实现？<br>就是想看看你是否了解Condition、CountDownLatch、CyclicBarrier、Semaphore的用法。<br>Condition只能由Lock锁创建，一般适用于两个线程之间的等待。<br>CountDownLatch是AQS共享模式的实现，state状态值表示计数器，await方法会使线程进入阻塞状态直到其他线程调用countdown方法将计数器减为0，CountDownLatch适用于一对多等待的场景。<br>CyclicBarrier常用来与CountDownLatch作比较，它也可以实现CountDownLatch一对多的等待，CyclicBarrier是一个栅栏，初始化指定屏障个数，所有的线程都到达屏障之后才可以继续执行，会使线程阻塞，且其可以重复使用。<br>Semaphore是许可证，常用来限制访问的数量，也是AQS共享模式的实现，state状态值用来表示许可证的数量。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库使用规范</title>
      <link href="/2022/10/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
      <url>/2022/10/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>单表索引利用率不高，部分为单字段索引，同时未避免索引失效</li><li>部分表单表数据过多，未进行及时拆表</li><li>索引建立未避过业务高峰时间</li><li>单次查询数据较多，未对数据量做限制</li><li>慢查询大多数集中在统计或分页场景下，具体原因在于扫描行数过多引起</li></ul><h1 id="后期规范"><a href="#后期规范" class="headerlink" title="后期规范"></a>后期规范</h1><h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><ul><li><strong>[强制]</strong> 数据库表、字段必须增加中文注释，字符编码集采用utf8mb4</li><li><strong>[强制]</strong> 数据库字段必须为非空，设置默认值</li><li><strong>[强制]</strong> 单表列数目不可超过25个，若超过则应考虑拆表存储</li><li>建议优先选择符合存储需求的最小数据类型，如unsigned无符号整型、char替换固定长度的varchar</li><li>避免使用TEXT、BLOB数据类型</li></ul><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><ul><li><strong>[强制]</strong> 查询数据必须限制数量级，不可频繁拉取大量数据；若业务需求，建议添加缓存层，以及相应的缓存更新机制</li><li><strong>[强制]</strong> 查询时指定所需的列，读取过多不需要的列会增加数据库的CPU、IO消耗，同时不能有效利用联合索引</li><li><strong>[强制]</strong> 对于分页场景需求，不推荐基于limit实现分页，容易触发深度分页；可根据主键id或其他自增字段实现查询分页</li><li>查询时应注意数据字段类型，避免隐式类型转换，从而导致无法利用索引的问题</li><li>查询时遵循索引最左匹配原则，避免索引失效情况，如：左模糊查询%like%、函数处理等；</li><li>建议单表数据量级不超过3000万，如查询过于复杂的表应考虑水平拆表</li><li>避免使用子查询，可把子查询优化为连表查询</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li><strong>[强制]</strong> 数据库表索引变更时，需在业务查询不频繁的时间进行，严禁在业务繁忙时进行索引变更</li><li><strong>[强制]</strong> 单表索引数量不超过8个，单个索引字段不超过5个，核心SQL优先考虑联合索引</li><li>索引顺序：1.区分度最高的字段放在索引左侧；2.查询频率高的字段放在索引左侧；3.字段长度小的字段放在索引左侧；</li><li>避免在更新比较频繁、区分度较小的列上单独建立索引</li><li>where条件使用范围查询时，索引最多用于一个范围条件，超过则不再使用索引</li><li>在较长的varchar字段上使用索引时，建议指定索引长度 </li><li>部分查询场景有排序需求时，order by字段需同样注意索引顺序，否则会出现慢查询；可通过explain查看sql执行计划，选取合适的字段或增加索引来满足排序需求</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程间通信</title>
      <link href="/2022/10/01/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2022/10/01/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="线程间通信常见问题"><a href="#线程间通信常见问题" class="headerlink" title="线程间通信常见问题"></a>线程间通信常见问题</h1><ol><li>三个线程分别打印 A，B，C，要求这三个线程一起运行，打印 n 次，输出形如“ABCABCABC…”</li><li>两个线程交替打印 0~100 的奇偶数</li><li>通过 N 个线程顺序循环打印从 0 至 100</li><li>多线程按顺序调用，A-&gt;B-&gt;C，AA 打印 5 次，BB 打印10 次，CC 打印 15 次，重复 10 次</li><li>用两个线程，一个输出字母，一个输出数字，交替输出 1A2B3C4D…26Z</li></ol><h2 id="Lock解法-第一题"><a href="#Lock解法-第一题" class="headerlink" title="Lock解法 第一题"></a>Lock解法 第一题</h2><pre><code class="java">import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class PrintABCUsingLock &#123;    private int times; // 控制打印次数    private int state;   // 当前状态值：保证三个线程之间交替打印    private Lock lock = new ReentrantLock();    public PrintABCUsingLock(int times) &#123;        this.times = times;    &#125;    private void printLetter(String name, int targetNum) &#123;        for (int i = 0; i  &lt; times;)&#123;             lock.lock();             if (state % 3 == targetNum) &#123;                 state++;                 i++;                 System.out.print(name);            &#125;            lock.unlock();        &#125;&#125;    public static void main(String[] args) &#123;        //顺序打印10次        PrintABCUsingLock loopThread = new PrintABCUsingLock(10);        new Thread(() -&gt; &#123;            loopThread.printLetter(&quot;A&quot;, 0);        &#125;, &quot;A&quot;).start();        new Thread(() -&gt; &#123;            loopThread.printLetter(&quot;B&quot;, 1);        &#125;, &quot;B&quot;).start();                new Thread(() -&gt; &#123;            loopThread.printLetter(&quot;C&quot;, 2);        &#125;, &quot;C&quot;).start();    &#125;&#125;</code></pre><h2 id="wait-notify解法-第一题"><a href="#wait-notify解法-第一题" class="headerlink" title="wait&#x2F;notify解法 第一题"></a>wait&#x2F;notify解法 第一题</h2><pre><code class="java">public class PrintABCUsingWaitNotify &#123;    private int state;    private int times;    private static final Object LOCK = new Object();    public PrintABCUsingWaitNotify(int times) &#123;        this.times = times;    &#125;    private void printLetter(String name, int targetState) &#123;        for (int i = 0; i &lt; times; i++)            synchronized (LOCK) &#123;                while (state % 3 != targetState) &#123;                try &#123;                    LOCK.wait();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            state++;            System.out.print(name);            LOCK.notifyAll();        &#125;    &#125;    public static void main(String[] args) &#123;        PrintABCUsingWaitNotify printABC = new PrintABCUsingWaitNotify(10);        new Thread(() -&gt; &#123;            printABC.printLetter(&quot;A&quot;, 0);        &#125;, &quot;A&quot;).start();        new Thread(() -&gt; &#123;            printABC.printLetter(&quot;B&quot;, 1);        &#125;, &quot;B&quot;).start();        new Thread(() -&gt; &#123;            printABC.printLetter(&quot;C&quot;, 2);        &#125;, &quot;C&quot;).start();    &#125;&#125;</code></pre><h2 id="wait-notify解法-第二题"><a href="#wait-notify解法-第二题" class="headerlink" title="wait&#x2F;notify解法 第二题"></a>wait&#x2F;notify解法 第二题</h2><pre><code class="java">package cn.wideth.util.thread;public class OddEvenPrinter &#123;    private Object monitor = new Object();    private final int limit;    private volatile int count;    OddEvenPrinter(int initCount, int times) &#123;        this.count = initCount;        this.limit = times;    &#125;    private void print() &#123;        synchronized (monitor) &#123;            while (count &lt; limit)&#123;            try &#123;                System.out.println(String.format(&quot;线程[%s]打印数字:%d&quot;, Thread.currentThread().getName(), ++count));                monitor.notifyAll();                monitor.wait();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        //防止有子线程被阻塞未被唤醒，导致主线程不退出        monitor.notifyAll();      &#125;   &#125;    public static void main(String[] args) &#123;        OddEvenPrinter printer = new OddEvenPrinter(0, 10);        new Thread(printer::print, &quot;odd&quot;).start();        new Thread(printer::print, &quot;even&quot;).start();    &#125;&#125;</code></pre><h2 id="wait-notify解法-第五题"><a href="#wait-notify解法-第五题" class="headerlink" title="wait&#x2F;notify解法 第五题"></a>wait&#x2F;notify解法 第五题</h2><pre><code class="java">package cn.wideth.util.thread;public class NumAndLetterPrinter &#123;    private static char c = &#39;A&#39;;    private static int i = 0;    static final Object lock = new Object();    public static void main(String[] args) &#123;        new Thread(() -&gt; printer(), &quot;numThread&quot;).start();        new Thread(() -&gt; printer(), &quot;letterThread&quot;).start();    &#125;    private static void printer() &#123;        synchronized (lock) &#123;            for (int i = 0; i &lt; 26; i++) &#123;                if (Thread.currentThread().getName() == &quot;numThread&quot;) &#123;                    //打印数字1-26                    System.out.print((i + 1));                    // 唤醒其他在等待的线程                    lock.notifyAll();                    try &#123;                        // 让当前线程释放锁资源，进入wait状态                        lock.wait();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125; else if (Thread.currentThread().getName() == &quot;letterThread&quot;) &#123;                    // 打印字母A-Z                    System.out.print((char) (&#39;A&#39; + i));                    // 唤醒其他在等待的线程                    lock.notifyAll();                    try &#123;                        // 让当前线程释放锁资源，进入wait状态                        lock.wait();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;            lock.notifyAll();        &#125;    &#125;&#125;</code></pre><h2 id="Condition解法-第一题"><a href="#Condition解法-第一题" class="headerlink" title="Condition解法 第一题"></a>Condition解法 第一题</h2><pre><code class="java">package cn.wideth.util.thread;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class PrintABCUsingLockCondition &#123;    private int times;    private int state;    private static Lock lock = new ReentrantLock();    private static Condition c1 = lock.newCondition();    private static Condition c2 = lock.newCondition();    private static Condition c3 = lock.newCondition();    public PrintABCUsingLockCondition(int times) &#123;        this.times = times;    &#125;    public static void main(String[] args) &#123;        PrintABCUsingLockCondition print = new PrintABCUsingLockCondition(10);        new Thread(() -&gt; &#123;            print.printLetter(&quot;A&quot;, 0, c1, c2);        &#125;, &quot;A&quot;).start();        new Thread(() -&gt; &#123;            print.printLetter(&quot;B&quot;, 1, c2, c3);        &#125;, &quot;B&quot;).start();        new Thread(() -&gt; &#123;            print.printLetter(&quot;C&quot;, 2, c3, c1);        &#125;, &quot;C&quot;).start();    &#125;    private void printLetter(String name, int targetState, Condition current, Condition next) &#123;        for (int i = 0; i &lt; times;)&#123;            lock.lock();            try &#123;               while (state % 3 != targetState) &#123;                  current.await();               &#125;            state++;            i++;            System.out.print(name);            next.signal();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;      &#125;   &#125;&#125;</code></pre><h2 id="Semaphore解法-第一题"><a href="#Semaphore解法-第一题" class="headerlink" title="Semaphore解法 第一题"></a>Semaphore解法 第一题</h2><pre><code class="java">import java.util.concurrent.Semaphore;public class PrintABCUsingSemaphore &#123;    public static void main(String[] args) &#123;        // 初始化许可数为1，A线程可以先执行        Semaphore semaphoreA = new Semaphore(1);        // 初始化许可数为0，B线程阻塞        Semaphore semaphoreB = new Semaphore(0);        // 初始化许可数为0，C线程阻塞        Semaphore semaphoreC = new Semaphore(0);        new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 10; i++) &#123;                try &#123;                    // A线程获得许可，同时semaphoreA的许可数减为0,进入下一次循环时                    // A线程会阻塞，知道其他线程执行semaphoreA.release();                    semaphoreA.acquire();                    // 打印当前线程名称                    System.out.print(Thread.currentThread().getName());                    // semaphoreB许可数加1                    semaphoreB.release();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;, &quot;A&quot;).start();        new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 10; i++) &#123;                try &#123;                    semaphoreB.acquire();                    System.out.print(Thread.currentThread().getName());                    semaphoreC.release();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;, &quot;B&quot;).start();        new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 10; i++) &#123;                try &#123;                    semaphoreC.acquire();                    System.out.print(Thread.currentThread().getName());                    semaphoreA.release();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;, &quot;C&quot;).start();    &#125;&#125;</code></pre><h2 id="Semaphore解法-第三题"><a href="#Semaphore解法-第三题" class="headerlink" title="Semaphore解法 第三题"></a>Semaphore解法 第三题</h2><pre><code class="java">public class LoopPrinter &#123;    //线程个数    private final static int THREAD_COUNT = 3;    private static int result = 0;    //最大数字    private static int maxNum = 10;    public static void main(String[] args) throws InterruptedException &#123;        final Semaphore[] semaphores = new Semaphore[THREAD_COUNT];        for (int i = 0; i  &lt; THREAD_COUNT; i++)&#123;           //非公平信号量，每个信号量初始计数都为1            semaphores[i] = new Semaphore(1);            if (i != THREAD_COUNT - 1) &#123;               //  System.out.println(i+&quot;===&quot;+semaphores[i].getQueueLength());               //获取一个许可前线程将一直阻塞, for 循环之后只有 syncObjects[2] 没有被阻塞                 semaphores[i].acquire();            &#125;        &#125;        for (int i = 0; i  &lt; THREAD_COUNT; i++)&#123;          // 初次执行，上一个信号量是 syncObjects[2]            final Semaphore lastSemphore = i == 0 ? semaphores[THREAD_COUNT - 1] : semaphores[i - 1];            final Semaphore currentSemphore = semaphores[i];            final int index = i;            new Thread(() -&gt; &#123;            try &#123;             while (true) &#123;                // 初次执行，让第一个 for 循环没有阻塞的 syncObjects[2] 先获得令牌阻塞了                lastSemphore.acquire();                System.out.println(&quot;thread&quot; + index + &quot;: &quot; + result++);                if (result &gt; maxNum) &#123;                    System.exit(0);                &#125;                // 释放当前的信号量，syncObjects[0] 信号量此时为 1，下次 for 循环中上一个信号量即为syncObjects[0]                currentSemphore.release();             &#125;         &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        &#125;).start();       &#125;    &#125;&#125;</code></pre><h2 id="LockSupport解法-第一题"><a href="#LockSupport解法-第一题" class="headerlink" title="LockSupport解法 第一题"></a>LockSupport解法 第一题</h2><pre><code class="java">import java.util.concurrent.locks.LockSupport;public class PrintABCUsingLockSupport &#123;    private static Thread threadA, threadB, threadC;    public static void main(String[] args) &#123;        threadA = new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 10; i++) &#123;                // 打印当前线程名称                System.out.print(Thread.currentThread().getName());                // 唤醒下一个线程                LockSupport.unpark(threadB);                // 当前线程阻塞                LockSupport.park();            &#125;        &#125;, &quot;A&quot;);        threadB = new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 10; i++) &#123;                // 先阻塞等待被唤醒                LockSupport.park();                System.out.print(Thread.currentThread().getName());                // 唤醒下一个线程                LockSupport.unpark(threadC);            &#125;        &#125;, &quot;B&quot;);        threadC = new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 10; i++) &#123;                // 先阻塞等待被唤醒                LockSupport.park();                System.out.print(Thread.currentThread().getName());                // 唤醒下一个线程                LockSupport.unpark(threadA);            &#125;        &#125;, &quot;C&quot;);        threadA.start();        threadB.start();        threadC.start();    &#125;&#125;</code></pre><h2 id="LockSupport解法-第五题"><a href="#LockSupport解法-第五题" class="headerlink" title="LockSupport解法 第五题"></a>LockSupport解法 第五题</h2><pre><code class="java">import java.util.concurrent.locks.LockSupport;public class NumAndLetterPrinterByLockSupport &#123;    private static Thread numThread, letterThread;    public static void main(String[] args) &#123;        letterThread = new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 26; i++) &#123;                System.out.print((char) (&#39;A&#39; + i));                LockSupport.unpark(numThread);                LockSupport.park();            &#125;        &#125;, &quot;letterThread&quot;);        numThread = new Thread(() -&gt; &#123;            for (int i = 1; i &lt;= 26; i++) &#123;                System.out.print(i);                LockSupport.park();                LockSupport.unpark(letterThread);            &#125;        &#125;, &quot;numThread&quot;);        numThread.start();        letterThread.start();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盛最多水的容器</title>
      <link href="/2022/09/01/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>/2022/09/01/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><pre><code class="java">    public int maxArea(int[] height) &#123;        int i = 0, j = height.length - 1, res = 0;        while(i &lt; j) &#123;            res = height[i] &lt; height[j] ?                 Math.max(res, (j - i) * height[i++]):                 Math.max(res, (j - i) * height[j--]);         &#125;        return res;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接雨水</title>
      <link href="/2022/08/01/%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
      <url>/2022/08/01/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p>输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><pre><code class="java">public int trap(int[] height) &#123;    int left = 0, right = height.length - 1;    int ans = 0;    int left_max = 0, right_max = 0;    while (left &lt; right) &#123;        if (height[left] &lt; height[right]) &#123;            if (height[left] &gt;= left_max) &#123;                left_max = height[left];            &#125; else &#123;                ans += (left_max - height[left]);            &#125;            ++left;        &#125; else &#123;            if (height[right] &gt;= right_max) &#123;                right_max = height[right];            &#125; else &#123;                ans += (right_max - height[right]);            &#125;            --right;        &#125;    &#125;    return ans;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
