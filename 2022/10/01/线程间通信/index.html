<!DOCTYPE html><html class="appearance-light" lang="zh-CN"><head><meta charset="UTF-8"><title>线程间通信</title><meta name="description" content="数学是上帝用来书写宇宙的文字"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="线程间通信常见问题
三个线程分别打印 A，B，C，要求这三个线程一起运行，打印 n 次，输出形如“ABCABCABC…”
两个线程交替打印 0~100 的奇偶数
通过 N 个线程顺序循环打印从 0 至 100
多线程按顺序调用，A-&amp;gt;B-&amp;gt;C，AA 打印 5 次，BB 打印10 次，CC 打印 15 次，重复 10 次
用两个线程，一个输出字母，一个输出数字，交替输出 1A2B3C4D…26Z

Lock解法 第一题import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class PrintABCUsingLock &amp;#123;

    private i.."><meta name="generator" content="Hexo 6.3.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Cygnus Dark's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">线程间通信</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">博客</a></h3><h3 class="is-inline-block"><a href="/about">个人简介</a></h3><h3 class="is-inline-block"><a href="/archives">文章</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">博客</a></h3><h3 class="is-inline-block"><a href="/about">个人简介</a></h3><h3 class="is-inline-block"><a href="/archives">文章</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-text">线程间通信常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock%E8%A7%A3%E6%B3%95-%E7%AC%AC%E4%B8%80%E9%A2%98"><span class="toc-text">Lock解法 第一题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wait-notify%E8%A7%A3%E6%B3%95-%E7%AC%AC%E4%B8%80%E9%A2%98"><span class="toc-text">wait&#x2F;notify解法 第一题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wait-notify%E8%A7%A3%E6%B3%95-%E7%AC%AC%E4%BA%8C%E9%A2%98"><span class="toc-text">wait&#x2F;notify解法 第二题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wait-notify%E8%A7%A3%E6%B3%95-%E7%AC%AC%E4%BA%94%E9%A2%98"><span class="toc-text">wait&#x2F;notify解法 第五题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Condition%E8%A7%A3%E6%B3%95-%E7%AC%AC%E4%B8%80%E9%A2%98"><span class="toc-text">Condition解法 第一题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semaphore%E8%A7%A3%E6%B3%95-%E7%AC%AC%E4%B8%80%E9%A2%98"><span class="toc-text">Semaphore解法 第一题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semaphore%E8%A7%A3%E6%B3%95-%E7%AC%AC%E4%B8%89%E9%A2%98"><span class="toc-text">Semaphore解法 第三题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LockSupport%E8%A7%A3%E6%B3%95-%E7%AC%AC%E4%B8%80%E9%A2%98"><span class="toc-text">LockSupport解法 第一题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LockSupport%E8%A7%A3%E6%B3%95-%E7%AC%AC%E4%BA%94%E9%A2%98"><span class="toc-text">LockSupport解法 第五题</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B"><i class="tag post-item-tag">多线程</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">线程间通信</h1><time class="has-text-grey" datetime="2022-10-01T00:00:00.000Z">2022-10-01</time><article class="mt-2 post-content"><h1 id="线程间通信常见问题"><a href="#线程间通信常见问题" class="headerlink" title="线程间通信常见问题"></a>线程间通信常见问题</h1><ol>
<li>三个线程分别打印 A，B，C，要求这三个线程一起运行，打印 n 次，输出形如“ABCABCABC…”</li>
<li>两个线程交替打印 0~100 的奇偶数</li>
<li>通过 N 个线程顺序循环打印从 0 至 100</li>
<li>多线程按顺序调用，A-&gt;B-&gt;C，AA 打印 5 次，BB 打印10 次，CC 打印 15 次，重复 10 次</li>
<li>用两个线程，一个输出字母，一个输出数字，交替输出 1A2B3C4D…26Z</li>
</ol>
<h2 id="Lock解法-第一题"><a href="#Lock解法-第一题" class="headerlink" title="Lock解法 第一题"></a>Lock解法 第一题</h2><pre><code class="java">import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class PrintABCUsingLock &#123;

    private int times; // 控制打印次数
    private int state;   // 当前状态值：保证三个线程之间交替打印
    private Lock lock = new ReentrantLock();

    public PrintABCUsingLock(int times) &#123;
        this.times = times;
    &#125;

    private void printLetter(String name, int targetNum) &#123;

        for (int i = 0; i  &lt; times;)&#123;
             lock.lock();
             if (state % 3 == targetNum) &#123;
                 state++;
                 i++;
                 System.out.print(name);
            &#125;
            lock.unlock();
        &#125;
&#125;

    public static void main(String[] args) &#123;

        //顺序打印10次
        PrintABCUsingLock loopThread = new PrintABCUsingLock(10);

        new Thread(() -&gt; &#123;
            loopThread.printLetter(&quot;A&quot;, 0);
        &#125;, &quot;A&quot;).start();

        new Thread(() -&gt; &#123;
            loopThread.printLetter(&quot;B&quot;, 1);
        &#125;, &quot;B&quot;).start();
        
        new Thread(() -&gt; &#123;
            loopThread.printLetter(&quot;C&quot;, 2);
        &#125;, &quot;C&quot;).start();
    &#125;

&#125;
</code></pre>
<h2 id="wait-notify解法-第一题"><a href="#wait-notify解法-第一题" class="headerlink" title="wait&#x2F;notify解法 第一题"></a>wait&#x2F;notify解法 第一题</h2><pre><code class="java">public class PrintABCUsingWaitNotify &#123;

    private int state;
    private int times;
    private static final Object LOCK = new Object();

    public PrintABCUsingWaitNotify(int times) &#123;
        this.times = times;
    &#125;

    private void printLetter(String name, int targetState) &#123;
        for (int i = 0; i &lt; times; i++)
            synchronized (LOCK) &#123;
                while (state % 3 != targetState) &#123;
                try &#123;
                    LOCK.wait();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            state++;
            System.out.print(name);
            LOCK.notifyAll();
        &#125;
    &#125;

    public static void main(String[] args) &#123;

        PrintABCUsingWaitNotify printABC = new PrintABCUsingWaitNotify(10);
        new Thread(() -&gt; &#123;
            printABC.printLetter(&quot;A&quot;, 0);
        &#125;, &quot;A&quot;).start();
        new Thread(() -&gt; &#123;
            printABC.printLetter(&quot;B&quot;, 1);
        &#125;, &quot;B&quot;).start();
        new Thread(() -&gt; &#123;
            printABC.printLetter(&quot;C&quot;, 2);
        &#125;, &quot;C&quot;).start();
    &#125;

&#125;
</code></pre>
<h2 id="wait-notify解法-第二题"><a href="#wait-notify解法-第二题" class="headerlink" title="wait&#x2F;notify解法 第二题"></a>wait&#x2F;notify解法 第二题</h2><pre><code class="java">package cn.wideth.util.thread;

public class OddEvenPrinter &#123;

    private Object monitor = new Object();
    private final int limit;
    private volatile int count;

    OddEvenPrinter(int initCount, int times) &#123;
        this.count = initCount;
        this.limit = times;
    &#125;

    private void print() &#123;

        synchronized (monitor) &#123;
            while (count &lt; limit)&#123;
            try &#123;
                System.out.println(String.format(&quot;线程[%s]打印数字:%d&quot;, Thread.currentThread().getName(), ++count));
                monitor.notifyAll();
                monitor.wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        //防止有子线程被阻塞未被唤醒，导致主线程不退出
        monitor.notifyAll();
      &#125;
   &#125;

    public static void main(String[] args) &#123;

        OddEvenPrinter printer = new OddEvenPrinter(0, 10);
        new Thread(printer::print, &quot;odd&quot;).start();
        new Thread(printer::print, &quot;even&quot;).start();
    &#125;
&#125;
</code></pre>
<h2 id="wait-notify解法-第五题"><a href="#wait-notify解法-第五题" class="headerlink" title="wait&#x2F;notify解法 第五题"></a>wait&#x2F;notify解法 第五题</h2><pre><code class="java">package cn.wideth.util.thread;

public class NumAndLetterPrinter &#123;

    private static char c = &#39;A&#39;;
    private static int i = 0;
    static final Object lock = new Object();

    public static void main(String[] args) &#123;
        new Thread(() -&gt; printer(), &quot;numThread&quot;).start();
        new Thread(() -&gt; printer(), &quot;letterThread&quot;).start();
    &#125;

    private static void printer() &#123;
        synchronized (lock) &#123;
            for (int i = 0; i &lt; 26; i++) &#123;
                if (Thread.currentThread().getName() == &quot;numThread&quot;) &#123;
                    //打印数字1-26
                    System.out.print((i + 1));
                    // 唤醒其他在等待的线程
                    lock.notifyAll();
                    try &#123;
                        // 让当前线程释放锁资源，进入wait状态
                        lock.wait();
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125; else if (Thread.currentThread().getName() == &quot;letterThread&quot;) &#123;
                    // 打印字母A-Z
                    System.out.print((char) (&#39;A&#39; + i));
                    // 唤醒其他在等待的线程
                    lock.notifyAll();
                    try &#123;
                        // 让当前线程释放锁资源，进入wait状态
                        lock.wait();
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;
            lock.notifyAll();
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="Condition解法-第一题"><a href="#Condition解法-第一题" class="headerlink" title="Condition解法 第一题"></a>Condition解法 第一题</h2><pre><code class="java">package cn.wideth.util.thread;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class PrintABCUsingLockCondition &#123;

    private int times;
    private int state;
    private static Lock lock = new ReentrantLock();
    private static Condition c1 = lock.newCondition();
    private static Condition c2 = lock.newCondition();
    private static Condition c3 = lock.newCondition();

    public PrintABCUsingLockCondition(int times) &#123;
        this.times = times;
    &#125;

    public static void main(String[] args) &#123;
        PrintABCUsingLockCondition print = new PrintABCUsingLockCondition(10);
        new Thread(() -&gt; &#123;
            print.printLetter(&quot;A&quot;, 0, c1, c2);
        &#125;, &quot;A&quot;).start();
        new Thread(() -&gt; &#123;
            print.printLetter(&quot;B&quot;, 1, c2, c3);
        &#125;, &quot;B&quot;).start();
        new Thread(() -&gt; &#123;
            print.printLetter(&quot;C&quot;, 2, c3, c1);
        &#125;, &quot;C&quot;).start();
    &#125;

    private void printLetter(String name, int targetState, Condition current, Condition next) &#123;
        for (int i = 0; i &lt; times;)&#123;
            lock.lock();
            try &#123;
               while (state % 3 != targetState) &#123;
                  current.await();
               &#125;
            state++;
            i++;
            System.out.print(name);
            next.signal();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            lock.unlock();
        &#125;
      &#125;
   &#125;
&#125;
</code></pre>
<h2 id="Semaphore解法-第一题"><a href="#Semaphore解法-第一题" class="headerlink" title="Semaphore解法 第一题"></a>Semaphore解法 第一题</h2><pre><code class="java">import java.util.concurrent.Semaphore;

public class PrintABCUsingSemaphore &#123;

    public static void main(String[] args) &#123;
        // 初始化许可数为1，A线程可以先执行
        Semaphore semaphoreA = new Semaphore(1);
        // 初始化许可数为0，B线程阻塞
        Semaphore semaphoreB = new Semaphore(0);
        // 初始化许可数为0，C线程阻塞
        Semaphore semaphoreC = new Semaphore(0);

        new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                try &#123;
                    // A线程获得许可，同时semaphoreA的许可数减为0,进入下一次循环时
                    // A线程会阻塞，知道其他线程执行semaphoreA.release();
                    semaphoreA.acquire();
                    // 打印当前线程名称
                    System.out.print(Thread.currentThread().getName());
                    // semaphoreB许可数加1
                    semaphoreB.release();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, &quot;A&quot;).start();

        new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                try &#123;
                    semaphoreB.acquire();
                    System.out.print(Thread.currentThread().getName());
                    semaphoreC.release();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, &quot;B&quot;).start();

        new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                try &#123;
                    semaphoreC.acquire();
                    System.out.print(Thread.currentThread().getName());
                    semaphoreA.release();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, &quot;C&quot;).start();
    &#125;
&#125;
</code></pre>
<h2 id="Semaphore解法-第三题"><a href="#Semaphore解法-第三题" class="headerlink" title="Semaphore解法 第三题"></a>Semaphore解法 第三题</h2><pre><code class="java">public class LoopPrinter &#123;

    //线程个数
    private final static int THREAD_COUNT = 3;
    private static int result = 0;
    //最大数字
    private static int maxNum = 10;

    public static void main(String[] args) throws InterruptedException &#123;

        final Semaphore[] semaphores = new Semaphore[THREAD_COUNT];
        for (int i = 0; i  &lt; THREAD_COUNT; i++)&#123;           //非公平信号量，每个信号量初始计数都为1
            semaphores[i] = new Semaphore(1);
            if (i != THREAD_COUNT - 1) &#123;
               //  System.out.println(i+&quot;===&quot;+semaphores[i].getQueueLength());
               //获取一个许可前线程将一直阻塞, for 循环之后只有 syncObjects[2] 没有被阻塞
                 semaphores[i].acquire();
            &#125;
        &#125;

        for (int i = 0; i  &lt; THREAD_COUNT; i++)&#123;          // 初次执行，上一个信号量是 syncObjects[2]
            final Semaphore lastSemphore = i == 0 ? semaphores[THREAD_COUNT - 1] : semaphores[i - 1];
            final Semaphore currentSemphore = semaphores[i];
            final int index = i;
            new Thread(() -&gt; &#123;
            try &#123;
             while (true) &#123;
                // 初次执行，让第一个 for 循环没有阻塞的 syncObjects[2] 先获得令牌阻塞了
                lastSemphore.acquire();
                System.out.println(&quot;thread&quot; + index + &quot;: &quot; + result++);
                if (result &gt; maxNum) &#123;
                    System.exit(0);
                &#125;
                // 释放当前的信号量，syncObjects[0] 信号量此时为 1，下次 for 循环中上一个信号量即为syncObjects[0]
                currentSemphore.release();
             &#125;
         &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        &#125;).start();
       &#125;
    &#125;
&#125;
</code></pre>
<h2 id="LockSupport解法-第一题"><a href="#LockSupport解法-第一题" class="headerlink" title="LockSupport解法 第一题"></a>LockSupport解法 第一题</h2><pre><code class="java">import java.util.concurrent.locks.LockSupport;

public class PrintABCUsingLockSupport &#123;

    private static Thread threadA, threadB, threadC;

    public static void main(String[] args) &#123;
        threadA = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                // 打印当前线程名称
                System.out.print(Thread.currentThread().getName());
                // 唤醒下一个线程
                LockSupport.unpark(threadB);
                // 当前线程阻塞
                LockSupport.park();
            &#125;
        &#125;, &quot;A&quot;);
        threadB = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                // 先阻塞等待被唤醒
                LockSupport.park();
                System.out.print(Thread.currentThread().getName());
                // 唤醒下一个线程
                LockSupport.unpark(threadC);
            &#125;
        &#125;, &quot;B&quot;);
        threadC = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                // 先阻塞等待被唤醒
                LockSupport.park();
                System.out.print(Thread.currentThread().getName());
                // 唤醒下一个线程
                LockSupport.unpark(threadA);
            &#125;
        &#125;, &quot;C&quot;);
        threadA.start();
        threadB.start();
        threadC.start();
    &#125;
&#125;
</code></pre>
<h2 id="LockSupport解法-第五题"><a href="#LockSupport解法-第五题" class="headerlink" title="LockSupport解法 第五题"></a>LockSupport解法 第五题</h2><pre><code class="java">import java.util.concurrent.locks.LockSupport;

public class NumAndLetterPrinterByLockSupport &#123;

    private static Thread numThread, letterThread;

    public static void main(String[] args) &#123;

        letterThread = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 26; i++) &#123;
                System.out.print((char) (&#39;A&#39; + i));
                LockSupport.unpark(numThread);
                LockSupport.park();
            &#125;
        &#125;, &quot;letterThread&quot;);

        numThread = new Thread(() -&gt; &#123;
            for (int i = 1; i &lt;= 26; i++) &#123;
                System.out.print(i);
                LockSupport.park();
                LockSupport.unpark(letterThread);
            &#125;
        &#125;, &quot;numThread&quot;);
        numThread.start();
        letterThread.start();
    &#125;
&#125;
</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2022/10/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/" title="数据库使用规范"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 数据库使用规范</span></a><a class="button is-default" href="/2022/09/01/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/" title="盛最多水的容器"><span class="has-text-weight-semibold">下一页: 盛最多水的容器</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="cygnusdark/cygnusdark" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/cygnusdark"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Cygnus Dark 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by CygnusDark &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/cygnusdark">Theme by CygnusGarden&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/cygnusdark/cygnusgarden" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>